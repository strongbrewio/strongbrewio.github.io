<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link>https://blog.strongbrew.io/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Opinionated guidelines for large nx angular projects</title>
	  <link>//opinionated-guidelines-for-large-nx-angular-projects/</link>
	  <author></author>
	  <pubDate>2018-12-08T00:00:00+00:00</pubDate>
	  <guid>//opinionated-guidelines-for-large-nx-angular-projects/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>This article contains a set of opinionated guidelines when it comes to building monorepos with <a href="https://nrwl.io/nx">Nx</a>.
I wrote this article because when I used Nx in the beginning, I struggled a lot with how to structure my workspace, and I’ve hit quite a few walls. That being said, I’ve been using it for a while now, and I finally have the feeling that I’ve reached a structure where I feel comfortable with.</p>

<h2 id="a-word-about-nx">A word about Nx</h2>

<p>Nx is a thin layer on top of the <a href="https://angular.io">Angular</a> CLI that helps us with structuring large applications in the form of monorepos.
A monorepo contains only one <a href="https://nrwl.io/nx/guide-nx-workspace">Nx workspace</a> that can contain multiple apps and multiple libs (we will refer to apps and libs as Nx projects). An app is a deployable unit and a lib is meant to contain the actual logic that can be shared across the workspace. Nx is actively being developed and updated along with Angular by the amazing people of <a href="https://nrwl.io/">Nrwl</a>.</p>

<p>Nx is especially valuable when managing <strong>big Angular applications</strong> that have a lot of shared functionality, but even in smaller projects it can help organize your approach.</p>

<p>At StrongBrew we are using this technology for a bunch of our clients and even though Nx is already pretty opinionated, I decided to write down some best practices and guidelines that I try to take in consideration.</p>

<p>The rules and guidelines written down in this article <strong>might work for you</strong>, and should in no circumstances be treated as the <em>ultimate truth</em>. Best practices and guidelines are mostly a matter of perception and personal preference. Nevertheless, I would love to share how I architect large Angular applications with Nx.</p>

<h2 id="barrel-files">Barrel files</h2>

<p>When it comes to managing monorepos, barrel files are quite important.
A barrel file is a <code>index.ts</code> file that lives in the <code>src</code> directory of every Nx lib and is meant to expose logic to the rest of the workspace.</p>

<p>This file is really important when you understand one of the big potential risks of organizing code in monorepos - overexposure of implementation details.</p>

<p>With code being located right next to each other, it can be easy to import code with deeply nested relative paths and include things that the original author of the code never intended to be used outside of their specific context.</p>

<p>The Nx lib’s <code>index.ts</code> file allows each lib to define its effective public API - only symbols which are explicitly exported from this file should be eligible for consumption in other parts of the workspace.</p>

<p>Let’s say that we have a <code>@strongbrew/users</code> lib which exposes a <code>UserService</code>…
This is what the barrel file from  <code>@strongbrew/users</code> might look like.</p>

<pre><code class="language-typescript">// libs/users/src/index.ts
export * from './lib/services/user.service';
</code></pre>

<p>Although this might seem pretty straight forward, let’s go over a few best-practices…</p>

<h3 id="dont-ever-import-a-lib-from-a-relative-path">Don’t ever import a lib from a relative path</h3>

<p>When we want to import <code>UserService</code> inside another lib or app, we want to import it from <code>@strongbrew/users</code>. This is way cleaner then importing it from a relative path like <code>../../../users/lib/src/index.ts</code> and helps protect us from the overexposure problem described above. Nx also provides a linting rule out of the box to make sure that you are respecting a lib’s API and not doing deep imports.</p>

<p>Nx uses TypeScript <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping">path mapping</a> to map these module names to the correct barrel files.</p>

<pre><code class="language-json">"paths": {
    "@strongbrew/users": {
        "libs/users/src/index.ts"
    }
}
</code></pre>

<h3 id="only-1-barrel-file-per-lib">Only 1 barrel file per lib</h3>

<p>It’s a known fact that barrel files might become big, but it gives us a central place of handling all the exports + it drastically reduces the chance of getting circular reference errors. Therefore, a lib should only contain 1 single barrel file.</p>

<h3 id="never-let-a-lib-import-from-its-own-barrel-file">Never let a lib import from its own Barrel file</h3>

<p>The TypeScript modules within a particular lib should not care what functionality that lib exposes, so it shouldn’t use its own barrel file at any point.</p>

<p>If a module imports something from its own barrel file, it almost always results in circular reference errors. Therefore, imports from inside of the module should use relative path imports.</p>

<h2 id="structuring-the-workspace">Structuring the workspace</h2>

<p>When using Nx, we might already get pushed in an opinionated way of working, which is great. But how are we going to structure the workspace itself? For instance, looking into a directory of 100 libs inside of a libs directory might not really be pragmatic to work with…</p>

<h3 id="structuring-apps">Structuring apps</h3>

<h4 id="an-app-should-be-an-empty-shell">An app should be an empty shell</h4>

<p>Apps are deployable units that wire the different pieces of an application together. These apps are nearly empty shells that use libs to build an entire application. Therefore <strong>an app holds almost no logic</strong> and mostly uses lazy loading to load feature libs. Some feature libs can be seen as microfrontends.
That being said, our apps mostly not completely empty. In general they also contain:</p>
<ul>
  <li>The general layout (composed out of components from ‘ui-kit’)</li>
  <li>Routing</li>
</ul>

<h4 id="keep-the-apps-directory-as-flat-as-possible">Keep the apps directory as flat as possible</h4>

<p>Chances are small that our monorepo will contain 100+ apps and even if it does, chances are small that we can divide these apps into categories.</p>

<h4 id="apps-should-not-import-from-other-apps">Apps should not import from other apps</h4>

<p>Although it might seem obvious, let’s mention it anyway… Shared logic should always live inside of libs, an not inside of apps. Apps are specific deployment targets.</p>

<h3 id="structuring-libs">Structuring libs</h3>

<p>Here comes the opinionated part, lets check how we can structure the libs inside of our workspace.</p>

<p>The directory structure of our workspace might look like this:</p>
<ul>
  <li><code>apps</code></li>
  <li><code>libs</code>
    <ul>
      <li><code>feature</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>…</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>ui-kit</code></li>
      <li><code>utils</code></li>
    </ul>
  </li>
  <li>A feature contains logic specific to a certain domain, like managing users or performing authentication.</li>
  <li>On the other hand, the <code>utils</code> lib contains logic that doesn’t have anything to do with any domain, E.g: HTTP interceptors, shared RxJS operators, a service that handles notifications etc… Consider it a toolkit for your workspace.</li>
</ul>

<p>In the next few sections we are going to cover the 3 types of feature libs, the <code>ui-kit</code> lib and the <code>utils</code> lib.</p>

<h4 id="featureapi">feature/api</h4>

<p>This directory contains Nx libs with a very specific purpose:</p>
<ul>
  <li>These libs contain <strong>api logic</strong> or <strong>business logic</strong> that needs to be shared.</li>
  <li>These libs contain the types of the REST responses. Let’s call them <strong>domain types</strong>.</li>
  <li>If we want to work with models, or dto’s, these would also live here.</li>
</ul>

<p>Having a specific api lib is very handy when developing in a microservices platform. Every microservice would have its own <strong>api lib</strong> that can be used throughout the entire monorepo.</p>

<p>Another common use-case is that feature libs tend to use domain types from other feature libs. By extracting these domain types in to api libs, we solve that problem. That way, these domain types can be shared across different places inside of the monorepo.</p>

<h4 id="featurelazy">feature/lazy</h4>

<p>This directory contains all feature libs that can be lazyloaded. To make sure these libs can be lazy-loaded, they should expose an <code>NgModule</code> in the barrel file and are loaded as such:</p>

<pre><code class="language-typescript">RouterModule.forRoot([
    {
        path: 'users',
        loadChildren: '@strongbrew/feature/lazy/users'
    }
])
</code></pre>

<p>One of the advantages is that these modules can be loaded on demand or even preloaded upfront. The biggest advantage though is that these modules are completely standalone, and don’t share anything with the rest of the workspace. This means they have nothing inside of their barrel file, other then the <code>NgModule</code> being exported. 
<strong>Lazy loaded modules can never share logic with the workspace</strong>
If we feel that a lazyloaded module needs to export something, we should extract that logic into a separate <code>feature/shared</code> or <code>feature/api</code> lib.</p>

<p>When a <code>feature/lazy</code> module needs to perform XHR calls it should delegate it to a <code>feature/api</code> lib. Therefore a <code>feature/lazy</code> lib should never contain api logic.</p>

<p>When using a statemanagement library like <a href="https://github.com/ngrx/platform">ngrx/store</a>, <code>feature/lazy</code> libs would contain their own reducers and use <code>store.forFeature()</code> to attach these to the <code>store</code> instance. This would result in lazy-loaded reducers.</p>

<h4 id="featureshared">feature/shared</h4>

<p>Not every feature can be lazyloaded. Think about feature logic that needs to be shared for instance. In that case we would create an Nx lib that lives inside of the <code>feature/shared</code> directory.</p>

<p>When a <code>feature/shared</code> module needs to perform XHR calls it should delegate it to a <code>feature/api</code> lib. Therefore the <code>feature/lazy</code> lib should not contain api logic.</p>

<h4 id="ui-kit">ui-kit</h4>

<p>This lib contains all the shared presentational components that can be used in different applications. Think about dropdowns, datepickers and empty modals. A <code>user-detail</code> component for instance does NOT belong here. A monorepo can contain multiple <code>ui-kit</code> libraries. We should name them according to its purpose. E.g <code>ui-kit-mobile</code> is a common use case.</p>

<p>The Ui-kit module contains an <code>ngModule</code> since we need it to declare and export our components/directives. The barrel file generally only exposes the <code>ngModule</code> since this is the vessel used to export the functionality.</p>

<p>However, a <code>ui-kit</code> might also export certain types in its barrel file… Like <code>DatepickerConfiguration</code> or other <code>ui-kit</code> specific types.</p>

<h4 id="utils">utils</h4>

<p>This lib can contain all kinds of utilities. It could contain shared interceptors, guards, services and custom RxJS operators. Think about it als a framework toolbox that could benefit any application. We will NOT use an <code>ngModule</code> here for tree-shaking purposes.</p>

<p>A <code>utils</code> lib will not contain any components. But if it contains pipes or directives we might need an <code>ngModule</code> for that.</p>

<p>When your workspace is small, one single <code>utils</code> lib might suffice, but it could become a good idea to split these up when the <code>utils</code> lib gets to big.</p>

<p>After splitting up, the directory structure of our workspace might look like this:</p>
<ul>
  <li><code>apps</code></li>
  <li><code>libs</code>
    <ul>
      <li><code>feature</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>…</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>ui-kit</code></li>
      <li><code>utils</code>
        <ul>
          <li><code>rxjs-operators</code></li>
          <li><code>forms</code></li>
          <li><code>http</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Do note, that the <code>forms</code> lib would not contain any forms or forms configuration, but it would contain general form logic that can be shared across the workspace.</p>

<h3 id="prefixing-libs">Prefixing libs</h3>

<p>Because of the fact that <code>selector</code> names for components and directives should be unique, prefixing them in a monorepo is quite important. 
Since every project in the <code>angular.json</code> file has a <code>prefix</code> property, we could set that prefix for every project.</p>

<p>Let’s assume that we need a <code>feature/shared</code> lib called <code>messages</code> then we could generate that lib by running <code>ng g lib messages --prefix sh-mes</code> for instance. 
<code>sh-mes</code> would be the prefix and if we create a message component in this lib it would have the selector: <code>sh-mes-message</code>.</p>

<h2 id="linting-and-tags">Linting and tags</h2>

<p>One thing that is absolutely critical when managing a monorepo is being able to determine, categorize, and constrain/run commands based on a dependency graph.</p>

<p>Nx determines the dependency graph for us out of the box, it infers it by statically analyzing our TypeScript import and export statements (as well as a few other things specific to the Angular CLI).</p>

<p>It has no way of automatically categorizing the dependency graph for it, because that is up to our subjective judgement, but it does provide helpers to make it easy.</p>

<p>Nx provides us with the ability to add tags to the different libs and apps and apply <a href="https://palantir.github.io/tslint/">tslint</a> rules to make sure we can’t import whatever we want wherever we want.	Nx provides us with the ability to add tags to the different libs and apps and apply <a href="https://palantir.github.io/tslint/">tslint</a> rules to make sure we can’t import whatever we want wherever we want (potentially leading to circular references and other problems (broken lazyloading, etc…)).</p>

<p>Tags can be added to projects in the <code>nx.json</code> file of the root directory.
Tags can be determined in numerous ways. Some of us might like a tag per team, other might like it per domain.</p>

<p>I like to have tags for every lib type. It might be opinionated but it works fine for me (again, that’s a matter of personal preference)</p>

<p>We define 5 types of tags:</p>

<ul>
  <li><code>app</code>: This tag is added to all the apps</li>
  <li><code>shared</code>: This tag is added to <code>uikit</code> and <code>utils</code> libs</li>
  <li><code>feature:lazy</code>: This tag is added to <code>feature/lazy</code> libs</li>
  <li><code>feature:shared</code>: This tag is added to <code>feature/shared</code> libs</li>
  <li><code>feature:api</code>: This tag is added to <code>feature/api</code> libs</li>
</ul>

<p>The rules could be the same for every workspace that we will create in the future:</p>

<ul>
  <li>Projects with the type <code>tag</code> can only depend on projects with the tags: <code>shared</code> or <code>feature:shared</code>.</li>
  <li>Projects with the type <code>shared</code> can only depend on projects with the tags: <code>shared</code> (we don’t want to import domain specific logic in there do we?)</li>
  <li>Projects with the type <code>feature:lazy</code> can only depend on projects with the tags: <code>shared</code>, <code>feature:shared</code> and <code>feature:api</code>.</li>
  <li>Projects with the type: <code>feature:shared</code> can only depend on projects with the tags: <code>shared</code> and <code>feature:api</code>.</li>
  <li>Projects with the type: <code>feature:api</code> can only depend on projects with the tags: <code>feature:api</code> and <code>shared</code>. (we never want to load <code>feature:shared</code> into an feature/api lib right?)</li>
</ul>

<h3 id="configuring-tslint">Configuring tslint</h3>

<p>To configure the tslint we have to use the <code>nx-enforce-module-boundaries</code> rule from tslint. If you like the rules defined above, you can just copy-paste the module boundaries defined below right in your <code>tslint.json</code> file that lives in the root directory.</p>

<pre><code class="language-json">"nx-enforce-module-boundaries": [
  true,
    {
      "allow": [],
      "depConstraints": [
      {
        "sourceTag": "app",
        "onlyDependOnLibsWithTags": ["shared", "feature:shared"]
      },
      {
        "sourceTag": "shared",
        "onlyDependOnLibsWithTags": ["shared"]
      },
      {
        "sourceTag": "feature:lazy",
        "onlyDependOnLibsWithTags": [
          "shared",
          "feature:shared",
          "feature:api"
        ]
      },
      {
        "sourceTag": "feature:api",
        "onlyDependOnLibsWithTags": ["feature:api", "shared"]
      },
      {
        "sourceTag": "feature:shared",
        "onlyDependOnLibsWithTags": ["shared", "feature:api"]
      }
      ]
    }
]
</code></pre>

<p>This tslint config will ensure that the rules defined above are mandatory.</p>

<h2 id="is-this-structure-the-only-way">Is this structure the only way?</h2>

<p>No, not at all, this would work perfectly for a monorepo with 5 applications. But if we are thinking about organisation wide monorepos, it might be a good idea to
combine features app per app. In that case we would have something like:</p>
<ul>
  <li><code>apps</code></li>
  <li><code>libs</code>
    <ul>
      <li><code>app1</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>…</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>app2</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>…</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>…</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>ui-kit</code></li>
      <li><code>utils</code>
        <ul>
          <li><code>rxjs-operators</code></li>
          <li><code>forms</code></li>
          <li><code>http</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="how-to-share-code-organisation-wide">How to share code organisation wide?</h2>

<p>Although an organisation wide monorepo has great benefits, they might be good reasons not to do it. These could be any combination of technical, cultural, legal or other reasons.</p>

<h3 id="scenario-a">Scenario A</h3>

<p>Our company has 10 angular projects that are actively developed and share a lot of code, but also had 5 legacy projects where there is no budget to bump them to the new Angular versions and so on. There might be a few <a href="https://vuejs.org/">Vue.js</a> or <a href="https://reactjs.org/">React</a> living there as well. It might be more trouble than it is worth for your organization to manage that complexity within one big workspace. In that case we could have a workspace for the non-legacy angular projects, and that workspace would gladly welcome new projects in the future.</p>

<h3 id="scenario-b">Scenario B</h3>

<p>Our company sells custom software to different clients. Every client wants its own custom look and feel, which a lot of custom logic, but we don’t want to reinvent the wheel every time.</p>

<p>In that case, we could create an Nx worspace for every client, and have one common toolkit that contains shared logic. That toolkit would live in its own monorepo and be published as an Angular package.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I hope we learned something today. How we structure our workspaces is completely up to us, and we should use something that works for us, not just pick whatever you read in some blog article ;-). If this structure doesn’t make sense to you, that’s perfectly fine… And I would love to hear your thoughts about this approach.</p>

<h2 id="special-thanks-to">Special thanks to</h2>

<p>Thanks to the people that have reviewed the article and gave great input!
I couldn’t have done it without you!</p>

<ul>
  <li><a href="https://twitter.com/beeman_nl">@beeman_nl</a></li>
  <li><a href="https://twitter.com/mrjameshenry">@MrJamesHenry</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Safe HTTP calls with RxJS</title>
	  <link>//safe-http-calls-with-rxjs/</link>
	  <author></author>
	  <pubDate>2018-10-24T00:00:00+00:00</pubDate>
	  <guid>//safe-http-calls-with-rxjs/</guid>
	  <description><![CDATA[
	     <p>Hi there, since it’s very busy lately this will probably be my one of my shortest articles ever.
Maybe that’s a good thing, because now you don’t have an excuse not to read it. It’s short, compact
and maybe you will learn a thing or two.</p>

<h2 id="the-problem">The problem</h2>

<p>The article is all about making sure our HTTP calls don’t die on bad connections, since strangely enough, <strong>404 responses can kill your application when using RxJS</strong>.</p>

<p>Remember that RxJS observables have 3 types of events right?</p>
<ul>
  <li><code>next</code>: passing in a new value into the observable</li>
  <li><code>error</code>: when an error occurs</li>
  <li><code>complete</code>: When the observable is completed</li>
</ul>

<p>We should not forget that <strong>an Error event will actually stop the observable</strong>. It will cease to exist.</p>

<p>You might say: “That’s not that bad, we’ll just create a new one every time we want to fetch data”.</p>

<p>When you are approaching your application the <em>reactive way</em>, this scenario might be problematic:
Imagine a typeahead search where we want to retrieve results for every input value. We have an observable of searchterms and we trigger the
HTTP request for every value using a <code>switchMap</code>.</p>

<pre><code class="language-typescript">// this observable contains the values
// of what the user is searching for
// over time
const searchTerm$: Observable&lt;string&gt;;

// when the term receives a new value...
// go fetch some data
const results$ = searchTerm$.pipe(
    switchMap(term =&gt; fetchData(term))
)

// subscribe to the observable to start listening
results$.subscribe((response: Result[]) =&gt; {
    console.log(response);
})
</code></pre>
<p>This all works fine, until an error happens in the observable. This could come from a bad connection, server down-time or anything that went wrong during the HTTP request (500, 404, …) 
If the user is having a bad connection which might result in a <code>404</code>, the observable will stop and the application will be broken. The user can search for results as much as he or she wants, the HTTP calls will never happen again.</p>

<h2 id="catcherror">catchError</h2>

<p>We could use the <code>catchError</code> operator that will basically catch the error for us, and return a brand new observable(containing the error).
That observable will have the error as a value, instead of throwing it again as an error.
That way we could actually show the user a decent message.
This might look something like this:</p>

<pre><code class="language-typescript">const results$ = searchTerm$.pipe(
    switchMap(term =&gt; 
        fetchData(term).pipe(
            // return an observable with the error inside
            catchError(e =&gt; of(e))
        )
    )
)
results$.subscribe(
    (response: Result[] | HttpErrorResponse) =&gt; {
        if(response instanceof HttpErrorResponse){
            console.log('oh no:(');
            return;
        }
        console.log('do something fancy');
    });
)
</code></pre>

<p>Ps: I’m not trying to say that this is the best idea to catch errors. I’m just showing you around some basics.</p>

<p>Do note that the <code>catchError</code> operator is applied to the result observable that <code>fetchData()</code> returns, and not added as the second operator of the first pipe. 
From the moment an observable receives an error, it will die… That’s why it’s important to catch the error on the inner observable.</p>

<h2 id="retrywhen">retryWhen</h2>

<p>Ok, great! The application won’t break anymore, but now imagine the following scenario: Our user is sitting in the train and drives through a tunnel. The connection is gone for a few seconds and the user won’t get results.</p>

<p>We could fix that by telling RxJS to retry a few times</p>

<pre><code class="language-typescript">const results$ = searchTerm$.pipe(
    switchMap(term =&gt; 
        fetchData(term).pipe(
            retryWhen(e$ =&gt; e$.pipe(
                // try again after 2 seconds
                delay(2000),
                // stop trying after 5 times
                take(4)
            )
            // still keep the observable alive if
            // the first 5 times fail
            catchError(e =&gt; of(e))
        )
    )
)
</code></pre>

<p>You can find more information about <code>retryWhen</code><a href="https://www.learnrxjs.io/operators/error_handling/retrywhen.html">here</a></p>

<h2 id="using-the-online-event">Using the online event</h2>

<p>Even though this is a good solution, there is room for improvement. A great choice is to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/Online_and_offline_events">online</a> event from HTML5 to tell the browser to retry when the user regains internet connection. It’s even shorter than before and it’s super elegant</p>

<pre><code class="language-typescript">const results$ = searchTerm$.pipe(
    switchMap(term =&gt; 
        fetchData(term).pipe(
            retryWhen(() =&gt; fromEvent(window, 'online'))
            // still keep the observable alive if
            // the server would return a different
            // HTTP error
            catchError(e =&gt; of(e))
        )
    )
)
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>RxJS gives us great control over HTTP calls! If we know how error handling works it becomes a breeze to take our HTTP calls to the next level.
This doesn’t only apply to typeahead searches but to every observable where we combine an existing stream with an error-affected one like HTTP. For instance: this can also happen in NgRx effects or with the angular router.</p>

<p>There, I told you it would be short, I hope you learned something though.</p>

<p>Also be sure to check this article: <a href="https://blog.angularindepth.com/power-of-rxjs-when-using-exponential-backoff-a4b8bde276b0">Power of RxJS when using exponential backoff</a></p>

<h2 id="special-thanks">Special thanks</h2>

<ul>
  <li><a href="https://twitter.com/AmarildoKurtaj">@AmarildoKurtaj</a> The last example was based on his idea</li>
</ul>

<p>Reviewers:</p>
<ul>
  <li><a href="https://twitter.com/fmalcher01">Ferdinand Malcher</a></li>
  <li><a href="https://twitter.com/FabianGosebrink">Fabian Gosebrink</a></li>
  <li><a href="https://twitter.com/tim_deschryver">Tim deschryver</a></li>
  <li><a href="https://twitter.com/webdave_de">David Müllerchen</a></li>
  <li><a href="https://twitter.com/rubenverm">Ruben Vermeulen</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Redux (@ngrx/store) best practices</title>
	  <link>//Redux-best-practices/</link>
	  <author></author>
	  <pubDate>2018-04-27T00:00:00+00:00</pubDate>
	  <guid>//Redux-best-practices/</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">@ngrx/store</a> is a library that tries to solve the problems of state management through the principles of <a href="https://redux.js.org/">Redux</a>. The difference between Redux and @ngrx/store is that @ngrx/store is written specifically for <a href="https://angular.io">Angular</a> and it embraces the use of Observables from <a href="http://reactivex.io/rxjs/">RxJS</a>.
The combination of redux principles and RxJS can be very powerful when it comes to writing reactive applications.
Since a lot of Angular projects use @ngrx/store, it might be a good idea to write down some best-practices.</p>

<p>Note: The best-practices and opinions described in this article are strictly personal. Best practices are almost always a matter of opinion. Nevertheless, we (StrongBrew) are using these best practices at all our customers on a daily basis and they certainly work for us.   From now on @ngrx/store will be reffered to as Redux in this article.</p>

<h2 id="to-redux-or-not-to-redux">To Redux or not to Redux?</h2>

<p>The first question that we might want to ask ourselves is do we really need Redux in our application.
It is a best practice to only use it when your application demands it.
<a href="https://blog.strongbrew.io/do-we-really-need-redux">This article</a> tackles this question separately.</p>

<h2 id="basic-best-practices">Basic best practices</h2>

<p>While the following list might be common sense for an experienced Redux developer, let’s sum those up as a refreshment for the sake of completeness.</p>
<ul>
  <li>Our application can only count one store, otherwise it would become too complex</li>
  <li>Reducers have to be pure, this is a principle from functional programming which makes functions predictable and avoids side effects</li>
  <li>Immutable datastructures are very important to optimise change detection cycles and avoid unexpected behavior, therefore reducers should handle data in an immutable manner</li>
  <li>Reducers always have to return a value! So don’t forget to implement the default case of the switch statement to return the original state</li>
</ul>

<h2 id="dont-add-models-to-the-store">Don’t add models to the store</h2>

<p>A model can be seen as a javascript object which has functionality, like the following example:</p>

<pre><code class="language-typescript">class User{
    constructor(private firstName: string, private lastName:string){
    }

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`; 
    }
}
</code></pre>

<p>While the Redux package written by Dan Abramov forbids sending these prototyped objects as a payload, @ngrx/store does not forbid it yet.
However, it is a bad practice because it adds a lot of complexity to the store and chances are big that the models will get broken because of the immutable way of handling data. Check this example for instance:</p>

<pre><code class="language-typescript">const user = new User('Brecht', 'Billiet');
console.log(user.fullName); // Brecht Billiet
const updatedUser = {...user, lastName: 'Doe'};
console.log(updatedUser.fullName); // undefined
</code></pre>

<p>Since we have updated the user in an immutable way, it has created a new reference and therefore all its functionality has been lost.
This is exactly what our reducers will do with the data that flows into them. So always send plain objects when it comes to sending payloads in the actions.</p>

<p>Another approach for models is using Interfaces. Interfaces are great because are only interpreted in compile time, doesn’t use memory in runtime and are very expressive. If your model doesn’t need to be computed (like <code>get fullName()</code> in the previous example), then is advisable to use Interfaces instead.</p>

<p>Using Interfaces allows us to get advantage of some TypeScript features like <code>Pick&lt;T&gt;</code>. With <code>Pick&lt;T&gt;</code> we can create Types from Interfaces, which is very handy in some situations, like creating a model and a record with fewer properties:</p>

<pre><code class="language-typescript">export interface User {
    id: number;
    name: string;
    middleName: string;
    lastName: string;
    fullName: string;
    address: string;
    city: string;
    state: string;
    zip: string;
}

export type UserRecord = Pick&lt;User, 'id' | 'fullName'&gt;;
</code></pre>

<p>If the endpoint to get a list of users is returning a partial object instead of the full object then we can create a new Type instead of two Classes or Interfaces. This is a cleaner approach and easier to maintain if your models are prepared for your UI.</p>

<h2 id="what-do-we-put-in-the-store">What do we put in the store?</h2>

<p>We shouldn’t put things in the store just because we can. We have to think about what state needs to be in there and why.
State that is being shared between components can sometimes be kept in the parent component for instance. We call that inner state:
The component keeps its own state, the component itself is responsible for that. If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux.</p>

<p>However, when state needs to be shared between different root components (rendered inside a router-outlet) we might want to keep that state in the store.</p>

<p>When we need to remember a value when navigating through the application we could put that in the store as well. An example here could be: Remembering if a sidebar was collapsed or not, so when we navigate back to the page with the sidebar, it would still be collapsed.</p>

<p>Complex state is something that we might want to put in the store as well, since Redux can handle complex state management in an elegant way.
The general rule of thumb here could be, <strong>Only keep shared state, values that we want to remember and complex state in the store</strong>. Don’t add state in the store if we don’t need to, it would result in unneeded boilerplate and complexity.</p>

<p>That being said, there are 2 more reasons where we might want to add extra state into the store:</p>
<ul>
  <li>When we want to make our application real-time. Check out <a href="https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/">How we made our app real time in 6 lines of code</a>.</li>
  <li>When we want to do optimistic updates. Check out <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">Cancellable optimistic updates in Angular2 and Redux</a></li>
</ul>

<h2 id="dont-forget-about-router-params">Don’t forget about router params</h2>

<p>A common mistake is putting things inside the store that could easily be added in the url.
The benefit of keeping state in the url is:</p>

<ul>
  <li>We can use the browser navigation buttons</li>
  <li>We can bookmark the url</li>
  <li>We can share that url with other people</li>
</ul>

<p>If we can put simple things into the url, we should at least consider it.</p>

<h2 id="avoid-huge-lists">Avoid HUGE lists</h2>

<p>Redux can not be seen as a local in-memory database, so we can’t put all our data into the store for performance reasons.
Redux can be seen as an abstraction of state and data that our application needs at a certain time.</p>

<p>For instance if we have a list of 10000 users, we don’t want to put them all in the store. What we could do is keep track of a list of 500 users in the store, which the user can see at that specific time, and load more users on the background and update that buffered list.</p>

<h2 id="designing-the-state">Designing the state</h2>

<p>Designing the state of our application is an important step, and we recommend to draw that state on a whiteboard first. The most important rule here is: <strong>Keep the state as flat as possible</strong></p>

<p>One of the most common bad practices is deep-nesting the state into something that becomes rather complex:</p>

<pre><code class="language-typscript">
// this is an example of how not to design state
export interface ApplicationState {
    moduleA: {
        data: {
            foo: {
                bar: {
                    users: User[],
                    cars: Car[]
                }
            }
        }
    }
}  

// keeping it flat makes the application way easier
export interface ApplicationState {
    users: User[],
    cars: Car[]
}  
</code></pre>

<p>I’m not saying you cannot nest state, I am saying we have to be very careful when we do. The general rule of thumb here is: <strong>keep the state as flat as possible</strong>
If we want to compose state in @ngrx/store we can work with feature module reducers and lazy load them as we can see in <a href="https://github.com/ngrx/platform/blob/master/docs/store/api.md#feature-module-state-composition">Feature Module State Composition</a>.</p>

<h2 id="make-everything-readonly">Make everything readonly</h2>

<p>We already covered the reason why we need to work immutable, but how can we enforce this?
Typescript comes with a readonly keyword which we can use to make a property readonly</p>

<pre><code class="language-typescript">type User = {
    readonly firstName: string;
    readonly lastName: string;
}

const user: User = {firstName: 'Brecht', lastName: 'Billiet'};
user.lastName = 'Doe';//cannot assign to 'lastName' 
// because it is a constant of read-only property
</code></pre>

<p>This would certainly make sure we aren’t updating properties in our reducers by accident. It does suck that we have to write readonly for every property.
The cool thing is that typescript offers us something called “advanced types” where we can do something like this:</p>

<pre><code class="language-typescript">// By using the Readonly&lt;&gt; advanced types all the properties inside the type
// are readonly by default
type User = Readonly&lt;{
    firstName: string;
    lastName: string;
}&gt;;
</code></pre>

<h2 id="action-design">Action design</h2>

<h3 id="actiontypes">Actiontypes</h3>

<p>An action type should be a string that explains what the action should change in the store. Keep these strings consistent. Don’t make the actiontypes too long, keep them short and clear.</p>

<pre><code class="language-typescript">// This is bad
const DATA_USERS_SET_USER_ADDRESS = 'DATA_USERS_SET_USER_ADDRESS';

// This is better
const SET_USER_ADDRESS = 'SET_USER_ADDRESS';

</code></pre>

<p>Another cool idea might be to suffix the action with square brackets and put the whole thing into an action object:</p>

<pre><code class="language-typescript">
// Easy to read/debug
const UserActions = {
  SET_ADDRESS: '[USER] ADDRESS'
}

</code></pre>

<p>If the state managment would become very large we could prefix the action, but let’s keep it simple and small as long as we can.</p>

<h3 id="action-creator-classes">Action creator classes</h3>

<p>When we use plain action types and payloads it becomes quite painful to remember all the action type names and all the payloads that belong to them. This example for instance:</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(
    {
        type: 'SET_USER_ADDRESS', 
        payload: {user_id, address}
    });
</code></pre>

<p>That’s pretty nasty if we want remember all that stuff, so let’s create action creator classes for these. What if we could do this?</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(new SetUserAddressAction(user_id, address));
</code></pre>

<p>That’s just became way easier to use and we don’t have to remember the payload of the action.</p>

<p>If we wanted to implement the actioncreator class for this action it would look like this:</p>

<pre><code class="language-typescript">class SetUserAddressAction implements Action {
    type = SET_USER_ADDRESS;
    payload: {user_id: string, address: Address};
    constructor(user_id: string, address: Address){
        this.payload = {user_id, address};
    }
}
</code></pre>

<h3 id="payload-design">Payload design</h3>

<p>When the action would only have one property for the payload we might be encouraged to use the payload directly instead of creating a property in it. However that would lead to inconsistency, so it might be better to always use subproperties</p>

<pre><code class="language-typescript">// This is bad (inconsistent with the rest of the actions)
class UpdateUserAction implements Action {
    type = UPDATE_USER;
    payload: User;
    constructor(user: User){
        this.payload = user;
    }
}
// This is better
class UpdateUserAction implements Action{
    type = UPDATE_USER;
    payload: {user: User};
    constructor(user: User){
        this.payload = {user};
    }
}
</code></pre>

<h3 id="type-safety">Type Safety</h3>

<p>Type Safety is a huge win when using Redux with typescript, it requires a bit of boilerplate but it makes developing reducers feel like a walk in the park. It makes sure that our applications won’t compile if they have type errors and it gives us great autocompletion inside our reducers.
Therefore I would definitely consider it a must. Since <a href="https://twitter.com/KwintenP">Kwinten Pisman</a> already wrote an <a href="https://blog.strongbrew.io/type-safe-actions-in-reducers/">awesome article</a> about this we won’t go in to much detail here.</p>

<h2 id="reducer-design">Reducer design</h2>

<h3 id="destructuring-the-payload">Destructuring the payload</h3>

<p>If we want to make the reducer code more readable and shorter we could use javascript destructuring for that.
This might be personal preference, but it sure as hell makes our reducers easier to read. Take this example for instance:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS':
        return state.map(v =&gt; 
          v.id === action.payload.user_id ? 
          {...user, address: action.payload.address} : 
          v
        )
    }
}
</code></pre>
<p>The <code>action.payload.</code>code comes back a few times, resulting in longer codelines.
The following piece of code might be more readable:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS': {
        const {user_id, address} = action.payload;
        return state.map(v =&gt; 
          v.id === user_id ? 
          {...user, address} : 
          v
        )
      }
    }
}
</code></pre>

<p>As we can see have have used destructuring to extract the properties of the payload into variables.
Cleaner right? Let’s imagine that our actions has 5 or even more properties on their payloads. In that case this would definitely help.
Something to note here is that the case implementation is wrapped inside a block statement. This is important because our reducer can have the same payload properties for different actions.</p>

<p>This means that <code>user_id</code> and <code>address</code> won’t be available in the other case statements, which is exactly what we want.</p>

<h3 id="dont-write-business-logic-inside-our-reducers">Don’t write business logic inside our reducers</h3>

<p>Reducers should not contain business logic, they are used to handle the state in an immutable fashion. We won’t write business logic inside reducers because:</p>

<ul>
  <li>It would become very complex</li>
  <li>Business logic has nothing to do with state management</li>
  <li>We have services for that</li>
</ul>

<h3 id="child-reducers">Child reducers</h3>

<p>When reducers need to update a piece of state a few levels down in the tree it can become complex in no-time. Take this example for instance:</p>

<pre><code class="language-typescript">type User = {
    id: string;
    contracts: Contract[];
}
type Contract = {
    id: string;
    assignees: Assignee[];
}
type ApplicationState = {
    users: User[];
}   
...
</code></pre>

<p>If we would put all the logic to add an assignee to a specific contract of a specific user, the code would be hard to read. Checkout the following piece of code:</p>

<pre><code class="language-typescript">// This is bad
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: user.contracts.map(contract =&gt; 
            contract.id === contract_id ?
            {
              ...contract, 
              assignees: [...contract.assignees, assignee]
            } : 
            contract
          )
        } : 
        v
      )
    }
    default:
      return state;
  }
}
</code></pre>

<p>When reducers become complex it might be a good idea to split the reducer up into child reducers. Check the refactored version of the previous example:</p>

<pre><code class="language-typescript">// This is better
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: contractsReducer(contracts, action.payload)
        } : 
        v
      )
    }
    default:
      return state;
  }
}

function contractsReducer
  (state: Contract[], action: UserActions): Contract []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const { contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === contract_id ? 
        {
          ...contract, 
          assignees: [...assignees, assignee]
        } : 
        v
      )
    }
    default:
      return state;
  }
}

</code></pre>

<p>As we can see, we have extracted the handling of contracts into its own reducer, which follows the exact same principles of a regular reducer.</p>

<p>The example just became a lot easier to read and way more maintainable. When traversing complex data structures, reducer nesting can be a really elegant way of managing state.</p>

<h2 id="testing">Testing</h2>

<p>Since reducers are pure functions, unit testing them is very easy.
We won’t need to mock out any dependencies and we only have to test the value that the reducer returns.</p>

<p>We can also use <a href="https://www.npmjs.com/package/deep-freeze">deepfreeze</a> to freeze the state that when the reducer accidently mutates data, the tests will throw an error. Deepfreeze is nothing more than a recursive <code>Object.freeze</code></p>

<pre><code class="language-typescript">describe('reducer: usersReducer', () =&gt; {
  describe('case UPDATE_USER', () =&gt; {
    it('should return a new instance with the correct state', 
    () =&gt; {
      const initialState = [new User('1'), new User('2')];
      // deepfreeze makes sure the reducer 
      // doesn't mutate anything by accident
      deepfreeze(initialState); 
      const user = new User('2');
      const action = new UpdateUserAction(user);
      const newState = usersReducer(initialState, action);
      // check if the result of the array is a new ref
      expect(newState).not.toBe(initialState); 
      // check if the result of the user is a new ref
      expect(newState[1]).not.toBe(initialState[1]);
      // check if the user got updated automatically
      expect(newState[1]).toEqual(user);
    });
  });
});
  
</code></pre>

<p><strong>Note: Don’t forget to test the default action</strong></p>

<h2 id="decoupling-redux-from-the-presentation-layer">Decoupling redux from the presentation layer</h2>

<p>Having the store injected everywhere in our application is not a good idea. We want to create an Angular, Vue or React application. Not a Redux application.</p>

<p>Therefore we could consider the following as best practices:</p>
<ul>
  <li>Components don’t need to know we are using Redux, don’t inject the store in them.</li>
  <li>Services generally don’t need to know we are using Redux, don’t inject the store in them.</li>
  <li>We want to be able to refactor Redux away from our application without to much effort</li>
</ul>

<p>Therefore we want to have some kind of abstraction layer between the presentation layer and the state management layer.</p>

<p>How to abstract away the statemanagement layer can be read in the following two articles: <a href="https://blog.strongbrew.io/A-scalable-angular2-architecture/">A scalable angular architecture</a> and <a href="https://blog.strongbrew.io/A-scalable-angular-architecture-part2/">A scalable angular architecture part 2</a>.
This is an architecture that we are using at our customers that really works for us.</p>

<h2 id="redux-as-a-messaging-bus-vs-redux-as-a-state-management-layer">Redux as a messaging bus VS redux as a state management layer</h2>

<p>This might be a personal preference, but I like to use Redux as a pure state management layer. Yes, there are tools like @ngrx/effects where
we can send actions to our application and those actions won’t just perform state management but will do XHR calls among other things.</p>

<p>The nice thing about this approach is that we use some kind of messaging bus. However, I mostly like to keep it simple and abstract Redux away as much as possible. Therefore I don’t use @ngrx/effects and only use Redux to update pieces of state and consume theses pieces. Some part of me believes that Redux shouldn’t be used to perform backend calls nor decide when to optimistically update. I usually tackle optimistic updates <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">this way</a>.</p>

<p>That being said, I wouldn’t call my approach a best practice, but it is a best practice to really think about which way we want it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We learned a lot! Once again, the best practices explained in this article are based on personal experiences and projects we have worked on. These are practices that work for us. They are not meant to be seen as the only way of doing things.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>A very warm and much appreciated special thanks to the following people:</p>

<p><a href="https://twitter.com/ncjamieson">Nicholas Jamieson</a>, <a href="https://twitter.com/elecash">Raúl Jiménez</a> and <a href="https://twitter.com/FabianGosebrink">Fabian Gosebrink</a>: Thank you all so much for reviewing and pointing out some awesome ideas</p>

<p>Your input makes blogging worth while!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Do we really need Redux or @ngrx/store</title>
	  <link>//do-we-really-need-redux/</link>
	  <author></author>
	  <pubDate>2018-04-13T00:00:00+00:00</pubDate>
	  <guid>//do-we-really-need-redux/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>If you are writing Angular, Vue or React applications, chances are big that you have used or encountered the Redux pattern.
Redux helps us to structure statemanagement in an immutable matter which is great, but in order to use it correctly, we have to write a bunch of boilerplate code.
In this article I would like to tackle the question on when to use Redux and why.
The referred plugins/code samples are written in an Angular context. But the principles explained in this articles work for other frameworks as well. This also means that we are using the <a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">@ngrx/store</a> package instead of the <a href="https://redux.js.org/">Redux</a> package</p>

<h2 id="to-redux-or-not-to-redux">To Redux or not to Redux?</h2>

<p>First of all it’s important to note that Redux solves certain problems for us. If we are not experiencing those problems, then there is a big chance that the Redux pattern
is overkill for our application.</p>

<p>The first question that we might want to ask ourselves is:
<strong>Does My application have state?</strong> State can be the value of a pager that we want to remember, or the fact that a sidebar is collapsed or not. State could be a cached set of data coming from our backend, or user information that we need throughout the whole application.
It could be a simple value that we want to remember in memory when we are navigating between pages.</p>

<p>Let’s sum up some examples where the Redux principle might shine in our applications:</p>
<ul>
  <li>Storing state (like the value of a search filter so it’s still available when the user navigates back to a certain grid)</li>
  <li>Sharing state between components that have their own route, and thus won’t have a parent component to pass them the state through inputs or properties</li>
  <li>Optimistic updates: Check <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">this article</a></li>
  <li>Real-time updates: Check <a href="https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/">this article</a></li>
  <li>When we want undo/redo logic</li>
  <li>When we want to keep track of all the state changes and debug them with awesome tooling (Redux devtools)</li>
  <li>When we want an organised way of handling session storage or localstorage. Check <a href="https://github.com/btroncone/ngrx-store-localstorage">this plugin</a></li>
</ul>

<p>When we are writing Angular applications it’s a best-practice to work with immutable data structures. That way we can make use of the <a href="https://angular-2-training-book.rangle.io/handout/change-detection/change_detection_strategy_onpush.html">OnPush changedetectionstrategy</a> that angular provides us, which results in better performance and less unexpected behavior. In React we could use a <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">Pure component</a> for that. So, for this article let’s assume that immutable datastructures are the way to go and that our application needs it.</p>

<p>While we know that Redux forces you to use immutable datastructures, let’s still challenge the need of Redux shall we?
If statemanagement is trivial to our applications and we just want to store values we could work with a state service instead of Redux.</p>

<pre><code class="language-typescript">@Injectable()
export class UsersService {
    private _users$ = new BehaviorSubject([]);

    get users$(): Observable&lt;User[]&gt; {
        return this._users$.asObservable();
    }

    // IMPORTANT: since we use an immutable dataflow
    // we have to make sure users is a new instance
    setUsers(users: User[]): void {
        this._users$.next(...users);
    }
}

</code></pre>

<p>This example shows how we can set the simple value of an array of users by calling the <code>setUsers()</code>function. It will store the value into a BehaviorSubject which we will consume as an observable. The spread operator (<code>...</code>) will create a new instance of the <code>users</code> array. That way we know that we are working in an immutable manner. This was pretty easy and we don’t need Redux anymore, nor all the boilerplate that we would had to write. So if the state of our application only contains a few simple properties, the Redux pattern might be overkill.</p>

<p>But what if we need to do more then just set the value of <code>users</code>. What if we want to add and remove users from that stream, and we would have to do it in an immutable manner? Checkout the following example for instance.</p>

<pre><code class="language-typescript">@Injectable()
export class UsersService {
    private _users$ = new BehaviorSubject([]);

    get users$(): Observable&lt;User[]&gt; {
        return this._users$.asObservable();
    }

    setUsers(users: User[]): void {
        this._users$.next(...users);
    }

    addUser(user: User): void {
        // We cannot use array.push because we only want to
        // pass immutable data to the streame
        // for the OnPush strategy remmber?
        this._users$.next([...this._users$.getValue(), user])
    }

    removeUser(id: string) {
        // Again, we have to create a new Array instance to not break the
        // immutable dataflow
        this._users$.next(this._users$.getValue().filter(v =&gt; v.id !== id));
    }
}

</code></pre>
<p>The code above is starting to feel a bit weird, and it seems like we are writing reducer logic inside of this state service to keep it immutable. We have also created our own observable implementation so we could subscribe to the changes of our state service. While it could still be overkill to use redux if this is the only state in our application, it might become complex if we are working with multiple states, nested states, etc.</p>

<p>Another example is caching. People use redux to cache data results. A simple <code>shareReplay</code> operator might to the trick as well.</p>

<pre><code class="language-typescript">fetchUsers(): Observable&lt;User[]&gt; {
    ...
    return this.httpClient.get('').pipe(shareReplay(1));
}
</code></pre>

<h2 id="summary">Summary</h2>

<p>I would suggest to not use Redux untill we actually need it, and in my experience most applications that I have written in the past did need redux at a certain point. That being said I also wrote a bunch of applications that didn’t need it at all (CRUD applications for instance.</p>

<p>It’s up to you if you want to use Redux or not, <strong>but keep your applications immutable at all times</strong>.
It will save you a lot of energy in debugging and it makes sure that you can optimise the change detection cycle in your applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Pre-rendering Angular Applications</title>
	  <link>//prerendering-angular-apps/</link>
	  <author></author>
	  <pubDate>2018-03-04T00:00:00+00:00</pubDate>
	  <guid>//prerendering-angular-apps/</guid>
	  <description><![CDATA[
	     <h2 id="why-should-we-pre-render-angular-applications">Why should we pre-render Angular applications?</h2>

<p>At the moment of writing this article, there are several ways of optimizing Angular applications - We could compile them <a href="https://angular.io/guide/aot-compiler">ahead-of-time</a> through AOT compilation.
We could use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service workers</a> to optimize caching. And there are plenty of other PWA (progressive web app) features that can increase the quality and overall performance of our Angular applications.</p>

<p>However, there are a still a few problems that these optimizations won’t fix:</p>
<ul>
  <li><strong>SEO</strong> (search engine optimization): At the time of writing, SPAs (single-page applications) are harder to index by search engines because the content isn’t available on load time. Therefore, the application is likely to fail on several SEO requirements.</li>
  <li><strong>Initial page load</strong> could be faster: Since the application still needs to be bootstrapped after the page is loaded, there is an initial waiting time until the user can use the application. This results in a bad user experience.</li>
</ul>

<p>These two problems can be fixed by implementing <a href="https://angular.io/guide/universal">SSR (server-side rendering)</a>. SSR executes the Angular application on the server. That way the server will actually serve the compiled content in a way that search engine crawlers can read it. This is really the best of both worlds: The application will be rendered on the server, but when the JavaScript bundle is loaded, it will turn into a SPA. That way the application is rich and fast at the same time!</p>

<p>To optimize our <a href="https://strongbrew.io">StrongBrew</a> website, we started using this approach. It was pretty fast when we ran it locally. However, the StrongBrew website is hosted on <a href="https://firebase.google.com">Firebase</a> and the SSR part was hosted by Firebase functions.</p>

<p>We really love Firebase and everything it stands for, but for us, SSR on Firebase functions was just too slow. Sometimes it took 4 seconds to serve the content… Since the loading time of a website is very important for keeping our visitors, we had to find another way to serve the content in a more effective manner.</p>

<p>SSR works like this: A user navigates to a URL =&gt; the server compiles the application and serves it.
But instead of compiling every route when the server receives a request, what if we could execute the SSR logic for every route at build time? That would certainly fix our problem.</p>

<p>That way we would run generated static HTML files, which is insanely fast, and when the JavaScript bundles are loaded, the browser would take over.
This also uses the best of both worlds: Ultra fast loading time + we don’t need to give up our rich SPA experience.
The result went from several seconds to 30 milliseconds.
<img src="/assets/images/posts/prerendering-angular-apps/ssr-vs-prerender.png" alt="SSR vs Prerender" /></p>

<p>This is a super fast and super effective improvement but it has one very important limitation.
<strong>It’s not possible to prerender dynamic content</strong>. The data in the StrongBrew website isn’t fetched by AJAX calls (at least not the data that has to be indexed). It rather works with simple webpack imports of JSON files. These are inserted at build time.</p>

<p>This does not mean that loading content dynamically isn’t possible at all, it just won’t get prerendered.</p>

<h2 id="lets-dive-in">Let’s dive in</h2>

<p>Enough chit chat! Let’s dive into some code.
I’ve created this <a href="https://github.com/strongbrewio/prerender-angular-example">GitHub repository</a> just for you! It’s a simple website with a few pages and the build system doesn’t know how to pre-render yet.
Checkout the branch <code>runtime</code> by running the command <code>git checkout runtime</code>. When running <code>npm i &amp;&amp; npm run start</code>, the bash should install all the NPM dependencies and host the application on <code>http://localhost:4200</code>, just like any default Angular CLI application.</p>

<h3 id="installing-the-dependencies">Installing the dependencies</h3>

<p>Great! We have a running website, but nothing is pre-rendered yet.
The first thing we need to do is to install @angular/platform-server by running
<code>npm i @angular/platform-server -D</code>. This is the most important bundle for SSR. This module contains the basics to run the Angular application on the server.</p>

<h3 id="applying-the-server-transition">Applying the server transition</h3>

<p>Next, we need to update the <code>app.module.ts</code> to enable server transition. This will make sure that Angular takes over on the frontend when the JavaScript bundles are loaded.</p>

<pre><code class="language-typescript">// src/app/app.module.ts
@NgModule({
  ...
  imports: [
    BrowserModule.withServerTransition(
        // this is just the name of our application
        // configured in angular-cli.json
        { appId: 'prerender-angular-example' }
    ),
    ...
  ],
  ...
})
export class AppModule { }
</code></pre>

<h3 id="creating-the-prerender-module">Creating the prerender module</h3>

<p>Then, we need to create a specific prerender module that will use the AppModule we have just adjusted. Let’s create an <code>app.prerender.module.ts</code> where we can tell which component it has to bootstrap.</p>

<pre><code class="language-typescript">// src/app/app.prerender.module.ts
import { NgModule } from '@angular/core';
import { ServerModule, ServerTransferStateModule } from '@angular/platform-server';

import { AppModule } from './app.module';
import { AppComponent } from './app.component';

@NgModule({
  imports: [
    AppModule,
    ServerModule,
    ServerTransferStateModule
  ],
  bootstrap: [AppComponent]
})
export class AppPrerenderModule {
}
</code></pre>

<h3 id="defining-a-prerender-entrypoint">Defining a prerender entrypoint</h3>

<p>To use the SSR logic at build time, we need to have a specific bundle. Since the <code>main.ts</code> file is used to bootstrap the application for the browser, we also need a <code>main.prerender.ts</code> file that will be used to create the prerender bundle.
Let’s create that file, shall we?</p>

<pre><code class="language-typescript">// src/app/main.prerender.ts
import { enableProdMode } from '@angular/core';
export { AppPrerenderModule } from './app/app.prerender.module';

enableProdMode();
</code></pre>
<h3 id="a-prerender-tsconfigjson">A prerender tsconfig.json</h3>

<p>We are almost there, I promise, but we need a few more things. We need a specific <strong>tsconfig</strong> file that compiles the bundle to something that the node server can read. It’s important for the compiler to compile to a <strong>commonjs</strong> package. This is because node.js uses this by default. So we need to create a <code>tsconfig.prerender.json</code> file:</p>

<pre><code class="language-json">/* src/tsconfig.prerender.json */
{
  "extends": "./tsconfig.app.json",
  "compilerOptions": {
    "outDir": "../out-tsc/prerender",
    /* node only understands commonjs for now*/
    "module": "commonjs"
  },
  "exclude": [
    "test.ts",
    "**/*.spec.ts"
  ],
  /* Additional informations to bootstrap Angular */
  "angularCompilerOptions": {
    "entryModule": "app/app.prerender.module#AppPrerenderModule"
  }
}

</code></pre>

<h3 id="letting-angular-cli-know-and-generating-the-bundle">Letting Angular CLI know and generating the bundle</h3>

<p>In the apps entry of the <code>angular-cli.json</code> file, we need to add a new app where we refer to the <code>main.prerender.ts</code> file and the <code>tsconfig.prerender.json</code> file. The app section should look like this:</p>

<pre><code class="language-json">{
      "name": "prerender",
      "platform": "server",
      "root": "src",
      "outDir": "dist-prerender",
      "main": "main.prerender.ts",
      "tsconfig": "tsconfig.prerender.json",
      "environmentSource": "environments/environment.ts",
      "environments": {
        "dev": "environments/environment.ts",
        "prod": "environments/environment.prod.ts"
      }
    }
</code></pre>

<p>Update the package JSON so it builds both the normal package and the server package. Set the <strong>output-hashing</strong> to none so that the build generates a clean <code>main.bundle.js</code> without any hash.</p>
<pre><code>    "build": "ng build --prod &amp;&amp; ng build --prod --app prerender --output-hashing=none",
</code></pre>
<p>When running <code>npm run build</code> the following files should be created:</p>
<ul>
  <li>dist (this contains the normal build)</li>
  <li><code>dist-prerender/main.bundle.js</code></li>
</ul>

<p>This <code>main.bundle.js</code> file exports a module called <code>AppPrerenderModuleNgFactory</code>. This is the module that we can use to pre-render the whole thing.</p>

<h2 id="generating-the-static-files">Generating the static files</h2>

<p>We have just generated the <code>main.bundle.js</code>, the file that we need to perform server-side rendering. However we don’t want to do server-side rendering in this case, we want to <strong>pre-render</strong> the html at build time. To do that we need a script that will complete the following steps.</p>

<ul>
  <li>Create an array with routes (we could automate this if we want)</li>
  <li>Loop over that array and for every entry:
    <ul>
      <li>create a folder in the dist map with that route name</li>
      <li>use the <code>main.bundle.js</code> to render the html and store that html as an <code>index.html</code> in the folder we just created.</li>
      <li>Overwrite the <code>dist/index.html</code> file.</li>
    </ul>
  </li>
</ul>

<p>Let’s call that script <code>prerender.ts</code>. Since I’m a typescript enthusiast, I want to develop the prerender script in typescript and use <a href="https://www.npmjs.com/package/ts-node">ts-node</a> to run it.
We can start with creating an empty <code>prerender.ts</code> file in the root folder and installing ts-node with <code>npm i -D ts-node</code></p>

<p>Now we can update the scripts section of the package.json so that the render function is called when the build is completed:</p>

<pre><code class="language-json"> "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build --prod &amp;&amp; ng build --prod --app prerender --output-hashing=none",
    "postbuild": "npm run render",
    "render": "ts-node prerender.ts",
    ...
  },
</code></pre>

<p>The only puzzle piece that is still missing is implementing the <code>prerender.ts</code> file.</p>

<h3 id="completing-the-prerenderts-file">Completing the prerender.ts file</h3>

<p>The following code should be self-explanatory:</p>

<pre><code class="language-typescript">import 'zone.js/dist/zone-node';
import * as path from 'path';
import * as fs from 'fs';
import { enableProdMode } from '@angular/core';
import { renderModuleFactory } from '@angular/platform-server';
import { AppPrerenderModuleNgFactory } from './dist-prerender/main.bundle';

const distFolder = './dist';
const index = fs
    .readFileSync(path.resolve(__dirname, `${distFolder}/index.html`), 'utf8')
    .toString();

// we could automate this based on the app.routes.ts file but
// to keep it simple let's just create an array with the routes we want
// to prerender
const paths = [
    '/about',
    '/brews',
    '/consultancy'];
enableProdMode();

// for every route render the html and save it in the correct folder
paths.forEach(p =&gt; renderToHtml(p, distFolder + p));

// don't forget to overwrite the index.html as well
renderToHtml('/index.html', distFolder);

function renderToHtml(url: string, folderPath: string): void {
  // Render the module with the correct url just 
  // as the server would do
  renderModuleFactory(AppPrerenderModuleNgFactory, {
    url,
    document: index
  }).then(html =&gt; {
    // create the route directory
    if (url !== '/index.html') {
    fs.mkdirSync(folderPath);
    }
    fs.writeFile(folderPath + '/index.html', html,  (err =&gt;  {
      if (err) {
        throw err;
      }
      console.log(`success`);
    });
  });
}

</code></pre>
<h3 id="testing-the-pre-rendered-application">Testing the pre-rendered application</h3>

<p>To test the website, we can build the project with <code>npm run build</code>. To serve it, we can use http-server. We can install http-server by running <code>npm i -g http-server</code>. By navigating into the <code>dist</code> directory and running <code>http-server</code>, the application will be hosted on port 8080.</p>

<p>If we navigate to http://localhost:8080 in the browser, we will see the pre-rendered application. We can test the SPA experience by navigating between the different pages and we can test the pre-rendered part by looking at the source code.</p>

<p><img src="/assets/images/posts/prerendering-angular-apps/sourcecode.png" alt="SSR sourcecode" /></p>

<h2 id="closing-words">Closing words</h2>

<p>I hope you liked this article and learned something.
We can find the full pre-rendered version by checking out branch <code>prerendered</code> by running <code>git checkout prerendered</code>. To test this example, checkout the previous section.</p>

<p>Note: to optimize the HTML even more, we could use an HTML minifier like <a href="https://www.npmjs.com/package/html-minifier">this one</a> to shrink the HTML where possible. The example could look something like this:</p>

<pre><code class="language-typescript">const minify = require('html-minifier').minify;
function renderToHtml(url: string, folderPath: string): void {
    // Render the module with the correct url just 
    // as the server would do
    renderModuleFactory(AppPrerenderModuleNgFactory, {
        url,
        document: index
    }).then(html =&gt; {
        ...
        // minify the html
        fs.writeFile(folderPath + '/index.html', minify(html),  (err =&gt;  {
          ...
        });
    });
}
</code></pre>

<h2 id="special-thanks">Special thanks</h2>

<p>A very special thanks to the awesome people that have helped me with their reviews:</p>

<ul>
  <li>Laurant Duveau <a href="https://twitter.com/laurentduveau">@laurentduveau</a></li>
  <li>Dominic Elm <a href="https://twitter.com/elmd_">@elmd_</a></li>
  <li>Sam Vloeberghs <a href="https://twitter.com/samvloeberghs">@samvloeberghs</a></li>
  <li>Ana Cidre <a href="https://twitter.com/anacidre_">@AnaCidre_</a></li>
  <li>Ruben Vermeulen <a href="https://twitter.com/CrushTheButton">@CrushTheButton</a></li>
  <li>Klaas Cuvelier <a href="https://twitter.com/klaascuvelier">@klaascuvelier</a></li>
</ul>

<h2 id="sources">Sources</h2>

<p><a href="https://hackernoon.com/deploy-angular-universal-w-firebase-ad70ea2413a1">deploy angular universal with firebase</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>RxJS best practices in Angular</title>
	  <link>//rxjs-best-practices-in-angular/</link>
	  <author></author>
	  <pubDate>2018-01-04T00:00:00+00:00</pubDate>
	  <guid>//rxjs-best-practices-in-angular/</guid>
	  <description><![CDATA[
	     <p>This article is all about the do’s and don’ts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#pipeable-operators">Pipeable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don’t pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don’t pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code>$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code>$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="pipeable-operators">Pipeable operators</h2>

<p>The first best practice is the use of pipeable operators. The operators being used in this article are pipeable.
Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about pipeable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<pre><code class="language-typescript">// BAD: This is the old way and should be avoided (patch operators)
// as we can see the operators (filter, map) are part of the
// Observable prototype
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
const new$ = Observable.interval$
    .filter(v =&gt; v % 2 === 0)
    .map(v =&gt; v * 2);

// GOOD: This is the new and improved way (lettable operators)
// we just use the pipe operator where we pass operators that
// we can import from 'rxjs/operators'
import {filter, map} from 'rxjs/operators';
const new$ = interval$
    .pipe(
        filter(v =&gt; v % 2 === 0),
        map(v =&gt; v *2)
    )
</code></pre>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: “Great code should be self-explanatory, writing documentation is something that we might want to avoid.”
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it’s hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it’s supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<pre><code class="language-typescript">// ---a--b--c--d---e---...
// ---a--b--c--d---e|
// ---a--b--c--d---e#
// ---a--b-^-c--d---e
</code></pre>
<ul>
  <li><code>-</code> (stands for a time frame)</li>
  <li><code>a-z</code> (are the values that are next’ed in the stream)</li>
  <li><code>|</code> (indicates that the stream has completed)</li>
  <li><code>...</code> (indicates that the stream will keep on living)</li>
  <li><code>#</code> (indicates that an error occurred)</li>
  <li><code>^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it’s time to check a real example and how we might document it:</p>

<pre><code class="language-typescript">const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
const new$ = interval$
    .pipe(
        skip(1),                            // ---1--2--3--4--5--6...
        take(5),                            // ---1--2--3--4--5|
        filter(v =&gt; v % 2 === 0),           // ------2-----4---|
        map(v =&gt; v + 1)                     // ------3-----5---|
    )
</code></pre>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it’s fairly easy to comprehend what happens, and how every operator affects the <code>new$</code> stream we can see above. There is no “one way of doing things” when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn’t mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn’t have any side effects. It can’t mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren’t fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit {
   ngOnInit() {
        // The following stream will produce values every second
        // 0--1--2--3--4--5--6--...
        const interval$ = interval(1000);
        // Even when this component gets destroyed,
        // the stream will keep producing values...
        // This means the console will keep on logging
        // This is a classic example of a memory-leak
        const subscription = interval$.subscribe(r =&gt; console.log(r));
    }
}
</code></pre>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    subscriptions = [];
    ngOnInit() {
        const interval$ = interval(1000);
        const subscription = interval$.subscribe(r =&gt; console.log(r));
        // manually keep track of the subscriptions in a subscription array
        this.subscriptions.push(subscription);
    }

    ngOnDestroy() {
        // when the component get's destroyed, unsubscribe all the subscriptions
        this.subscriptions.forEach(sub =&gt; sub.unsubscribe());
    }
}
</code></pre>

<p>However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    destroy$ = new Subject();
    ngOnInit() {
        // interval$: 0--1--2--3--4--5--6--...
        // destroy$:  -------------true|
        // result:    0--1--2--3--4|
        const interval$ = interval(1000);
        interval$
            // let the interval$ stream live 
            // until the destroy$ Subject gets a value
            .pipe(takeUntil(this.destroy$))
            .subscribe(r =&gt; console.log(r));
    }

    ngOnDestroy() {
        // when the component get's destroyed, pass something to the
        // destroy$ Subject
        this.destroy$.next(true);
    }
}
</code></pre>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService)
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // VERY BAD: nesting subscribes is ugly and takes away
        // the control over a stream
        this.route.params
            .pipe(map(v =&gt; v.id))
            .subscribe(id =&gt; 
                this.userService.fetchById(id)
                    .subscribe(user =&gt; this.user = user))
    }
}
</code></pre>

<p>The previous implementation is considered a bad-practice. It’s recommended to use <strong>higher-order streams</strong> like <code>mergeMap</code> or <code>switchMap</code>. Let’s have a look at this example:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) 
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // GOOD: we have created a single subscribe which makes
        // the flow way easier and gives us the control we need
        this.route.params
            .pipe(
                map(v =&gt; v.id),
                switchMap(id =&gt; this.userService.fetchById(id))
            )
            .subscribe(user =&gt; this.user = user)
    }
}
</code></pre>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that’s simply how observables work. But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code>async pipe</code>. It’s used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don’t have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let’s have a look at the cleaned up previous example:</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // expose a user$ stream that will be 
    // subscribed in the template with the async pipe
    user$ = this.route.params.pipe(
        map(v =&gt; v.id),
        switchMap(id =&gt; this.userService.fetchById(id))
    );

    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) {
    }
}
</code></pre>

<p>If you are into <a href="https://reactjs.org/">React</a>, I’ve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don’t pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That’s the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // this http call will get called when the 
    // user-detail component subscribes to users$
    // We don't want that
    users$ = this.http.get(...);
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent implements OnInit {
    @Input() user$: Observable&lt;User&gt;;
    user: User;
    ngOnInit(){
        // WHOOPS! This child component subscribes to the stream
        // of the parent component which will do an automatic XHR call
        // because Angular HTTP returns a cold stream
        this.user$.subscribe(u =&gt; this.user = u);
    }
}
</code></pre>

<p>It would be better to handle the subscription in the parent component itself:</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent implements OnInit {
    users$: Observable&lt;User[]&gt; = this.http.get(...);
    user: User;
    ngOnInit(){
        // the app component (smart) subscribes to the user$ which will
        // do an XHR call here
        this.users$ = this.http.get(...);
    }
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent {
    // This component doesn't even know that we are using RxJS which
    // results in better decoupling
    @Input() user: User;
}
</code></pre>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don’t pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don’t know what’s going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don’t care that your components are using streams. Take this example for instance:</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
class AppComponent {
     users$ = this.http.get(...)
     filteredusers$ = this.fooService
        .filterUsers(this.users$); // Passing stream directly: BAD
    ...
}

// foo.service.ts
class FooService {
    // return a stream based on a stream
    // BAD! because we don't know what will happen here
    filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; {
        return users$.pipe(
            map(users =&gt; users.filter(user =&gt; user.age &gt;= 18))
    }
}
</code></pre>

<p>It would be better to use higher order streams for these situations.
Use <code>switchMap</code> over <code>mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
class AppComponent {
    users$ = this.http.get(...)
    filteredusers$ = this.users$
        .pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));
    ...
}

// foo.service.ts
class FooService {
    // this is way cleaner: this service doesn't even know
    // about streams now
    filterUsers(users: User[]): User[] {
        return users.filter(user =&gt; user.age &gt;= 18);
    }
}
</code></pre>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code>http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code>numberOfUsers$</code> depends on <code>users$</code>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// BAD
class AppComponent {
    users$ = this.http.get(...)
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>In those cases we might want to share the subscriptions. The following example uses the <code>share()</code> operator:</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// GOOD
class AppComponent {
    users$ = this.http.get(...).pipe(share());
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code>shareReplay(1)</code> instead of <code>share()</code>. This will keep the last value in memory for us.</p>

<p>It’s a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code>async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `
})
class AppComponent {
    // This stream will only subscribed to once
    users$ = this.http.get(...);
}
</code></pre>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn’t make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it’s ok to use Subjects in the following scenarios:</p>
<h4 id="when-mocking-streams-in-tests">When mocking streams in tests</h4>

<pre><code class="language-typescript">const fetchAll$ = new Subject(); // use a Subject as a mock
usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
fetchAll$.next(fakeUser);
</code></pre>

<h4 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h4>

<pre><code class="language-typescript">@Component({
    ...
    template: `
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `
})
class AppComponent {
search$ = new Subject(); // ----t-----te-----ter----term...
}
</code></pre>

<h4 id="when-handling-circular-references">When handling circular references</h4>

<p>I’m not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code>getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<pre><code class="language-typescript">    foo$.pipe(
        map(...)
        filter(...)
        tap(...)
    )
</code></pre>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that’s personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it’s recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code>ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code>Form</code> and <code>FormControl</code> both have a <code>valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code>ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the “Advanced RxJS in Angular workshop” from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Safe image requests in angular</title>
	  <link>//safe-image-requests-in-angular/</link>
	  <author></author>
	  <pubDate>2017-10-24T00:00:00+00:00</pubDate>
	  <guid>//safe-image-requests-in-angular/</guid>
	  <description><![CDATA[
	     <p>We all know how to load images in a web-application right? We would just make use of the img DOM-element, define its src attribute and we are good to go. Everything would happen automatically. However, there is a big security-issue with this approach.</p>

<p>Take this hypothetical application for instance: We have an app that is used to manage pictures and this particular app can have multiple users. It makes sense that every user owns their own images, right? For privacy reasons user A could never consume the images of user B. Since images are loaded through the DOM with the img DOM-element, it might be hard to add authorization there. Take this angular snippet for instance:</p>

<pre><code class="language-typescript">@Component({
    template: `
        &lt;img [src]="img.src"/&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
}
</code></pre>

<p>Since the browser just loads this image through a normal HTTP call, how is the server supposed to know if user A or user B is trying to consume this image? The server needs some kind of authorization to be passed to it.</p>

<h2 id="passing-the-authorization-with-session-cookies">Passing the authorization with Session cookies</h2>

<p>We could use session cookies, which kinda works like this: The user authenticates with the backend of our app, receives a session cookie which will be passed with every future request. That way the backend knows who is trying to consume the resource in question.</p>

<p>Some could argue that session cookies are not to way the go, and stateless backends are better and more scalable.
If we use JWT or any other modern authentication system we would rather send <strong>authorization-headers</strong> instead of using the session cookie approach. The value that our server should receive in the authorization-header is called a <strong>Bearer token</strong>.</p>

<h2 id="passing-the-authorization-without-cookies">Passing the authorization without cookies</h2>

<p>Let’s explore 2 different methods to pass Bearer tokens to the backend:</p>

<h3 id="passing-the-token-in-the-url">Passing the token in the url</h3>

<p>In this case we would just pass the token as a <strong>query parameter</strong> in the url. The previous snippet would now look like this:</p>

<pre><code class="language-typescript">@Component({
    template: `
        &lt;img [src]="img.src + '?bearer=' + bearToken"/&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
    bearerToken  = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
}
</code></pre>

<p>The url of the server request would now look like this: <em>https://angular.io/assets/images/logos/angular/logo-nav@2x.png?bearer=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9…</em></p>

<p>Based on the token, the server knows which user tries to load the image and can block unauthorized users of fetching that image.</p>

<p>There are a few tradeoffs:</p>

<ul>
  <li>The Token is there for everyone to see in the URL (less secure, but then again, they could still check it in the offline-storage)</li>
  <li>Every time the token changes, the cache would be cleared, since the url of the resource changes</li>
  <li>The backend would need a way to handle all the image calls that contain a bearer token in their url</li>
  <li>We need to load and parse the token everywhere we load images in our components</li>
  <li>Doesn’t work for css, unless it’s dynamically created</li>
</ul>

<h3 id="handling-the-images-with-ajax-calls">Handling the images with AJAX calls</h3>

<p>In this approach we will create a generic way of handling image-security by using:</p>

<ul>
  <li>A generic component</li>
  <li>AJAX calls with a blob responseType</li>
  <li>HTTP interceptors (introduced by the new HttpClient in angular 4.3)</li>
  <li>Data urls</li>
</ul>

<p>We would like to consume images like this:</p>

<pre><code class="language-typescript">@Component({
    template: `
          &lt;secured-image [src]="img.src"&gt;&lt;/secured-image&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
}
</code></pre>

<p>Let’s create a <strong>secured-image</strong> component as shown above.
This component needs to handle the following:</p>

<ul>
  <li>Load an image through an AJAX call</li>
  <li>Create a data url based on a blob</li>
  <li>When the source changes:
    <ul>
      <li>Cancel the previous AJAX call (if it’s still busy)</li>
      <li>Start loading the new resource through AJAX</li>
    </ul>
  </li>
  <li>When the component gets destroyed, cancel the current AJAX call (if it’s still busy)</li>
</ul>

<p>In the beginning, this might look like this:</p>

<pre><code class="language-typescript">@Component({
  selector: 'secured-image',
  template: `
    &lt;img [src]="dataUrl$|async"/&gt;
  `
})
export class SecuredImageComponent implements OnChanges  {
  // This code block just creates an rxjs stream from the src
  // this makes sure that we can handle source changes
  // or even when the component gets destroyed
  // So basically turn src into src$
  @Input() private src: string;
  private src$ = new BehaviorSubject(this.src);
  ngOnChanges(): void {
    this.src$.next(this.src);
  }

  // this stream will contain the actual url that our img tag will load
  // everytime the src changes, the previous call would be canceled and the
  // new resource would be loaded
  dataUrl$ = this.src$.switchMap(url =&gt; this.loadImage(url))
  
  // we need HttpClient to load the image
  constructor(private httpClient: HttpClient) {
  }

  private loadImage(url: string): Observable&lt;any&gt; {
    return this.httpClient
      // load the image as a blob
      .get(url, {responseType: 'blob'})
      // create an object url of that blob that we can use in the src attribute
      .map(e =&gt; URL.createObjectURL(e))
  }
}

</code></pre>

<p>This pretty much covers everything, but if we check it in the browser we get the following error.
<strong>WARNING: sanitizing unsafe URL value blob:https://localhost:4200/da89c71e-5df2-4842-af06-993cd5263471 (see http://g.co/ng/security#xss)</strong></p>

<p>Loading the image through AJAX does not work yet because we haven’t sanitized the url yet. For that we need the <strong>DomSanitizer</strong> that angular provides us. This is a security mechanism to protect the app from XSS-attacks. We basically have to tell angular which urls to trust.</p>

<pre><code class="language-typescript">export class SecuredImageComponent implements OnChanges  {
  ...
  // inject the domSanitizer here as well
  constructor(private httpClient: HttpClient, private domSanitizer: DomSanitizer) {
  }

  private loadImage(url: string): Observable&lt;any&gt; {
    return this.httpClient
      .get(...)
      // pass the url through the domSanitizer so angular knows he can parse it
      .map(e =&gt; this.domSanitizer.bypassSecurityTrustUrl(URL.createObjectURL(e)))
  }
}

</code></pre>

<p>We now have a fully working way of loading images through AJAX calls. However, we still haven’t passed our Bearer token.
We could add the the authorization header in the get call directly, but let’s find a cleaner solution.
Since we use httpClient, this opens up a few doors for us.
The new HttpClient, which was introduced in angular 4.3 offers a few new features. One of these features are <strong>interceptors</strong>.
Interceptors are a way to hook into http calls that are being made by the new HttpClient.</p>

<p>This would be a perfect solution to pass the bearer token wouldn’t you agree?</p>

<p>Let’s create the interceptor and register it to angular.</p>

<pre><code class="language-typescript">// my-http.interceptor.ts
@Injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  // intercept any http call done by the httpClient
  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    // fetch the bearer token from wherever you have stored it
    // NOTE: fetching it directly from window is not a good idea (demo purpose)
    const jwtToken = window.localStorage.getItem('jwtToken');

    // if there is a token, clone the request and set the correct
    // authorization header, if not =&gt; just use the old request
    const requestToHandle = jwtToken
      ? request.clone({
        headers: request.headers.set('authorization', `Bearer ${jwtToken}`)
      })
      : request;
    return next.handle(requestToHandle);
  }
}

// app.module.ts
@NgModule({
  ...
  // don't forget to import the HttpClientModule
  imports: [ BrowserModule, FormsModule, HttpClientModule ],
  providers: [{
    // register the interceptor to our angular module
    provide: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true
  }]
})
export class AppModule { }
</code></pre>

<p>If you would like to learn more about interceptors, check this <a href="https://juristr.com/blog/2017/08/intercept-http-requests-in-angular/">awesome article</a> by <a href="https://twitter.com/juristr">Juri Strumpflohner</a>.
He also has an amazing egghead course on that subject.</p>

<p>Right now, every call that the secured-image component has initiated will load the image through AJAX with the right authorization header. That way the server can check who has been asking for that specific resource.</p>

<p>However, this approach also introduces a few tradeoffs:</p>

<ul>
  <li>CORS headers for CDN resources. Since we are using a GET AJAX call there will be extra OPTIONS calls.</li>
</ul>

<p>Extra advantages:</p>
<ul>
  <li>It’s easier to handle the loading of the image, show a spinner or animation</li>
  <li>Doesn’t work for css, unless it’s dynamically created</li>
</ul>

<p>You can find the complete source of a working version in this <a href="https://stackblitz.com/edit/secure-image-loads">stackblitz example</a>.</p>

<h2 id="thanks-for-reading">Thanks for reading</h2>
<p>I hope you all liked this article, if you have questions, shoot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>A scalable angular architecture (part 2)</title>
	  <link>//A-scalable-angular-architecture-part2/</link>
	  <author></author>
	  <pubDate>2017-08-13T00:00:00+00:00</pubDate>
	  <guid>//A-scalable-angular-architecture-part2/</guid>
	  <description><![CDATA[
	     <h1 id="the-sandbox-pattern">The sandbox pattern</h1>

<h2 id="introduction">Introduction</h2>
<p>A while ago I released a blogpost called “<a href="http://blog.brecht.io/A-scalable-angular2-architecture/">A scalable angular 2 architecture</a>” which was all about creating large scale enterprise webapplications. The title should actually have been <strong>“A scalable angular architecture”</strong> (It’s just angular) or even, <strong>“A scalable SPA architecture”</strong> since we can use the same architecture for <a href="https://facebook.github.io/react/">React</a> or <a href="https://vuejs.org">Vue.js</a>.</p>

<p>It’s been over a year now, since I’ve been introducing that specific architecture in companies and projects. Nowadays, I know quite a few people that are using this particular architecture in their projects.
Often, I ask developers about how they feel about this SPA-architecture and the feedback is mostly this:
They believe its a <strong>clear and opiniated way</strong> to structure their code, and they have no trouble, finding their way into the codebase.</p>

<p>A big part of the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">article</a> in question, was about explaining the so called “sandboxes”, a personal terminology for a very specific kind of facade.
Since writing that <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">article</a> raised a bunch of questions about these “sandboxes”, it seemed like a good idea to write a followup article.</p>

<p>In this article we will cover what sandboxes are really about and why I introduced them in the first place.</p>

<p><strong>Note: This architecture is only one way of structuring your applications and the statements being made in this article are completely personal and might be opiniated.</strong></p>

<h2 id="what-is-a-sandbox-in-a-nutshell">What is a sandbox in a nutshell</h2>

<p>In real life it’s a place where we can put our children together with a limited set of toys. That way, they can only play with those toys and have fun, and we as parents wouldn’t have to worry about them running around in the garden.</p>

<p>In this architecture a sandbox is a controlled environment, and the only place where components can consume pieces of the application.
It’s the only interface for our smart components to communicate with the rest of the application. It’s a facade that abstracts away logic from our components. It does have very specific logic though.</p>

<h2 id="here-is-why-i-introduced-sandboxes">Here is why I introduced sandboxes</h2>

<p>One of the most challenging parts of creating big clientside javascript applications is encapsulation and dividing responsibilities. Having a decent encapsulated structure where every component, service, class has a clear reason of existence, makes it easy for us as developers to maintain the code and develop new features.</p>

<p>When writing single-page-applications one could face the following challenges:</p>

<h3 id="challenge-1-how-do-we-structure-components">Challenge 1: How do we structure components?</h3>

<p>Since this topic is covered in the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">previous article</a>, we won’t do a deepdive in this subject.
We use the smart/dumb component approach to structure our components. The dumb components mostly have presentational purposes and the smart components interact with the rest of the application.</p>

<h3 id="challenge-2-how-do-we-handle-statemanagement">Challenge 2: How do we handle statemanagement?</h3>

<p>Another topic covered by the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">previous article</a> is how handle our statemanagement. In short: we use @ngrx/store, or another redux implementation that embraces reactive programming.</p>

<h3 id="challenge-3">Challenge 3</h3>

<p>The first two challenges are met: we have a clear and structured presentational layer and because of the fact that we use @ngrx/store (or any statemanagement tool for that matter), we have a clear way of managing state. We can optimise performance with immutable data and still have clear unidirectional dataflow.</p>

<p>However, there are still a few pieces of the puzzle missing, which might raise the following questions:</p>

<h4 id="how-do-we-separate-the-presentation-layers-from-the-rest-of-the-application">How do we separate the presentation-layers from the rest of the application?</h4>

<p>If we inject whatever we want in our smart components, their constructors might get huge in no-time. Do those smart components really need to know everything about the application? Do they need to know where everything lives and what service it should call from which module in the application? Wouldn’t it be easier if they had an interface they could talk to, that just handles things for them?
It would certainly help to decouple angular modules from each other, and keep the responsibility of those smart components clear and compact. <strong>This is something a sandbox might be able to help us with.</strong></p>

<h3 id="do-our-components-need-to-know-about-redux">Do our components need to know about redux?</h3>

<p>Redux is an awesome library/principle that helps us ace statemanagement, but it’s a really heavy dependency if you don’t manage it carefully. What if your <strong>very specific</strong> redux actions would be everywhere in your components and services? In that case your codebase would be completely affected by it and it would be very hard to use another statemanagement tool in the future. It would be impossible to share that code in non-redux applications.
It would be a huge depencency… What if you like to switch to firebase for instance, or MOBX, or even write your own statemanagement tool. You would need to refactor your whole application. The sole principle of redux is to manage state, and I prefer to use it that way. That is also why I don’t really use effects, thunk or saga. (That’s a personal preference)
For me this means: <strong>Use redux only to manage state, not to trigger backend actions etc</strong>
One could even argue that the action-dispatching and state-selecting should be combined in central places in your appliction.
 <strong>Let’s add that logic to the sandboxes as well.</strong></p>

<h4 id="do-our-http-services-need-to-know-about-a-redux-implementation">Do our HTTP services need to know about a redux implementation?</h4>

<p>Well, as the name already reveals. An HTTP service is all about doing HTTP communication and returning asynchronous objects to the components. An HTTP service should have no notion about redux at all nor any other statemanagement tool. Its sole purpose is fetching data and returning it. Let’s take a look at the following example for instance. We fetch an array of wines from the backend and we want to persist that in a redux store. This is an example of an HTTP service that is being abused to achieve that:</p>

<pre><code class="language-typescript">class WineService {
	// bad
	fetchWines(): void {
		this.api.get('url')
			.subscribe(wines =&gt; 
				this.store.dispatch({type: 'SET_WINES', payload: {wines}});
	}
}
</code></pre>

<p>This code doesn’t belong here, it’s not the responsibility of that service. The question is where does it belong?
Does it belong in the component? They would get dirty and reduxy in no-time…
<em>*Again, this would belong to the sandbox!</em>.</p>

<p>An http service should look like this:</p>

<pre><code class="language-typescript">class WineService {
	// good
	fetchWines(): Observable&lt;any&gt; {
		return this.api.get('url')
	}
}
</code></pre>

<h4 id="on-what-place-do-we-dispatch-actions-to-the-store">On what place do we dispatch actions to the store?</h4>

<p>Err…, the sandbox =)</p>

<h4 id="where-do-we-handle-optimistic-updates">Where do we handle optimistic updates</h4>

<p>Again, that would be the sandbox</p>

<h4 id="how-to-not-make-your-whole-application-smell-like-redux">How to NOT make your whole application smell like REDUX</h4>

<p>Components and services should not know about redux, so the store interaction should be in a very specific place as well.</p>

<p>I bet you saw it coming, but YES! That’s what a sandbox is all about! It’s about separation of concerns and having a very specific interface to handle this very specific logic.</p>

<h2 id="what-does-a-sandbox-do">What does a sandbox do?</h2>

<p>A sandbox has a very specific responsibility:</p>

<ul>
  <li>It lets your module communicate with other modules without that module having to know about the rest of the application</li>
  <li>It sends Redux actions</li>
  <li>It exposes streams of data (coming from Redux, Firebase or other technologies)</li>
  <li>It handles optimistic updates</li>
  <li>It keeps the containers stupid enough</li>
</ul>

<h2 id="whats-very-specific-on-a-sandbox">What’s very specific on a sandbox?</h2>

<ul>
  <li>They handle what the container tells them to handle, without the container having to know how…</li>
  <li>They interact between modules</li>
  <li>They handle a lot of redux (or similar technology) logic</li>
  <li>The functions mostly have a void return-type, unless we want to be able to cancel HTTP calls</li>
  <li>They expose observables/streams</li>
  <li>It mostly contains redundant code, but no redundant logic (it’s all about KISS instead of DRY)</li>
  <li>Mostly every module has a sandbox, unless it contains a huge amount of logic (in that case we could implement a sandbox for every container)</li>
  <li>It does not contain business logic, ever…</li>
  <li>It mostly doesn’t contain if-statements, that would be business logic right?!</li>
  <li>It gives us a clear overview of the responsabilities of a module.</li>
</ul>

<h2 id="what-doesnt-a-sandbox-do">What doesn’t a sandbox do?</h2>

<ul>
  <li>It doesn’t contain business logic. It contains sandbox logic (see above).</li>
  <li>It doesn’t contain presentation logic, like routing etc.</li>
  <li>It doesn’t do HTTP calls directly, it delegates to http services.</li>
  <li>It doesn’t let your components do whatever they want =)</li>
</ul>

<h2 id="an-example">An example</h2>

<pre><code class="language-typescript">@Injectable()
export class StockSandbox {
	// these are the store select statements
	// It's pretty dirty to have them all over our components
	// Our components just want to get streams of data, no matter where they come from
	wines$ = this.store.select(state =&gt; state.wines);
	isAuthenticated$ = this.store.select(state =&gt; state.authentication.isAuthenticated);

	constructor(
		private store: Store&lt;ApplicationState&gt;, 
		private stockService: StockService,
		private fooService: FooService) {
	}

	addWine(wine: Wine): void {
		// use the stockservice to add a wine
		// and when it's done handle our statemanagement
		this.stockService.add(wine).subscribe((wine: Wine) =&gt; {
			this.store.dispatch(new AddWine(wine));
		}, () =&gt; this.handleError());
	}

	 removeWine(wine: Wine): void {
		// removing a wine can be done optimistically!
		// this would certainly improve the performance and snappyness of our app
		// this would be sandbox logic
		let action = new RemoveWine(wine._id);
		this.store.dispatch(action);
		this.stockService.remove(wine).subscribe(
			() =&gt; {}, 
			// if the call failed, we have to undo an action. This is sandbox logic as well!
			() =&gt; this.store.dispatch({type: UNDO_ACTION, payload: action}););
	}

	fetchWine(id: string): Observable&lt;Wine&gt; {
		// simple delegation of fetching something: Sandbox logic
		return this.stockService.fetchWine(id).share();
	}

	notifyAnotherModule(): void {
		// our components should NOT know where fooService is, or what it does
		// it should just tell its sandbox to handle a specific action
		this.fooService.doSomething();
	}
}
</code></pre>

<p>Look how clean this smart component has become:</p>
<pre><code class="language-typescript">export class StockPageContainer {
    wines$ = this.sb.wines$; // Does this stream comes from Redux? or Firebase (I don't need to know)
    numberOfWines$ = this.wines$.map(wines =&gt; sumBy(wines, (wine: Wine) =&gt; wine.inStock));

	// a clean constructor makes it easy to test.
	// Util dependencies or presentational dependencies like a router
	// do not belong in the sandbox.
	// They belong right here in the component, in the presentational layer.
    constructor(private sb: StockSandbox, private router: Router) {
    }

    onRemove(wine: Wine): void {
		// Hey Sandbox! Remove the wine please, I don't care how you do it
		// I don't even care that you do optimistic updates, it's not my business
        this.sb.removeWine(wine);
    }

    notifyAnotherModule(): void {
		// I don't know what will happen, but that's okay... It's not my responsability
        this.sb.notifyAnotherModule(); 
    }
}

</code></pre>

<p>I hope this clarifies the purpose of the sandbox and why I have introduced them in my projects.
If you still have questions about this approach, don’t hesitate to contact me =)</p>

<h3 id="special-thanks">Special thanks</h3>
<p>Special thanks to <a href="'https://twitter.com/ManfredSteyer'">Manfred Steyer (@manfredsteyer)</a> and <a href="https://twitter.com/juristr">Juri Strumpflohner (@juristr)</a> for reviewing this article!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Thinking reactively in Angular and RXJS</title>
	  <link>//thinking-reactively-in-angular-and-rxjs/</link>
	  <author></author>
	  <pubDate>2017-07-25T00:00:00+00:00</pubDate>
	  <guid>//thinking-reactively-in-angular-and-rxjs/</guid>
	  <description><![CDATA[
	     <h2 id="foreword">Foreword</h2>

<p>RxJS is an awesome library that can help us with creating <strong>reactive web applications</strong>. Reactive web applications can be overwhelming in the beginning, but eventually, they can be really rewarding.</p>

<p>This article is all about making the paradigm switch from thinking imperatively towards <strong>thinking reactively</strong>.
In this article, we will explain how to write a reactive calendar application in only a few lines of code (<strong>spoiler: It’s gonna be real time too</strong>).</p>

<p>We will use Angular, Angular Material, TypeScript, RxJS, Firebase, and AngularFire as our main technology stack. Keep in mind that this article really focusses on reactive programming. Don’t expect a deep dive into all RxJS operators, but rather expect an explanation of how to draw, think, and reason about reactive web applications. We will learn <strong>how to think in streams</strong>. If you haven’t heard of streams yet, please read <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this awesome article</a> first.</p>

<p><strong>Note:</strong> This article contains personal terminology.</p>

<h2 id="the-reactive-calendar">The Reactive Calendar</h2>
<p>This is the application we are going to write. It’s a small but complete calendar application that allows us to:</p>

<ul>
  <li>Switch between different view modes: day, week, month.</li>
  <li>Navigate to previous and next days, weeks, and months.</li>
  <li>Add, update, and remove appointments.</li>
  <li>Search for specific appointments.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar1.png" alt="Reactive calendar" /></p>

<p>The user can interact with the following UI elements:</p>

<ul>
  <li><strong>Next button:</strong> Allows the user to go to the next day in day mode, week in week mode, etc.</li>
  <li><strong>Previous button:</strong> Allows the user to go to the previous day in day mode, week in week mode, etc.</li>
  <li><strong>Day, week, month buttons:</strong> Allows the user to switch between the different view modes</li>
  <li><strong>Search term input:</strong> Allows the user to filter the appointments on the fly</li>
  <li><strong>Plus-buttons in the grid:</strong> Allows the user to create new appointments</li>
  <li><strong>Trashcan buttons in the grid:</strong> Allows the user to remove appointments</li>
  <li><strong>Description inputs:</strong> Allows the user to update the description of an appointment</li>
</ul>

<p>I decided to use Firebase as a backend and because of that, our application will be realtime and offline first by default!</p>

<p><strong>Note:</strong> One small issue, I’ve been a bit lazy so we can only create lunch appointments. =) But hey! Consider it some homework.</p>

<h2 id="setting-up-the-project">Setting Up the Project</h2>

<p>I’ve created the git branch <strong>initial</strong> to get us started. It contains the default logic/components, setup, and styles. There is no reactive code written yet, just plain Angular code. The goal is to write the reactive part ourselves.</p>

<h3 id="the-component-tree">The Component Tree</h3>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar3.png" alt="The component tree" />
The dumb components (blue) are already implemented. The <code>app-root</code> (orange) is the one and only smart component in the application and the only place where we will write code.</p>

<p>If you don’t know the difference between smart and dumb components, <a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">read this first</a>.</p>

<h3 id="installing-the-project-locally">Installing the Project Locally</h3>
<p>First of all, we have to clone the project locally and check out the <strong>initial</strong> branch. This branch already contains all the uninteresting parts that don’t have anything to do with this article.</p>

<p>In the terminal, we have to go to the folder where we want to install the project and run the following commands:</p>

<pre><code>$ git clone git@github.com:brechtbilliet/reactive-calendar.git
$ cd reactive-calendar/reactive-calendar
$ git checkout initial
$ npm install
</code></pre>

<h3 id="setting-up-firebase">Setting Up Firebase</h3>

<p>We are using <a href="https://firebase.google.com/">Firebase</a> as our backend because it requires minimal setup, it’s realtime by default, and <a href="https://github.com/angular/angularfire2">AngularFire</a> gives us streams for free. We can complete the Firebase configuration in a few steps:</p>

<ul>
  <li>Go to <a href="https://firebase.google.com/">https://firebase.google.com</a>, click on the “GO TO CONSOLE” button, and choose your Google account.</li>
  <li>Click on the “Add project” button and choose a name for your project. Let’s take <strong>“reactive-calendar”</strong> to keep it simple.</li>
  <li>Click on the “CREATE PROJECT” button. Now we should be redirected to <a href="https://console.firebase.google.com/project/reactive-calendar/overview">something like this</a>.</li>
  <li>In the Authentication tab, go to “SIGN-IN METHOD” and enable the “Anonymous” setting.</li>
  <li>Click on database and navigate to the rules tab. Set the read and write property to “true” and click “publish”:
    <pre><code class="language-json">{
  "rules": {
      ".read": "true",
      ".write": "true"
  }
}
</code></pre>
  </li>
  <li>Go back to the overview by clicking on the home icon, and then select “Add Firebase to your web app”.</li>
  <li>Copy the config with the correct properties and replace the firebaseConfig object in src/app/app.module.ts with these properties.
It might look something like this:</li>
</ul>

<pre><code class="language-typescript">const firebaseConfig = {
    apiKey: "AIzaSyBuqjTJd5v6xTf8D2EZmvFUl8lseH8lVuHU",
    authDomain: "reactive-calendar.firebaseapp.com",
    databaseURL: "https://reactive-calendar.firebaseio.com",
    projectId: "reactive-calendar",
    storageBucket: "reactive-calendar.appspot.com",
    messagingSenderId: "3978123451455750"
};
</code></pre>

<p>Let’s continue. Start the project by running the following command and open your browser on <a href="http://localhost:4200">http://localhost:4200</a>.</p>

<pre><code>npm start
</code></pre>

<p>As you can see, this just handles static data, the buttons/inputs won’t work, and the appointments are not loaded yet.
This is where we start from.</p>

<h2 id="thinking-reactively">Thinking Reactively</h2>

<p>Now comes the tricky part. We are trying to forget imperative programming for now, and we are trying to evolve into a reactive mindset.</p>

<h3 id="marble-diagrams">Marble Diagrams</h3>

<p>To be able to think reactively, we need some kind of graphic model so we can picture streams in our head. Marble diagrams are a great way to do that.
As you can see in the image below, a marble represents a value over time.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar12.png" alt="Marble diagrams" /></p>

<p>The website <a href="http://rxmarbles.com/">rxmarbles.com</a> has a great playground for learning how to use and draw marble diagrams.</p>

<h4 id="ascii-documentation">ASCII Documentation</h4>

<p>One could argue that code should not be documented and be self-explanatory. I don’t believe that to be the case when writing complex streams. When we document complex streams, we can see what’s going on inside the stream, which makes it easier for our colleagues.
Streams can be documented by ASCII documentation. Since that is not really part of this article, I’m only going to show a small example below.</p>

<pre><code class="language-typescript">// a$ gets three values over time and then stops
// a$: -------a-----b-----c|

// b$ has an initial value (a), has three values in total
// and will keep on living
// b$: a------b-----c------...
</code></pre>

<h3 id="imperative-programming-what-does-the-app-have-to-do">Imperative Programming: What Does the App Have to Do?</h3>

<p>When we think about the functionality of our application, we quickly notice that there are quite a few corner cases and special scenarios. For every interaction the user makes in the UI, the app needs to handle that specific interaction accordingly. Sometimes it has to combine these interactions and handle that specific combination as well. Take this crazy (but simple) example, for instance.</p>

<blockquote>
When the view mode is changed to week mode, and the previous view mode was month mode, and the month was June, and the year was 2017, and an appointment was added, while the search term was set to "Brecht", then we would have to update...
</blockquote>

<p>Yes, we would have to update a bunch of stuff. This is imperative thinking, and it can become exhausting. There is a big chance that we forget certain corner cases. Let’s not even imagine that we have to combine that with asynchronous actions as well.</p>

<p>In the image below, we see all the different interactions the user has in the calendar application.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar2.png" alt="Application events" /></p>

<p>As we can see, for every specific interaction, the UI will have to update specific things.</p>

<h3 id="reactive-programming-what-data-will-change-and-what-data-do-the-components-need">Reactive programming: What Data Will Change, and What Data Do the Components Need?</h3>

<h4 id="source-streams">Source Streams</h4>

<p>Now, let’s completely stop with what we are thinking. Let’s free our minds and stop thinking about corner cases and special scenarios. We have to learn to think in streams. A stream is a collection of events that will change over time. Think about what can change in your application and call these streams of data. Let’s call them <strong>source streams</strong>.</p>

<p><strong>Note:</strong> For readability purposes, we will suffix all the streams with a <code>$</code> symbol.</p>

<p>We can come up with 4 source streams:</p>

<ul>
  <li><strong>navigation$:</strong> Can contain the values: -1, 0 or 1</li>
  <li><strong>viewMode$:</strong> Can contain the values: DAY, WEEK, or MONTH</li>
  <li><strong>searchTerm$:</strong> The value of the search field</li>
  <li><strong>appointments$:</strong> This is an array of appointments that comes from Firebase</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar4.png" alt="data streams" /></p>

<p>That was pretty easy. We just had to think about the events that can occur in our application. A user can navigate, change view mode, search for appointments, and the appointments in Firebase can change. This is the beginning of thinking reactively. Don’t think about who triggers what. Think about the changes as streams.</p>

<p>It’s always a good idea to draw marble diagrams to make it easier to reason.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar5.png" alt="data stream diagram" /></p>

<p><code>The appointments$</code> is a stream that will be provided to us by AngularFire, but the <code>viewMode$</code>, <code>searchTerm$</code>, and <code>navigation$</code> are simple behavior subjects. We use subjects because we need to control the values of the streams ourselves, and we use the <code>BehaviorSubject</code> in particular because all our source streams need an initial value.</p>

<pre><code class="language-typescript">export class AppComponent {
    ...
    // this is how we can retrieve the list of appointments from angularfire
    appointments$ = this.db.list('/appointments');
     // 0--------(+1)----(+1)----(-1)-------------...
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    navigation$ = new BehaviorSubject(0);
    searchTerm$ = new BehaviorSubject('');

	// because we set up the angularfire configuration correctly, we can just
	// inject the angularfiredatabase right here and use it
    constructor(private db: AngularFireDatabase) {
    }
    ...
}

</code></pre>

<p>These subjects get values from the simple interactions from the template.</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        ...
    `
})
export class AppComponent {
    ...
    
    onSetViewMode(viewMode: string): void {
        // when the viewmode changes, update its subject
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        // when the user clicks the previous button
        // update the navigation subject
        this.navigation$.next(-1);
    }

    onNext(): void {
        // when the user clicks the next button
        // update the navigation subject
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        // when the user searches
        // update the searchterm subject
        this.searchTerm$.next(e);
    }
}

</code></pre>

<h4 id="presentational-streams">Presentational Streams</h4>

<p>Now we have to think about the data that our components need, because those components will need to be updated based on those source streams.
Let’s take this code sample, for instance:</p>

<pre><code class="language-html">&lt;div [ngSwitch]="XX" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="XX"
            [date]="XX"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="XX"
            [year]="XX"
            [week]="XX"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="XX"
            [year]="XX"
            [appointments]="xxx"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>I marked the input properties with XX to show what our components need in terms of data. These places will need streams as well. Let’s call them <strong>presentational streams</strong>.</p>

<p>Let’s try to fill in these gaps, shall we?</p>

<p><strong>Note:</strong> We use the <a href="https://angular.io/api/common/AsyncPipe">async pipe</a> from Angular to subscribe/unsubscribe the streams automatically.</p>

<pre><code class="language-html">&lt;div [ngSwitch]="viewMode$|async" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="filteredAppointments$|async"
            [date]="currentDate$|async"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="filteredAppointments$|async"
            [year]="currentYear$|async"
            [week]="currentWeek$|async"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="currentMonth$|async"
            [year]="currentYear$|async"
            [appointments]="filteredAppointments$|async"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>We have gathered the 6 following presentational streams:</p>

<ul>
  <li><strong>viewMode$ (string):</strong> needed to determine which view has to be shown</li>
  <li><strong>filteredAppointments$ (Array &lt; Appointment &gt;):</strong> needed by day view, week view, and month view to render the correct appointments</li>
  <li><strong>currentDate$ (date):</strong> the current date for the day view</li>
  <li><strong>currentWeek$ (number):</strong> the current week for the week view</li>
  <li><strong>currentYear$ (number):</strong> needed by week view and month view</li>
  <li><strong>currentMonth$ (number):</strong> needed by the month view</li>
</ul>

<p>Okay, great, we know the source streams, which are the sources of change in our application.
We know the presentational streams, which are simply the streams that our components need. Now it’s time for the cool part: <strong>We need to create those presentational streams based on the source streams</strong>.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar6.png" alt="sources to presentational streams" /></p>

<p>The first presentational stream we need is <code>viewMode$</code>. This is already an easy one, since <code>viewMode$</code> is also a source stream.</p>

<h4 id="currentdate">currentDate$</h4>
<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar7.png" alt="currentDate$" /></p>

<p><strong>Note:</strong> We use moment.js for date calculation. The suffix M after the currentDate property shows that the type is <code>Moment</code>. So in short, it’s not just a date, but a moment wrapper.</p>

<pre><code class="language-typescript">// we will need this stream a few times, so let's extract the stream 
// in a currentDateM first

// viewMode$:     M------------------W---------------D--------...
// navigation$:   0---(+1)-(-1)----------(+1)-(-1)------------...
// currentDateM$: d---d----d---------d---d----d------d--------...
private currentDateM = this.viewMode$.flatMap((viewMode: string) =&gt; {
    // every time the viewMode changes, the navigation should be reset as well
    // the dateM variable will contain the navigation and because of the 
    // flatMap it will reset every time the view mode changes
    // if the navigation$ changes afterwards it will manipulate the dateM object
    // by adding months, weeks, or days depending on the viewMode
    const dateM = moment();
    return this.navigation$
        .map((action: number) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return dateM.startOf('month').add(action, "months");
                case VIEW_MODE.WEEK:
                    return dateM.startOf('week').add(action, "weeks");
                case VIEW_MODE.DAY:
                    return dateM.startOf('day').add(action, "days");
            }
            return dateM;
        })
})
currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());

</code></pre>

<h4 id="currentweek">currentWeek$</h4>

<p>Based on the <code>currentDateM$</code> we can calculate the current week. The <code>currentDateM$</code> is just a moment object of the current date based on the navigation and viewMode.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar8.png" alt="currentWeek$" /></p>

<pre><code class="language-typescript">currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
</code></pre>

<h4 id="currentmonth">currentMonth$</h4>

<p>Just like we calculated the <code>currentWeek$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar9.png" alt="currentMonth$" /></p>

<pre><code class="language-typescript">currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
</code></pre>
<h4 id="currentyear">currentYear$</h4>

<p>Just like we calculated the <code>currentWeek$</code> and the <code>currentMonth$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar10.png" alt="currentYear$" /></p>

<pre><code class="language-typescript">currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
</code></pre>

<h4 id="filteredappointments">filteredAppointments$</h4>

<p>This is the most important stream. It is used to show the appointments in all the different views, and it is dependent on a bunch of streams:</p>

<ul>
  <li>viewMode$</li>
  <li>currentDateM$</li>
  <li>appointments$</li>
  <li>searchTerm$</li>
</ul>

<p>This looks a bit more complex, but let’s give it a go.</p>

<p><strong>Note:</strong> the <code>[]</code> in the image below stands for an empty array, the <code>[.]</code> for an array with one value, and so on.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar11.png" alt="filteredAppointment$" /></p>

<p>Let’s take the time to process this image. The operator we will use to combine all these streams is called <strong>combineLatest</strong>. It will create a stream that will wait until all streams have a value and will start emitting values for every change of every stream.</p>

<p>So basically, it gives us a function where we have all the information we need. The appointments in Firebase, the view mode, the search term, and the current date. Based on those values, we can calculate the appointments for every view:</p>

<pre><code class="language-typescript">filteredAppointments$ = Observable.combineLatest(
    [this.viewMode$, this.currentDateM$, 
    this.appointments$, this.searchTerm$],
    (viewMode: string, currentDateM: Moment, 
        appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
        switch (viewMode) {
            // calculate the appointments for the month-view based on
            // the current date, the appointments in firebase 
            // and the searchterm
            case VIEW_MODE.MONTH:
                return appointments
                    .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
             // calculate the appointments for the week-view based on
             // the current date, the appointments in firebase
             // and the searchterm
            case VIEW_MODE.WEEK:
                return appointments
                    .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
            // calculate the appointments for the day-view based on
            // the current date, the appointments in firebase
            // and the searchterm
            case VIEW_MODE.DAY:
                return appointments
                    .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));

        }
    });

private filterByTerm(appointment: Appointment, term: string): boolean {
    return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
}
</code></pre>

<p>This is all we have to do in order to create a kick-ass realtime reactive calendar application. We have created it in no time and with only a few lines of code. If we think about it, we will soon realize that all corner cases have been covered.</p>

<h2 id="performance-improvements">Performance Improvements</h2>

<p>The complete component looks like the code snippet below now. The calendar should be completely functional in your browser.</p>

<pre><code class="language-typescript">import { Component } from '@angular/core';
import { VIEW_MODE } from '../../constants';
import * as moment from 'moment';
import { Appointment } from '../../types/appointment.type';
import { AngularFireDatabase } from 'angularfire2/database';
import { Observable } from 'rxjs/Observable';
import Moment = moment.Moment;
import { BehaviorSubject } from 'rxjs/BehaviorSubject';


@Component({
    selector: 'app-root',
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        &lt;div [ngSwitch]="viewMode$|async"&gt;
            &lt;day-view
                    *ngSwitchCase="VIEW_MODE.DAY"
                    [appointments]="filteredAppointments$|async"
                    [date]="currentDate$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/day-view&gt;
            &lt;week-view
                    *ngSwitchCase="VIEW_MODE.WEEK"
                    [appointments]="filteredAppointments$|async"
                    [year]="currentYear$|async"
                    [week]="currentWeek$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/week-view&gt;
            &lt;month-view
                    *ngSwitchCase="VIEW_MODE.MONTH"
                    [month]="currentMonth$|async"
                    [year]="currentYear$|async"
                    [appointments]="filteredAppointments$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/month-view&gt;
        &lt;/div&gt;
    `,
    styleUrls: ['./app.component.less']
})
export class AppComponent {
    VIEW_MODE = VIEW_MODE;
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    // 0--------(+1)----(+1)----(-1)-------------...
    navigation$ = new BehaviorSubject&lt;number&gt;(0);
    searchTerm$ = new BehaviorSubject('');

    // -----MONTH---------------------YEAR------...
    // -----MONTH-------------------------------...
    // -----(d)---------------------------------...
    // --------(+1)----(+1)----(-1)-------------...
    // -----d---d-------d-------d-----d----------...

    private currentDateM$ = this.viewMode$.flatMap((viewMode: string) =&gt; {
        let dateM = moment();
        return this.navigation$
            .map((action: number) =&gt; {
                switch (viewMode) {
                    case VIEW_MODE.MONTH:
                        return dateM.startOf('month').add(action, 'months');
                    case VIEW_MODE.WEEK:
                        return dateM.startOf('week').add(action, 'weeks');
                    case VIEW_MODE.DAY:
                        return dateM.startOf('day').add(action, 'days');
                }
                return dateM;
            })
    });

    currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());
    currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
    currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
    currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
    appointments$ = this.db.list('/appointments');
    filteredAppointments$ = Observable.combineLatest([this.viewMode$, this.currentDateM$, this.appointments$, this.searchTerm$],
        (viewMode: string, currentDateM: Moment, appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.WEEK:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.DAY:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));

            }
        });

    constructor(private db: AngularFireDatabase) {
    }

    private filterByTerm(appointment: Appointment, term: string): boolean {
        return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
    }

    onSetViewMode(viewMode: string): void {
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        this.navigation$.next(-1);
    }

    onNext(): void {
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        this.searchTerm$.next(e);
    }

    onRemoveAppointment(id: string): void {
        this.appointments$.remove(id);
    }

    onAddAppointment(date: Date): void {
        this.appointments$.push(new Appointment(date.toDateString(), ''));
    }

    onUpdateAppointment(appointment: Appointment): void {
        this.db.object('appointments/' + appointment.$key).set({
            description: appointment.description,
            date: appointment.date
        });
    }
}

</code></pre>

<p>There is only one problem. We use the same observables multiple times in our template. Since observables are cold by default, they will get executed every time there is a subscription. In Angular, this means a subscription for every async pipe. For performance reasons, we only want to recalculate these streams when something actually changes. For that purpose, we can try to use the <code>share()</code> operator from RxJS. The <code>share()</code> operator is an alias for <code>publish().refCount()</code> and will share the subscription.</p>

<p>However, that creates some problems with Angular and its async pipe.
The situation of the problem goes like this:</p>

<ul>
  <li>Since we are using BehaviorSubjects, the streams will get an initial value (which is what we want, of course).</li>
  <li>The share() operator will emit that value on the first subscription</li>
  <li>When the app is initialized, the async pipes will start subscribing to the stream.</li>
  <li>Because the first async pipe triggered the first emit the rest of the async pipes will miss that value.</li>
</ul>

<p><strong>Solution: shareReplay() will emit those values but keep track of them. That way, the async pipes will never miss a value.</strong></p>

<h2 id="conclusion">Conclusion</h2>

<p>We have created a completely reactive calendar that is performant and fixes a bunch of corner cases in only a few lines of code. Just by thinking about source streams and presentational streams, it wasn’t even that hard. I hope that I can encourage more people to take on this reactive approach and start writing kick-ass applications.</p>

<h2 id="special-thanks">Special Thanks</h2>

<p>I would like to give special thanks to the awesome people that reviewed this post and gave me pointers:</p>

<ul>
  <li>Dominic Elm (<a href="https://twitter.com/elmd_">@elmd_</a>)</li>
  <li>Manfred Steyer (<a href="https://twitter.com/manfredsteyer">@manfredsteyer</a>)</li>
  <li>David Müllerchen (<a href="https://twitter.com/webdave_de">@webdave_de</a>)</li>
  <li>Maxim Robert (<a href="https://twitter.com/sizerone">@sizerOne</a>)</li>
</ul>

<p>Thanks, guys! It means a lot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Infinite scroll in Angular an RxJS</title>
	  <link>//infinite-scroll-with-rxjs-and-angular2/</link>
	  <author></author>
	  <pubDate>2016-12-21T00:00:00+00:00</pubDate>
	  <guid>//infinite-scroll-with-rxjs-and-angular2/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>This article explains how the “reactive-programming” approach helps us to create an awesome <strong>infinite-scroll-list</strong> in only a few lines of code. For this article, we are going to use <a href="http://reactivex.io/rxjs/">RxJS</a> and <a href="http://angular.io">Angular</a>. If <a href="http://reactivex.io/rxjs/">RxJS</a> is completely new, it might be a good idea to read the documentation first. Whether we use <a href="http://angular.io">Angular</a> or something else like <a href="https://facebook.github.io/react/">React</a>, it shouldn’t really interfere with the clarity of this article.</p>

<h2 id="reactive-programming">Reactive programming</h2>

<p>Reactive programming is a rather old but very powerful approach of solving problems. However, we can run into problems when trying to think in a completely reactive manner. Thinking reactively is a huge mind switch that we must make to completely accept this “new” way of coding things. The whole “Our application reacts to a state-management-layer like <a href="http://redux.js.org/">redux</a>” principle is grasped quite quickly (it’s reactive programming too), but when it comes to <a href="http://freecontent.manning.com/reactive-fundamentals-thinking-in-streams/">thinking in streams</a> it can become quite difficult in the beginning.</p>

<h3 id="why-reactive-programming">Why reactive programming?</h3>

<p>Reactive programming has some advantages over imperative programming.</p>

<ul>
  <li>No more “if this, then that” scenario’s</li>
  <li>We can forget about a ton of edge-cases&lt;</li>
  <li>It’s easy to separate presentation logic from other logic (The presentation layer will just react to streams)</li>
  <li>It’s a standard: widely supported by tons of languages</li>
  <li>When we grasp the concepts, we write complex logic in a few lines of code in a very simple manner</li>
</ul>

<p>A few days back a colleague of mine came to me with this problem: He wanted to create an <strong>infinite-scroll in Angular</strong> but he had bumped into the  boundaries of imperative programming. It turned out that an infinite-scroll-solution was actually a great use-case to explain how reactive programming can help you write better code.</p>

<h2 id="the-infinite-scroll">The infinite scroll</h2>

<h3 id="what-should-it-do">What should it do?</h3>

<p>An infinite-scroll-list, is a list where the data is being loaded asynchronosly when the user scrolls further down the application. It’s a great way to avoid a pager (where the user had to click on every time) and it can really keep the application performant. It’s an efficient way to keep bandwidth low and increase the user-experience.</p>

<p>For this scenario, let’s say that every page contains 10 results and that all the pages with results are being shown as one long scrollable list =&gt; the infinite-scroll-list.</p>

<p>Let’s list the features of what our infinite-scroll-list must do:</p>

<ul>
  <li>It should load the first page by default</li>
  <li>When the results of the first page don’t fill the page completely, it should fill page 2, and so on, until the page is full</li>
  <li>When the user scrolls down, it should load page 3, and so on…</li>
  <li>When the user resizes it’s window, and more space is being freed for results, it should load the next page</li>
  <li>It should make sure that it doesn’t load the same pages more than once (caching)</li>
</ul>

<h2 id="lets-draw-it-first">Let’s draw it first</h2>

<p>Like most coding decisions, drawing them on a whiteboard first might be a good idea. That might be a personal approach, but it helps us not to write code that will be removed/refactored later.</p>

<p>Based on the feature-list, there are three actions that will trigger the application to load data: Scrolling, resizing, and a manual action that will be triggered to manually fetch pages. When thinking reactively we can see 3 sources of events happening, let’s call them streams:</p>

<ul>
  <li>A stream of scroll events: <strong>scroll$</strong></li>
  <li>A stream of resize events: <strong>resize$</strong></li>
  <li>A manual stream where we can manually decide what page to load: <strong>pageByManual$</strong></li>
</ul>

<p><strong>Note: We will suffix the streams with $ to indicate that they are streams, this is a convention (personal preference)</strong></p>

<p>Let’s draw these streams on a whiteboard:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard1.png" alt="Whiteboard 1" /></p>

<p>These streams would contain certain values over time:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard2.png" alt="Whiteboard 2" /></p>

<p>The scroll$ stream has Y values, which we can use to calculate the page number.</p>

<p>The resize$ stream has event values. We don’t need the values but we do need to know when the user resizes its window.</p>

<p>The pageByManual$ will contain page numbers, which we can set directly since this is a subject (more on that later).</p>

<p>What if we could map all these streams, to streams that would contain page numbers? That would be awesome, because based on the page number, we could load a specific page. How we map the current streams to page number-streams is not something that we need to think about right now (we are just drawing remember?).
The next drawing might look something like this:</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard3.png" alt="Whiteboard 3" /></p>

<p>We can see that we have created the following streams based on our initial streams:</p>

<ul>
  <li><strong>pageByScroll$</strong>: which contains page numbers based on the scroll-events</li>
  <li><strong>pageByResize$</strong>: which contains page numbers based on the resize-events</li>
  <li><strong>pageByManual$</strong>: which contains page numbers based on manual events (for instance, if there is still whitespace on the screen, we have to load the next page)</li>
</ul>

<p>What if we could merge these 3 page-number streams in an efficient manner, than we would get a new stream called <strong>pageToLoad$</strong>, that would contain page numbers created by scrolling-events, resize-events, and manual events.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard4.png" alt="Whiteboard 4" /></p>

<p>If we subscribe to the pageToLoad$ stream and than fetch data from the service, part of our infinite scroll would work. However, we were thinking reactively right? That also means, avoid subscriptions as much as possible… 
We actually need a new stream based on the pageToLoad$ stream that contains the results of our infinite scroll list…</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard5.png" alt="Whiteboard 5" /></p>

<p>Now let’s throw this in one big schema.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard6.png" alt="Whiteboard 6" /></p>

<p>As we can see above we have 3 input streams: one for scrolling, one for resizing and a manual one.
Afterwards we have 3 page streams that are based on the input streams. When merging these streams we can create a pageToLoad$ stream. Based on that pageToLoad$ stream, we will fetch the data.</p>

<h2 id="lets-code">Let’s code</h2>

<p>We have drawn more than enough, we have a clear vision of what our inifinte-scroll-list should do, so let’s start shall we?</p>

<p>To calculate which page needs to be loaded we need 2 properties:</p>

<pre><code class="language-typescript">private itemHeight = 40;
private numberOfItems = 10;// number of items in a page
</code></pre>

<h3 id="pagebyscroll">pageByScroll$</h3>

<p>The pageByScroll$ stream might look something like this:</p>

<pre><code class="language-typescript"> 
// first of all, we want to create a stream that contains 
// all the scroll events that are happening in the window object
private pageByScroll$ = fromEvent(window, "scroll")
  .pipe(
	// we are only interested in the scrollY value of these events
	// let's create a stream with only these values
	map(() =&gt; window.scrollY),
	// create a stream with the filtered values
	// we only need the values from when we are scrolling outside
	// our viewport
	filter(current =&gt; 
	  current &gt;=  document.body.clientHeight - window.innerHeight),
	// Only when the user stops scrolling for 200 ms, we can continue
	// so let's debounce this stream for 200 ms
	debounceTime(200),
	// filter out double values
	distinct(), 
	// calculate the page number
	map(y =&gt; Math.ceil(
		(y + window.innerHeight)/ (this.itemHeight * this.numberOfItems))
	)
  );
	
	// --------1---2----3------2...
</code></pre>

<p><strong>note: In real applications you might want to use injected services for window and document</strong></p>

<h3 id="pagebyresize">pageByResize$</h3>

<p>The pageByResize$ looks like this:</p>

<pre><code class="language-typescript">private pageByResize$ = 
  // Now, we want to create a new stream that contains 
  // all the resize events that are happening in the window object
  fromEvent(window, "resize")
	.pipe()
		// when the user stops resizing for 200 ms, then we can continue
		debounceTime(200),
		// calculate the page number based on the window
		map(_ =&gt; Math.ceil(
			(window.innerHeight + document.body.scrollTop) / 
			(this.itemHeight * this.numberOfItems)
		))
	);
	// --------1---2----3------2...
</code></pre>

<h3 id="pagebymanual">pageByManual$</h3>

<p>The pageByManual$ is the stream we use to have an initial value (initial page to load), but it’s also something that we need to control manually. A <a href="http://reactivex.io/documentation/subject.html">Behavior subject</a> looks perfect for the job, because we need a stream that has an initial value where we can also manually add values. A behavior subject is just a stream that has an initial value and can be manipulated over time.</p>

<pre><code class="language-typescript">private pageByManual$ = new BehaviorSubject(1);

// 1---2----3------...
</code></pre>

<h3 id="pagetoload">pageToLoad$</h3>

<p>Awesome, we have the 3 streams with page inputs, now let’s create a pageToLoad$ stream.</p>

<pre><code class="language-typescript">private pageToLoad$ = 
  // merge all the page streams and create a new stream of those
  merge(this.pageByManual$, this.pageByScroll$, this.pageByResize$)
	.pipe(
		// create a new stream where the double values are filtered out
		distinct(),
		// check if the page is already in the cache 
		// (just an array property in our component)
		filter(page =&gt; this.cache[page-1] === undefined)
	);
</code></pre>

<h3 id="itemresults">itemResults$</h3>

<p>The hard part is over. We now have a stream with the page we have to load in there, which is super useful. We don’t need to care anymore about corner cases or other complex logic. Every time a new value in that stream is added, we just need to load the data. <strong>That’s it!!</strong></p>

<p>We will use <a href="http://reactivex.io/documentation/operators/flatmap.html">flatmap</a> for this because the fetch-data-call will return a stream as well. FlatMap (or MergeMap) will merge these 2 streams as one.</p>

<pre><code class="language-typescript">itemResults$ = this.pageToLoad$
  .pipe(
    // based on that stream, load our asynchronosly data
    // flatmap is an alias for mergemap
    flatMap((page: number) =&gt; {
      // load me some starwars characters
      return this.httpClient.get(`https://swapi.co/api/people?page=${page}`)
        .pipe(
          // create a stream that contains the results
          map(resp =&gt; resp.results),
          tap(resp =&gt; {
            // add the page to the cache
            this.cache[page -1] = resp;
            // if the page contains enough white space
            // load some more data :)
            if((this.itemHeight * this.numberOfItems * page) 
			  &lt; window.innerHeight) {
              this.pageByManual$.next(page + 1);
            }
          })
        )
      }),
      // eventually, just return a stream that contains the cache
      map(_ =&gt; flatMap(this.cache))
  ); 
</code></pre>

<h3 id="the-result">The result</h3>

<p>the complete result might look like this:  <strong>Note the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#!#async-pipe">async pipe</a> that puts the whole subscription process into play</strong></p>

<pre><code class="language-typescript">import {Component} from '@angular/core';
import {Observable, BehaviorSubject} from 'rxjs';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import {distinct, filter, map, debounceTime, tap, flatMap} from 'rxjs/operators';
import {HttpClient} from '@angular/common/http';
import * as _ from 'lodash';
@Component({
  selector: 'infinite-scroll-list',
  template: `
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr *ngFor="let item of itemResults$|async" 
	  	[style.height]="itemHeight + 'px'"&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
  `
})
export class InfiniteScrollListComponent {
  private cache = []; 
  private pageByManual$ = new BehaviorSubject(1);
  private itemHeight = 40;
  private numberOfItems = 10; 
  private pageByScroll$ = fromEvent(window, "scroll")
    .pipe(
        map(() =&gt; window.scrollY),
        filter(current =&gt; 
			current &gt;=  document.body.clientHeight - window.innerHeight),
        debounceTime(200),
        distinct(),
        map(y =&gt; Math.ceil(
			(y + window.innerHeight)/ (this.itemHeight * this.numberOfItems)
			)
		)
    );
       
  private pageByResize$ = fromEvent(window, "resize")
    .pipe(
      debounceTime(200),
	    map(_ =&gt; Math.ceil(
        (window.innerHeight + document.body.scrollTop) / 
        (this.itemHeight * this.numberOfItems)
      ))
    )
    
  private pageToLoad$ = merge(
	  this.pageByManual$, 
	  this.pageByScroll$, 
	  this.pageByResize$)
    .pipe(
      distinct(),
      filter(page =&gt; this.cache[page-1] === undefined)
    );

  loading = false;
    
  itemResults$ = this.pageToLoad$
    .pipe(
      tap(_ =&gt; this.loading = true),
      flatMap((page: number) =&gt; {
        return this.httpClient.get(`https://swapi.co/api/people?page=${page}`)
          .pipe(
            map((resp: any) =&gt; resp.results),
            tap(resp =&gt; {
              this.cache[page -1] = resp;
              if((this.itemHeight * this.numberOfItems * page) 
			  	&lt; window.innerHeight) {
                this.pageByManual$.next(page + 1);
              }
            })
          )
      }),
      map(() =&gt; _.flatMap(this.cache))
    ); 
  
  constructor(private httpClient: HttpClient){ 
  } 
}
</code></pre>

<p>Here is a <a href="https://stackblitz.com/edit/angular-qszxoh?file=app%2Finfinite-scroll-list.component.ts">working stackblitz</a></p>

<iframe src="https://stackblitz.com/edit/angular-qszxoh?embed=1&amp;file=app/infinite-scroll-list.component.ts" frameborder="0" width="100%" height="480px">
</iframe>

<p>Again, (like I try to prove in previous articles) We don’t need to use third party solutions for everything. The infinite-scroll-list doesn’t contain that much code, and it’s very flexible.
Let’s say that we would like to free up DOM-elements and use only 100 items at a time, we could just create a new stream for that :)</p>

<p>Thanks for reading, I hope you enjoyed it.</p>

	  ]]></description>
	</item>


</channel>
</rss>
