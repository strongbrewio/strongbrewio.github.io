<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link>https://blog.strongbrew.io/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Redux (@ngrx/store) best practices</title>
	  <link>//Redux-best-practices/</link>
	  <author></author>
	  <pubDate>2018-04-27T00:00:00+00:00</pubDate>
	  <guid>//Redux-best-practices/</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">@ngrx/store</a> is a library that tries to solve the problems of state management through the principles of <a href="https://redux.js.org/">Redux</a>. The difference between Redux and @ngrx/store is that @ngrx/store is written specifically for <a href="https://angular.io">Angular</a> and it embraces the use of Observables from <a href="http://reactivex.io/rxjs/">RxJS</a>.
The combination of redux principles and RxJS can be very powerful when it comes to writing reactive applications.
Since a lot of Angular projects use @ngrx/store, it might be a good idea to write down some best-practices.</p>

<p>Note: The best-practices and opinions described in this article are strictly personal. Best practices are almost always a matter of opinion. Nevertheless, we (StrongBrew) are using these best practices at all our customers on a daily basis and they certainly work for us.   From now on @ngrx/store will be reffered to as Redux in this article.</p>

<h2 id="to-redux-or-not-to-redux">To Redux or not to Redux?</h2>

<p>The first question that we might want to ask ourselves is do we really need Redux in our application.
It is a best practice to only use it when your application demands it.
<a href="https://blog.strongbrew.io/do-we-really-need-redux">This article</a> tackles this question separately.</p>

<h2 id="basic-best-practices">Basic best practices</h2>

<p>While the following list might be common sense for an experienced Redux developer, let’s sum those up as a refreshment for the sake of completeness.</p>
<ul>
  <li>Our application can only count one store, otherwise it would become too complex</li>
  <li>Reducers have to be pure, this is a principle from functional programming which makes functions predictable and avoids side effects</li>
  <li>Immutable datastructures are very important to optimise change detection cycles and avoid unexpected behavior, therefore reducers should handle data in an immutable manner</li>
  <li>Reducers always have to return a value! So don’t forget to implement the default case of the switch statement to return the original state</li>
</ul>

<h2 id="dont-add-models-to-the-store">Don’t add models to the store</h2>

<p>A model can be seen as a javascript object which has functionality, like the following example:</p>

<pre><code class="language-typescript">class User{
    constructor(private firstName: string, private lastName:string){
    }

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`; 
    }
}
</code></pre>

<p>While the Redux package written by Dan Abramov forbids sending these prototyped objects as a payload, @ngrx/store does not forbid it yet.
However, it is a bad practice because it adds a lot of complexity to the store and chances are big that the models will get broken because of the immutable way of handling data. Check this example for instance:</p>

<pre><code class="language-typescript">const user = new User('Brecht', 'Billiet');
console.log(user.fullName); // Brecht Billiet
const updatedUser = {...user, lastName: 'Doe'};
console.log(updatedUser.fullName); // undefined
</code></pre>

<p>Since we have updated the user in an immutable way, it has created a new reference and therefore all its functionality has been lost.
This is exactly what our reducers will do with the data that flows into them. So always send plain objects when it comes to sending payloads in the actions.</p>

<p>Another approach for models is using Interfaces. Interfaces are great because are only interpreted in compile time, doesn’t use memory in runtime and are very expressive. If your model doesn’t need to be computed (like <code>get fullName()</code> in the previous example), then is advisable to use Interfaces instead.</p>

<p>Using Interfaces allows us to get advantage of some TypeScript features like <code>Pick&lt;T&gt;</code>. With <code>Pick&lt;T&gt;</code> we can create Types from Interfaces, which is very handy in some situations, like creating a model and a record with fewer properties:</p>

<pre><code class="language-typescript">export interface User {
    id: number;
    name: string;
    middleName: string;
    lastName: string;
    fullName: string;
    address: string;
    city: string;
    state: string;
    zip: string;
}

export type UserRecord = Pick&lt;User, 'id' | 'fullName'&gt;;
</code></pre>

<p>If the endpoint to get a list of users is returning a partial object instead of the full object then we can create a new Type instead of two Classes or Interfaces. This is a cleaner approach and easier to maintain if your models are prepared for your UI.</p>

<h2 id="what-do-we-put-in-the-store">What do we put in the store?</h2>

<p>We shouldn’t put things in the store just because we can. We have to think about what state needs to be in there and why.
State that is being shared between components can sometimes be kept in the parent component for instance. We call that inner state:
The component keeps its own state, the component itself is responsible for that. If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux.</p>

<p>However, when state needs to be shared between different root components (rendered inside a router-outlet) we might want to keep that state in the store.</p>

<p>When we need to remember a value when navigating through the application we could put that in the store as well. An example here could be: Remembering if a sidebar was collapsed or not, so when we navigate back to the page with the sidebar, it would still be collapsed.</p>

<p>Complex state is something that we might want to put in the store as well, since Redux can handle complex state management in an elegant way.
The general rule of thumb here could be, <strong>Only keep shared state, values that we want to remember and complex state in the store</strong>. Don’t add state in the store if we don’t need to, it would result in unneeded boilerplate and complexity.</p>

<p>That being said, there are 2 more reasons where we might want to add extra state into the store:</p>
<ul>
  <li>When we want to make our application real-time. Check out <a href="https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/">How we made our app real time in 6 lines of code</a>.</li>
  <li>When we want to do optimistic updates. Check out <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">Cancellable optimistic updates in Angular2 and Redux</a></li>
</ul>

<h2 id="dont-forget-about-router-params">Don’t forget about router params</h2>

<p>A common mistake is putting things inside the store that could easily be added in the url.
The benefit of keeping state in the url is:</p>

<ul>
  <li>We can use the browser navigation buttons</li>
  <li>We can bookmark the url</li>
  <li>We can share that url with other people</li>
</ul>

<p>If we can put simple things into the url, we should at least consider it.</p>

<h2 id="avoid-huge-lists">Avoid HUGE lists</h2>

<p>Redux can not be seen as a local in-memory database, so we can’t put all our data into the store for performance reasons.
Redux can be seen as an abstraction of state and data that our application needs at a certain time.</p>

<p>For instance if we have a list of 10000 users, we don’t want to put them all in the store. What we could do is keep track of a list of 500 users in the store, which the user can see at that specific time, and load more users on the background and update that buffered list.</p>

<h2 id="designing-the-state">Designing the state</h2>

<p>Designing the state of our application is an important step, and we recommend to draw that state on a whiteboard first. The most important rule here is: <strong>Keep the state as flat as possible</strong></p>

<p>One of the most common bad practices is deep-nesting the state into something that becomes rather complex:</p>

<pre><code class="language-typscript">
// this is an example of how not to design state
export interface ApplicationState {
    moduleA: {
        data: {
            foo: {
                bar: {
                    users: User[],
                    cars: Car[]
                }
            }
        }
    }
}  

// keeping it flat makes the application way easier
export interface ApplicationState {
    users: User[],
    cars: Car[]
}  
</code></pre>

<p>I’m not saying you cannot nest state, I am saying we have to be very careful when we do. The general rule of thumb here is: <strong>keep the state as flat as possible</strong>
If we want to compose state in @ngrx/store we can work with feature module reducers and lazy load them as we can see in <a href="https://github.com/ngrx/platform/blob/master/docs/store/api.md#feature-module-state-composition">Feature Module State Composition</a>.</p>

<h2 id="make-everything-readonly">Make everything readonly</h2>

<p>We already covered the reason why we need to work immutable, but how can we enforce this?
Typescript comes with a readonly keyword which we can use to make a property readonly</p>

<pre><code class="language-typescript">type User = {
    readonly firstName: string;
    readonly lastName: string;
}

const user: User = {firstName: 'Brecht', lastName: 'Billiet'};
user.lastName = 'Doe';//cannot assign to 'lastName' 
// because it is a constant of read-only property
</code></pre>

<p>This would certainly make sure we aren’t updating properties in our reducers by accident. It does suck that we have to write readonly for every property.
The cool thing is that typescript offers us something called “advanced types” where we can do something like this:</p>

<pre><code class="language-typescript">// By using the Readonly&lt;&gt; advanced types all the properties inside the type
// are readonly by default
type User = Readonly&lt;{
    firstName: string;
    lastName: string;
}&gt;;
</code></pre>

<h2 id="action-design">Action design</h2>

<h3 id="actiontypes">Actiontypes</h3>

<p>An action type should be a string that explains what the action should change in the store. Keep these strings consistent. Don’t make the actiontypes too long, keep them short and clear.</p>

<pre><code class="language-typescript">// This is bad
const DATA_USERS_SET_USER_ADDRESS = 'DATA_USERS_SET_USER_ADDRESS';

// This is better
const SET_USER_ADDRESS = 'SET_USER_ADDRESS';

</code></pre>

<p>Another cool idea might be to suffix the action with square brackets and put the whole thing into an action object:</p>

<pre><code class="language-typescript">
// Easy to read/debug
const UserActions = {
  SET_ADDRESS: '[USER] ADDRESS'
}

</code></pre>

<p>If the state managment would become very large we could prefix the action, but let’s keep it simple and small as long as we can.</p>

<h3 id="action-creator-classes">Action creator classes</h3>

<p>When we use plain action types and payloads it becomes quite painful to remember all the action type names and all the payloads that belong to them. This example for instance:</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(
    {
        type: 'SET_USER_ADDRESS', 
        payload: {user_id, address}
    });
</code></pre>

<p>That’s pretty nasty if we want remember all that stuff, so let’s create action creator classes for these. What if we could do this?</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(new SetUserAddressAction(user_id, address));
</code></pre>

<p>That’s just became way easier to use and we don’t have to remember the payload of the action.</p>

<p>If we wanted to implement the actioncreator class for this action it would look like this:</p>

<pre><code class="language-typescript">class SetUserAddressAction implements Action {
    type = SET_USER_ADDRESS;
    payload: {user_id: string, address: Address};
    constructor(user_id: string, address: Address){
        this.payload = {user_id, address};
    }
}
</code></pre>

<h3 id="payload-design">Payload design</h3>

<p>When the action would only have one property for the payload we might be encouraged to use the payload directly instead of creating a property in it. However that would lead to inconsistency, so it might be better to always use subproperties</p>

<pre><code class="language-typescript">// This is bad (inconsistent with the rest of the actions)
class UpdateUserAction implements Action {
    type = UPDATE_USER;
    payload: User;
    constructor(user: User){
        this.payload = user;
    }
}
// This is better
class UpdateUserAction implements Action{
    type = UPDATE_USER;
    payload: {user: User};
    constructor(user: User){
        this.payload = {user};
    }
}
</code></pre>

<h3 id="type-safety">Type Safety</h3>

<p>Type Safety is a huge win when using Redux with typescript, it requires a bit of boilerplate but it makes developing reducers feel like a walk in the park. It makes sure that our applications won’t compile if they have type errors and it gives us great autocompletion inside our reducers.
Therefore I would definitely consider it a must. Since <a href="https://twitter.com/KwintenP">Kwinten Pisman</a> already wrote an <a href="https://blog.strongbrew.io/type-safe-actions-in-reducers/">awesome article</a> about this we won’t go in to much detail here.</p>

<h2 id="reducer-design">Reducer design</h2>

<h3 id="destructuring-the-payload">Destructuring the payload</h3>

<p>If we want to make the reducer code more readable and shorter we could use javascript destructuring for that.
This might be personal preference, but it sure as hell makes our reducers easier to read. Take this example for instance:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS':
        return state.map(v =&gt; 
          v.id === action.payload.user_id ? 
          {...user, address: action.payload.address} : 
          v
        )
    }
}
</code></pre>
<p>The <code>action.payload.</code>code comes back a few times, resulting in longer codelines.
The following piece of code might be more readable:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS': {
        const {user_id, address} = action.payload;
        return state.map(v =&gt; 
          v.id === user_id ? 
          {...user, address} : 
          v
        )
      }
    }
}
</code></pre>

<p>As we can see have have used destructuring to extract the properties of the payload into variables.
Cleaner right? Let’s imagine that our actions has 5 or even more properties on their payloads. In that case this would definitely help.
Something to note here is that the case implementation is wrapped inside a block statement. This is important because our reducer can have the same payload properties for different actions.</p>

<p>This means that <code>user_id</code> and <code>address</code> won’t be available in the other case statements, which is exactly what we want.</p>

<h3 id="dont-write-business-logic-inside-our-reducers">Don’t write business logic inside our reducers</h3>

<p>Reducers should not contain business logic, they are used to handle the state in an immutable fashion. We won’t write business logic inside reducers because:</p>

<ul>
  <li>It would become very complex</li>
  <li>Business logic has nothing to do with state management</li>
  <li>We have services for that</li>
</ul>

<h3 id="child-reducers">Child reducers</h3>

<p>When reducers need to update a piece of state a few levels down in the tree it can become complex in no-time. Take this example for instance:</p>

<pre><code class="language-typescript">type User = {
    id: string;
    contracts: Contract[];
}
type Contract = {
    id: string;
    assignees: Assignee[];
}
type ApplicationState = {
    users: User[];
}   
...
</code></pre>

<p>If we would put all the logic to add an assignee to a specific contract of a specific user, the code would be hard to read. Checkout the following piece of code:</p>

<pre><code class="language-typescript">// This is bad
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: user.contracts.map(contract =&gt; 
            contract.id === contract_id ?
            {
              ...contract, 
              assignees: [...contract.assignees, assignee]
            } : 
            contract
          )
        } : 
        v
      )
    }
    default:
      return state;
  }
}
</code></pre>

<p>When reducers become complex it might be a good idea to split the reducer up into child reducers. Check the refactored version of the previous example:</p>

<pre><code class="language-typescript">// This is better
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: contractsReducer(contracts, action.payload)
        } : 
        v
      )
    }
    default:
      return state;
  }
}

function contractsReducer
  (state: Contract[], action: UserActions): Contract []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const { contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === contract_id ? 
        {
          ...contract, 
          assignees: [...assignees, assignee]
        } : 
        v
      )
    }
    default:
      return state;
  }
}

</code></pre>

<p>As we can see, we have extracted the handling of contracts into its own reducer, which follows the exact same principles of a regular reducer.</p>

<p>The example just became a lot easier to read and way more maintainable. When traversing complex data structures, reducer nesting can be a really elegant way of managing state.</p>

<h2 id="testing">Testing</h2>

<p>Since reducers are pure functions, unit testing them is very easy.
We won’t need to mock out any dependencies and we only have to test the value that the reducer returns.</p>

<p>We can also use <a href="https://www.npmjs.com/package/deep-freeze">deepfreeze</a> to freeze the state that when the reducer accidently mutates data, the tests will throw an error. Deepfreeze is nothing more than a recursive <code>Object.freeze</code></p>

<pre><code class="language-typescript">describe('reducer: usersReducer', () =&gt; {
  describe('case UPDATE_USER', () =&gt; {
    it('should return a new instance with the correct state', 
    () =&gt; {
      const initialState = [new User('1'), new User('2')];
      // deepfreeze makes sure the reducer 
      // doesn't mutate anything by accident
      deepfreeze(initialState); 
      const user = new User('2');
      const action = new UpdateUserAction(user);
      const newState = usersReducer(initialState, action);
      // check if the result of the array is a new ref
      expect(newState).not.toBe(initialState); 
      // check if the result of the user is a new ref
      expect(newState[1]).not.toBe(initialState[1]);
      // check if the user got updated automatically
      expect(newState[1]).toEqual(user);
    });
  });
});
  
</code></pre>

<p><strong>Note: Don’t forget to test the default action</strong></p>

<h2 id="decoupling-redux-from-the-presentation-layer">Decoupling redux from the presentation layer</h2>

<p>Having the store injected everywhere in our application is not a good idea. We want to create an Angular, Vue or React application. Not a Redux application.</p>

<p>Therefore we could consider the following as best practices:</p>
<ul>
  <li>Components don’t need to know we are using Redux, don’t inject the store in them.</li>
  <li>Services generally don’t need to know we are using Redux, don’t inject the store in them.</li>
  <li>We want to be able to refactor Redux away from our application without to much effort</li>
</ul>

<p>Therefore we want to have some kind of abstraction layer between the presentation layer and the state management layer.</p>

<p>How to abstract away the statemanagement layer can be read in the following two articles: <a href="https://blog.strongbrew.io/A-scalable-angular2-architecture/">A scalable angular architecture</a> and <a href="https://blog.strongbrew.io/A-scalable-angular-architecture-part2/">A scalable angular architecture part 2</a>.
This is an architecture that we are using at our customers that really works for us.</p>

<h2 id="redux-as-a-messaging-bus-vs-redux-as-a-state-management-layer">Redux as a messaging bus VS redux as a state management layer</h2>

<p>This might be a personal preference, but I like to use Redux as a pure state management layer. Yes, there are tools like @ngrx/effects where
we can send actions to our application and those actions won’t just perform state management but will do XHR calls among other things.</p>

<p>The nice thing about this approach is that we use some kind of messaging bus. However, I mostly like to keep it simple and abstract Redux away as much as possible. Therefore I don’t use @ngrx/effects and only use Redux to update pieces of state and consume theses pieces. Some part of me believes that Redux shouldn’t be used to perform backend calls nor decide when to optimistically update. I usually tackle optimistic updates <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">this way</a>.</p>

<p>That being said, I wouldn’t call my approach a best practice, but it is a best practice to really think about which way we want it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We learned a lot! Once again, the best practices explained in this article are based on personal experiences and projects we have worked on. These are practices that work for us. They are not meant to be seen as the only way of doing things.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>A very warm and much appreciated special thanks to the following people:</p>

<p><a href="https://twitter.com/ncjamieson">Nicholas Jamieson</a>, <a href="https://twitter.com/elecash">Raúl Jiménez</a> and <a href="https://twitter.com/FabianGosebrink">Fabian Gosebrink</a>: Thank you all so much for reviewing and pointing out some awesome ideas</p>

<p>Your input makes blogging worth while!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Do we really need Redux or @ngrx/store</title>
	  <link>//do-we-really-need-redux/</link>
	  <author></author>
	  <pubDate>2018-04-13T00:00:00+00:00</pubDate>
	  <guid>//do-we-really-need-redux/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>If you are writing Angular, Vue or React applications, chances are big that you have used or encountered the Redux pattern.
Redux helps us to structure statemanagement in an immutable matter which is great, but in order to use it correctly, we have to write a bunch of boilerplate code.
In this article I would like to tackle the question on when to use Redux and why.
The referred plugins/code samples are written in an Angular context. But the principles explained in this articles work for other frameworks as well. This also means that we are using the <a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">@ngrx/store</a> package instead of the <a href="https://redux.js.org/">Redux</a> package</p>

<h2 id="to-redux-or-not-to-redux">To Redux or not to Redux?</h2>

<p>First of all it’s important to note that Redux solves certain problems for us. If we are not experiencing those problems, then there is a big chance that the Redux pattern
is overkill for our application.</p>

<p>The first question that we might want to ask ourselves is:
<strong>Does My application have state?</strong> State can be the value of a pager that we want to remember, or the fact that a sidebar is collapsed or not. State could be a cached set of data coming from our backend, or user information that we need throughout the whole application.
It could be a simple value that we want to remember in memory when we are navigating between pages.</p>

<p>Let’s sum up some examples where the Redux principle might shine in our applications:</p>
<ul>
  <li>Storing state (like the value of a search filter so it’s still available when the user navigates back to a certain grid)</li>
  <li>Sharing state between components that have their own route, and thus won’t have a parent component to pass them the state through inputs or properties</li>
  <li>Optimistic updates: Check <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">this article</a></li>
  <li>Real-time updates: Check <a href="https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/">this article</a></li>
  <li>When we want undo/redo logic</li>
  <li>When we want to keep track of all the state changes and debug them with awesome tooling (Redux devtools)</li>
  <li>When we want an organised way of handling session storage or localstorage. Check <a href="https://github.com/btroncone/ngrx-store-localstorage">this plugin</a></li>
</ul>

<p>When we are writing Angular applications it’s a best-practice to work with immutable data structures. That way we can make use of the <a href="https://angular-2-training-book.rangle.io/handout/change-detection/change_detection_strategy_onpush.html">OnPush changedetectionstrategy</a> that angular provides us, which results in better performance and less unexpected behavior. In React we could use a <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">Pure component</a> for that. So, for this article let’s assume that immutable datastructures are the way to go and that our application needs it.</p>

<p>While we know that Redux forces you to use immutable datastructures, let’s still challenge the need of Redux shall we?
If statemanagement is trivial to our applications and we just want to store values we could work with a state service instead of Redux.</p>

<pre><code class="language-typescript">@Injectable()
export class UsersService {
    private _users$ = new BehaviorSubject([]);

    get users$(): Observable&lt;User[]&gt; {
        return this._users$.asObservable();
    }

    // IMPORTANT: since we use an immutable dataflow
    // we have to make sure users is a new instance
    setUsers(users: User[]): void {
        this._users$.next(...users);
    }
}

</code></pre>

<p>This example shows how we can set the simple value of an array of users by calling the <code>setUsers()</code>function. It will store the value into a BehaviorSubject which we will consume as an observable. The spread operator (<code>...</code>) will create a new instance of the <code>users</code> array. That way we know that we are working in an immutable manner. This was pretty easy and we don’t need Redux anymore, nor all the boilerplate that we would had to write. So if the state of our application only contains a few simple properties, the Redux pattern might be overkill.</p>

<p>But what if we need to do more then just set the value of <code>users</code>. What if we want to add and remove users from that stream, and we would have to do it in an immutable manner? Checkout the following example for instance.</p>

<pre><code class="language-typescript">@Injectable()
export class UsersService {
    private _users$ = new BehaviorSubject([]);

    get users$(): Observable&lt;User[]&gt; {
        return this._users$.asObservable();
    }

    setUsers(users: User[]): void {
        this._users$.next(...users);
    }

    addUser(user: User): void {
        // We cannot use array.push because we only want to
        // pass immutable data to the streame
        // for the OnPush strategy remmber?
        this._users$.next([...this._users$.getValue(), user])
    }

    removeUser(id: string) {
        // Again, we have to create a new Array instance to not break the
        // immutable dataflow
        this._users$.next(this._users$.getValue().filter(v =&gt; v.id !== id));
    }
}

</code></pre>
<p>The code above is starting to feel a bit weird, and it seems like we are writing reducer logic inside of this state service to keep it immutable. We have also created our own observable implementation so we could subscribe to the changes of our state service. While it could still be overkill to use redux if this is the only state in our application, it might become complex if we are working with multiple states, nested states, etc.</p>

<p>Another example is caching. People use redux to cache data results. A simple <code>shareReplay</code> operator might to the trick as well.</p>

<pre><code class="language-typescript">fetchUsers(): Observable&lt;User[]&gt; {
    ...
    return this.httpClient.get('').pipe(shareReplay(1));
}
</code></pre>

<h2 id="summary">Summary</h2>

<p>I would suggest to not use Redux untill we actually need it, and in my experience most applications that I have written in the past did need redux at a certain point. That being said I also wrote a bunch of applications that didn’t need it at all (CRUD applications for instance.</p>

<p>It’s up to you if you want to use Redux or not, <strong>but keep your applications immutable at all times</strong>.
It will save you a lot of energy in debugging and it makes sure that you can optimise the change detection cycle in your applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Type safe actions in reducers</title>
	  <link>//type-safe-actions-in-reducers/</link>
	  <author></author>
	  <pubDate>2016-11-21T00:00:00+00:00</pubDate>
	  <guid>//type-safe-actions-in-reducers/</guid>
	  <description><![CDATA[
	     <p>I’ve been using TypeScript and Redux for a while now. One thing that’s been bothering me from day one is the lack of typing on actions, or so I thought. Until the following twitter conversation last week caught my eye.</p>

<p><img src="https://www.dropbox.com/s/28omnkkkn1o2rm1/Screenshot%202016-11-16%2016.45.43.png?raw=1" alt="twitter" /></p>

<p>It’s about an exhaustive switch statement in flowtype and the option to do the same in TypeScript. But the real interesting part for me was the link from Mike Ryan. He pointed out they used some kind of pattern in the ngrx example app. Having never checked it out before, I decided to do so, and I found this cool idea to use classes for your actions.</p>

<p>I loved it so much, I decided to blog about it :). All credits to Mike Ryan of course who came up with the idea.</p>

<h3 id="my-previous-situation">My previous situation</h3>
<p>This is what my old code looked like (see comments).</p>

<pre><code class="language-typescript">// Create string constants for the action types
const SET_ID: string = "SET_ID";
const REMOVE_ID: string = "REMOVE_ID";

// Create action creators for every action
function setId(id): Action {
	return { type: SET_ID, payload: { id } };
}

function removeId(): Action {
	return { type: REMOVE_ID };
}

function test(state: string = "", action: Action): string {
    // switch on the action type
	switch (action.type) {
		case SET_ID:
		     // have absolutely no type safety on the
		     // payload here since payload is
		     // defined as 'any'
		     return action.payload.id;
		case REMOVE_ID:
	         return "";
		default:
		     return state;
	}
}

</code></pre>
<p>While this is perfectly valid code, it doesn’t provide me with any code completion or type safety regarding the payload.
Just check out this <a href="http://bit.ly/2fVxE7C" target="_blank">TypeScript playground</a> example and try to change the <code>action.payload.id</code> into <code>action.payload.whatever</code>. You will see no compile errors.</p>

<p>Let’s see how this can be improved.</p>

<h3 id="use-classes-to-define-actions">Use classes to define actions</h3>
<p>In the following code snippet I used classes for actions instead of action creators. These classes extend from the Action interface. This means, every class will have the <code>type</code> property.
I also created a new <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" target="blank">Union type</a> called <code>Actions</code> which combines all the possible action classes.</p>

<p>Our switch statement works on the common denominator between all our actions, being the <code>type</code> property. This way the TypeScript compiler can
know that, if the type is for example <code>"SET_ID"</code>, the only possible class in that specific ‘case’ part of the switch statement is the <code>SetId</code> class. It can then use the type information in that class to determine what the payload looks like. Check the code below if this is unclear.</p>

<p>This is a concept called <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions" target="_blank">Discriminated Unions</a>.</p>

<pre><code class="language-typescript">// Instead of using action creators, classes are used.
class SetId implements Action {
	type: "SET_ID" = "SET_ID";
	// here we declare the type of the payload for the
	// SetId class to be an object with a property 'id'
	payload: { id: string };

	public constructor(id: string) {
		this.payload = { id };
	}
}

class RemoveId implements Action {
	type: "REMOVE_ID" = "REMOVE_ID";

	public constructor() { }
}

// Create a union type that contains all the possible actions.
type Actions = SetId | RemoveId;

function test(state: string = "", action: Actions): string {
    // The switch case statements use discriminated unions
	switch (action.type) {
		case "SET_ID":
		    // The compiler knows this can only be the
		    // class SetId so it can use the type
		    // information in that class
		    // to know the payload has an id property.
			return action.payload.id;
		case "REMOVE_ID":
			return "";
		default:
			return state;
	}
}

</code></pre>

<p>You can try this <a href="http://bit.ly/2fXYiPB" target="_blank">TypeScript playground example</a>. If you remove the id property in the switch statement, you’ll see that you have autocompletion</p>

<p><img src="https://www.dropbox.com/s/1s4zyh01xbp8g2a/Screenshot%202016-11-16%2020.31.03.png?raw=1" alt="autocomplete" /></p>

<p>and type safety!</p>

<p><img src="https://www.dropbox.com/s/6wtt9oupqr8290z/Screenshot%202016-11-16%2020.45.46.png?raw=1" alt="type safety" /></p>

<p>Just try to change the property <code>id</code> into <code>whatever</code>, you’ll get a compilation error. You can even click on the <code>id</code> property and directly be redirected to the <code>SetId</code> class.</p>

<p>Awesome right!</p>

<h3 id="the-finishing-touch">The finishing touch</h3>
<p>The way the type property in the classes were defined before, are a little strange.</p>

<pre><code class="language-typescript">type: "REMOVE_ID";
</code></pre>
<p>This is actually called a <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types" target="_blank">String literal type</a>.
There’s a better way to do this using a utility method that coerces a string you pass to it to a string literal type. It also remembers every action type you’ve passed to it to avoid duplicates in your app.</p>

<pre><code class="language-typescript">let typeCache: { [label: string]: boolean } = {};
export function type&lt;T&gt;(label: T | ''): T {
  // this actually checks whether your action type
  // name is unique!
  if (typeCache[&lt;string&gt;label]) {
    throw new Error(`Action type "${label}" is not unqiue"`);
  }

  typeCache[&lt;string&gt;label] = true;

  return &lt;T&gt;label;
}
</code></pre>

<p>Using this function, you can declare your action types like this:</p>

<pre><code class="language-typescript">export const ActionTypes = {
	SET_ID: type&lt;"SET_ID"&gt;("SET_ID"),
	REMOVE_ID: type&lt;"REMOVE_ID"&gt;("REMOVE_ID")
}
</code></pre>

<p>and use them everywhere like this:</p>

<pre><code class="language-typescript">type = ActionTypes.SET_ID;
// or
case ActionTypes.SET_ID:
</code></pre>

<p>Checkout the finished <a href="http://bit.ly/2m7nG7S" target="blank">TypeScript playground example</a>. It’s basically the same as the previous one, but cleaner.</p>

<h3 id="conclusion">Conclusion</h3>
<p>Using some of TypeScript 2’s powerful typing system, you can make the actions in your reducers type safe with little effort.</p>

<p><strong>Note:</strong> Thanks to <a href="https://twitter.com/PascalPrecht" target="_blank">Pascal Precht</a>, <a href="https://twitter.com/toddmotto" target="_blank">Todd Motto</a>, <a href="https://twitter.com/basarat" target="_blank">Basarat</a> and <a href="https://twitter.com/SamVerschueren" target="_blank">Sam Verschueren</a> for reviewing!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Cancellable optimistic updates in Angular 2 and Redux</title>
	  <link>//Cancellable-optimistic-updates-in-Angular2-and-Redux/</link>
	  <author></author>
	  <pubDate>2016-09-23T00:00:00+00:00</pubDate>
	  <guid>//Cancellable-optimistic-updates-in-Angular2-and-Redux/</guid>
	  <description><![CDATA[
	     <p><a href="https://angular.io/">Angular 2</a> and <a href="https://github.com/reactjs/redux">redux</a> are 2 technologies that are getting a lot of traction these days. Angular 2 is a SPA (single-page-app) framework and redux is a state management tool. Most developers that are using Angular 2 are using the <a href="https://github.com/ngrx/store">@ngrx/store</a> variant of the redux principle. Because I’m one of them I will be using @ngrx/store instead of redux.js for this article. Don’t let that bother you, what you are about to read can be used with redux.js in the exact same way. If you have never heard about redux, I strongly advice to read the <a href="http://redux.js.org/">documentation</a> first.</p>

<h2 id="optimistic-updates">Optimistic updates</h2>

<p>Redux has a client-side store that has all the data and state your client-side application needs. Therefore, it is the single source of truth for your frontend. When something in that store changes, your components get updated automatically. Let’s say that we are implementing a winecellar application which will obviously contain an array of wines.</p>

<p><strong>Scenario: we want to remove a wine from the winecellar.</strong></p>

<p>A user goes to the index page of our application, clicks a delete button in the datagrid which will call an angular service to remove a wine. The service does an HTTP call to a server, and when the wine finally gets deleted, the service responds with a 200 response (ok). When that happens we can update the redux store and our view gets updated.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario1.png" alt="Scenario 1" /></p>

<p>The code explained above might look like this:</p>

<pre><code class="language-typescript">remove(wine: Wine): void {
    this.http.delete(`${API_URL}/wines/${wine._id}`).subscribe(() =&gt; {
    	// dispatch the action to the store, when the call was successful
    	this.store.dispatch({type: REMOVE_WINE, payload: {_id: wine._id}});
    });
}
</code></pre>

<p>This is the traditional way of doing things, but I think we can do it better. What if we would update the store, regardless of the HTTP response the server returns? We click the delete button in the datagrid, call the angular service like we already did. But in that service we update the store directly (parallel with the http call)</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario2.png" alt="Scenario 2" /></p>

<p>The code explained above might look like this:</p>

<pre><code class="language-typescript">remove(wine: Wine): void {
	// dispatch directly to the store
	this.store.dispatch({type: REMOVE_WINE, payload: {_id: wine._id}};
	// we still have to subscribe because http calls return cold observables
    this.http.delete(`${API_URL}/wines/${wine._id}`).subscribe();
}
</code></pre>

<p>This is a pretty nice change: Our application has just gotten a lot <strong>faster and snappier</strong>. Every time the user does an action, the store gets updated immediately, which means that the components will get updated immediately as well. We never have to wait for http responses again.</p>

<p>There is one exception to this rule: When <strong>adding</strong> data, the backend has to return an ID which means that for POST calls we will have to postpone the store update until we get a 200 response. (otherwise we would have id-less wines in our store, and we can’t have that)</p>

<h2 id="what-if-the-server-call-fails">What if the server-call fails?</h2>

<p>What if the user’s internet-connection is lost? Or the backend doesn’t return a 200 response but an error. Our store will already be updated, the wine will be lost when it’s in fact still in the database. In some scenarios you want to prevent that kind of behavior. In those cases we want to rollback that specific action, but not interfere with the rest of the actions. It has to be completely safe.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario3.png" alt="Scenario 3" /></p>

<p>We would like to implement something like this:</p>

<pre><code class="language-typescript">remove(wine: Wine): void {
	// create an action
	let action = {type: REMOVE_WINE, payload: {_id: wine._id}};
	//dispatch the action to the store
	this.store.dispatch(action);
	// call the backend
    this.http.delete(`${API_URL}/wines/${wine._id}`)
    	.subscribe(
    		// on success, do nothing
    		() =&gt; {}, 
	    	// on error, rollback the action
	    	() =&gt; {
	    		this.store.dispatch({type: "UNDO_ACTION", payload: action});
	    	// maybe show somekind of errormessage to show the user that it's action failed
    	});
}
</code></pre>

<p>It turns out that when using the redux pattern, this only takes 12 lines of code (without comments :-)). We will have to create a parent reducer that will delegate to our root reducer. The parent reducer will keep track of all the actions, so they can be rolled back.
The implementation looks like this:</p>

<pre><code class="language-typescript">import {ApplicationState} from "../statemanagement/state/ApplicationState";
import {Action, ActionReducer} from "@ngrx/store";

export function handleUndo(rootReducer: ActionReducer&lt;ApplicationState&gt;)
	: ActionReducer&lt;ApplicationState&gt; {
	// keep the executedActions
    let executedActions: Array&lt;Action&gt; = [];
    return (state: ApplicationState, action: Action) =&gt; {
        if (action.type === "UNDO_ACTION") {
        	// if the action is UNDO_ACTION, 
        	// then call all the actions again on the rootReducer, 
        	// except the one we want to rollback
            let newState: any = {};
            executedActions = executedActions.filter(eAct =&gt; eAct !== action.payload);
            // update the state for every action untill we get the
            // exact same state as before, but without the action we want to rollback
            executedActions.forEach(executedAction =&gt; 
            	newState = rootReducer(newState, executedAction));
            return newState;
        }
        // push every action that isn't an UNDO_ACTION to the executedActions property
        executedActions.push(action);
        // just delegate
        return rootReducer(state, action);
    };
}
</code></pre>

<p>So basically, when an action is being rolled back, every action that has been taken before is being executed on a piece of state again. When that piece of state is updated, it will return it and the store will be updated with the same state, except the one that our rolled back action created.</p>

<p>To make sure the actions can be undone, we have to make redux use the piece of code above. This is how you could use it in Angular 2.</p>

<pre><code class="language-typescript">@NgModule({
	// instead of passing the rootReducer directly
	// like we would have done before, wrap it in the handleUndo function
    imports: [StoreModule.provideStore(handleUndo(rootReducer))/*, ...*/],
    /* ... */
})
export class AppModule {
}
</code></pre>

<h2 id="possible-improvements">Possible improvements</h2>

<p>Won’t it become slow after a while, replaying all these actions?
Some facts:</p>
<ul>
<li>Actions are very cheap</li>
<li>They will update the store only once, we execute the actions ourselves, so ui won't get updated</li>
<li>Actions only get replayed when there is an error</li>
<li>The devtools also work like that, enables [timetraveling](https://onsen.io/blog/react-redux-devtools-with-time-travel)</li>
</ul>
<p>What if it would become slow?
We can implement a buffer. Let’s say that we only want the last 100 actions to be kept.</p>

<pre><code class="language-typescript">export function handleUndo(rootReducer: ActionReducer&lt;ApplicationState&gt;, 
	bufferSize = 100): ActionReducer&lt;ApplicationState&gt; {
    let executedActions: Array&lt;Action&gt; = [];
    let initialState = undefined;
    return (state: ApplicationState, action: Action) =&gt; {
        if (action.type === "UNDO_ACTION") {
        	// if the action is UNDO_ACTION, 
        	// then call all the actions again on the rootReducer, 
        	// except the one we want to rollback
            let newState: any = initialState;
            executedActions = executedActions.filter(eAct =&gt; eAct !== action.payload);
            // update the state for every action untill we get the
            // exact same state as before, but without the action we want to rollback
            executedActions.forEach(executedAction =&gt; 
            	newState = rootReducer(newState, executedAction));
            return newState;
        }
       	// push every action that isn't an UNDO_ACTION to the executedActions property
		executedActions.push(action);
        let updatedState =  rootReducer(state, action);
        if (executedActions.length === bufferSize + 1) {
            let firstAction = executedActions[0];
            // calculate the state x (buffersize) actions ago
            initialState = rootReducer(initialState, firstAction);
            // keep the correct actions
            executedActions = executedActions.slice(1, bufferSize + 1);
        }
        return updatedState;
    };
}
</code></pre>

<h3 id="conclusion">Conclusion</h3>
<p>The redux pattern has opened amazing doors for frontend development. Just like <a href="http://blog.brecht.io/How-we-made-our-app-real-time-in-6-lines-of-code/">realtime</a> became a breeze we can do optimistic updates with almost no effort.
The reason why you would do optimistic updates is that your application becomes amazingly fast and snappy! When implementing optimistic updates, the user will experience a native, mobile feeling.</p>

<p>Here you can find the npm package I’ve created for angular, called <a href="https://www.npmjs.com/package/ngrx-undo">ngrx-undo</a></p>

<p>Let me know if you enjoyed this article!</p>

	  ]]></description>
	</item>

	<item>
	  <title>combineReducers enhanced</title>
	  <link>//combinereducers-enhanced/</link>
	  <author></author>
	  <pubDate>2016-09-15T00:00:00+00:00</pubDate>
	  <guid>//combinereducers-enhanced/</guid>
	  <description><![CDATA[
	     <p>When working with redux or ngrx/store, you get a lovely utillity method called <code>combineReducers</code> that solves a pretty annoying problem for you. This method could however be further improved and we’ll see why in a bit.</p>

<p><strong>Note: some knowledge of the redux architecture is required to continue with this blogpost. Checkout <a href="http://redux.js.org/" target="_blank">this</a> for more info on Redux.</strong></p>

<p><strong>Note: Since the PR still isn’t merged in the @ngrx/store library, I created a separate npm module with the functionality described below. You can find the github repo <a href="https://github.com/KwintenP/combine-reducers-enhanced" target="_blank">here</a>.</strong></p>

<p><strong>TL;DR Go to the <a href="#conclusion">conclusion</a></strong></p>

<h3 id="current-situation">Current situation</h3>
<p>Take a look at the following state design.</p>

<pre><code class="language-typescript">{
	"ui": {
		"topBarCollapsed": true,
		"sideBarCollapsed": true
	},
	"data": {
		"tweets": [],
		"users": []
	}
}
</code></pre>

<p>Let’s try to translate this into reducers.</p>

<h5 id="without-combinereducers">Without combineReducers</h5>

<p>Remember, when your store is being initialised, you can only pass it a single reducer. To avoid a single reducer with all the logic, we are going to use the concept of reducer composition. Your reducer tree could look like this:</p>

<p><img src="https://www.dropbox.com/s/gglg3j3ama5affo/Screenshot%202016-09-14%2016.35.12.png?raw=1" /></p>

<p>You can then create your store like this:</p>

<pre><code class="language-typescript">// pseudo code
new Store(rootReducer);
</code></pre>

<p>The function of the rootReducer is:</p>

<ul>
  <li>Delegate the actions towards the dataReducer and the uiReducer with the correct state slice.</li>
  <li>Assure that the reference of the data does not change if changes are made to the ui property and vice versa.</li>
</ul>

<p>The ‘rootReducer’ doesn’t do that much and it’s a PITA to have to write this every time. Every time a new action is added, you need to add it to the rootReducer as well.
Enter <code>combineReducers</code>!</p>

<h5 id="with-combinereducers">With combineReducers</h5>
<p><code>combineReducers</code> removes the need to write this reducer yourself. When creating your store, you can pass it, not only a reducer function, but also an object like this:</p>

<pre><code class="language-typescript">const rootReducer = {
	ui: uiReducer,
	data: dataReducer
}

new Store(rootReducer);
</code></pre>

<p>The store will see this is not a function, and thus not a ‘rootReducer’. Internally it will  pass this object to the <code>combineReducers</code> method. This will generate a ‘meta-reducer’ for you that does exactly the same as the ‘rootReducer’ we’ve described before.
Conceptually speaking it looks like this:</p>

<p><img src="https://www.dropbox.com/s/i1mh7frvr8tddg0/Screenshot%202016-09-15%2007.42.26.png?raw=1" /></p>

<p>The advantage is that you do not need to write the ‘rootReducer’ yourself.
Pretty neat right!</p>

<h3 id="problem-description">Problem description</h3>
<p>Let’s say, you have a state tree that looks more like this.</p>

<pre><code class="language-typescript">{
	"ui": {
		"mainPage": {
				"topBarCollapsed": true
		},
		"loginPage": {
			"sideBarCollapsed": true
		}
	},
	"data": {
		"tweets": [],
		"users": []
	}
}
</code></pre>

<p>As you can see, we have a second nested level for our ui property and maybe we want to split the data into two different reducers, a tweets- and usersReducer.
Let’s take a look at how we can implement this.</p>

<h3 id="current-possible-solutions">Current possible solutions</h3>
<p>The <code>combineReducers</code> method only allows a single level of nesting, so we’ll have to see how we can fix this.</p>

<h5 id="create-the-intermediary-reducers-yourself">Create the intermediary reducers yourself</h5>
<p>You can always decide to just implement the intermediate reducers yourself.</p>

<p><img src="https://www.dropbox.com/s/e2gjsrcp03cxzq9/Screenshot%202016-09-15%2020.11.55.png?raw=1" /></p>

<p>However, writing these reducers yourself is the same PITA as it was for the first level so it’s not the preferred solution</p>

<h5 id="use-a-third-party-library-which-handles-this-for-you">Use a third-party library which handles this for you</h5>
<p>There is a third-party library created by Brecht Billiet that does exactly this. Check it out <a href="https://github.com/brechtbilliet/create-reducer-tree">here</a>.
You can pass it an object and it will create all the intermediate reducers for you. This is an awesome solution, but unfortunately, it requires us to depend an yet another third-party library.</p>

<h5 id="nest-the-combinereducers-method-yourself">Nest the combineReducers method yourself</h5>

<p>Since we have the <code>combineReducers</code> method, we might as well leverage it fully and use it for every intermediary reducer. You can do this by passing an object like this to your store at creation time.</p>

<pre><code class="language-typescript">const rootReducer = {
	"ui": combineReducers({
		"mainPage": mainPageReducer
		"loginPage": loginReducer
	}),
	"data": combineReducers({
		"tweets": tweetsReducer
		"users": usersReducer
	})
}
</code></pre>

<p>It will generate all the intermediary reducers for you but the ‘rootReducer’ definition doesn’t look clean. For people just starting with Redux, this will probably look a little confusing as well.</p>

<p>It turns out, the <code>combineReducers</code> method can be changed to fix this pretty easily.
<a name="conclusion"></a></p>

<h3 id="proposed-solution">Proposed solution</h3>
<p>I’ve created a <a href="https://github.com/ngrx/store/pull/214" target="_blank">PR</a> towards the ngrx/store library where I extended the <code>combineReducers</code> method to work with nested objects as well. This allows you to create an object like this:</p>

<pre><code class="language-typescript">const rootReducer = {
	"ui": {
		"mainPage": mainPageReducer
		"loginPage": loginReducer
	},
	"data": {
		"tweets": tweetsReducer
		"users": usersReducer
	}
}

new Store(rootReducer);
</code></pre>

<p>which will create this:</p>

<p><img src="https://www.dropbox.com/s/lpd3io77pqemecp/Screenshot%202016-09-15%2007.42.41.png?raw=1" /></p>

<p>It’s actually a change of only two LOC and semantically does exactly the same as nesting the <code>combineReducers</code> method yourself or the third-party library, but it’s a lot cleaner to implement and use.
If you feel this feature might help you in the future, be sure to ‘like’ the PR it so it could be added to the library asap.</p>

<p><strong>Note: As soon as the PR is being approved for the NGRX/Store library, I’ll submit a similar one to Redux.js</strong></p>


	  ]]></description>
	</item>

	<item>
	  <title>How to write clean reducers (and test them!)</title>
	  <link>//how-to-write-clean-reducers-and-test-them/</link>
	  <author></author>
	  <pubDate>2016-08-22T00:00:00+00:00</pubDate>
	  <guid>//how-to-write-clean-reducers-and-test-them/</guid>
	  <description><![CDATA[
	     <p>Last week, someone asked me how I kept my reducers clean and how to properly test them. Since it wasn’t the first time someone asked me that, I decided to write it down for future reference.
Here it is!</p>

<p><strong>NOTE: Reducers are a part of the Redux architecture. If you do not know what I’m talking about, checkout <a href="http://redux.js.org/" target="_blank">this</a>.</strong></p>

<h3 id="reducers-basic-building-blocks">Reducers basic building blocks</h3>
<p>To me, a clean reducer has a number of different building blocks. Let’s take a look at the following example. It’s a very simple tweetsReducer that manages an array of tweets.</p>

<pre><code class="language-typescript">function tweetsReducer(
        state: State = [],
        action: Action): State {
    let tweet: Tweet;
    switch (action.type) {
        case "ADD_TWEET":
            ({tweet} = action.payload);
            return [...state, tweet];
        default:
            return state;
    }
}
</code></pre>

<p><strong>NOTE: all examples are written using typescript</strong></p>

<h4 id="default-values">Default values</h4>

<p>First thing we’re going to focus on, is the default value for the input parameter.</p>

<pre><code class="language-typescript">state: State = [];
</code></pre>

<p>To understand why defining a default parameter is important, you need to know about the lifecycle of Redux. Every Redux implementation has a method called <code>createStore</code> or something similar. This method creates the store.</p>

<p><img src="https://cdn.meme.am/instances/500x/62970260.jpg" /></p>

<p>What this method also does is dispatch an action to that newly created store. If you’ve used Redux before, then you know that the Store holds a single State object. At startup, this object doesn’t exist yet and in order to create it, every Redux implementation will dispatch an <code>INIT</code>-like action to get all the default values from the reducers and build the state tree.</p>

<p>Next is a simplified, conceptual snippet that shows what a <code>createStore</code> method could look like.</p>

<pre><code class="language-typescript">function createStore(reducer: Reducer): Store {
    // Create the new store and pass the reducer
	const store: Store = new Store(reducer)

	// dispatch an init action to the store
	store.dispatch({type: "REDUX_INIT"});

	return store;
}
</code></pre>

<p>The dispatching of the <code>INIT</code>-action will result in the reducer, for example the tweetsReducer, being called with the following parameters.</p>

<pre><code class="language-typescript">tweetsReducer(undefined, initActionDispatchedToTheStore: Action);
</code></pre>

<p>The first parameter should be the state, but since the State object is not yet created, it will be undefined. This results in the use of the default value of the state parameter, which in our tweetsReducer is an empty array. The initial value won’t always be that easy, this can also be a complex object.</p>

<p>What’s important to remember is to define default states to assure we get a nice, clean state object at startup.</p>

<p><strong>NOTE: Be sure to never define an action with the same name of your Redux implementation’s <code>INIT</code>-action. You can easily check this in the source code.</strong></p>

<p><strong>NOTE: Often, you can pass an initial state object to the <code>createStore</code> method as a second parameter. This doesn’t mean that you shouldn’t add the default values to ALL your reducers</strong></p>

<h4 id="default-case">Default case</h4>
<p>The second part I want to focus on is the default case of the switch statement. This simply returns the state object it was given.</p>

<pre><code class="language-typescript">default:
     return state;
</code></pre>

<p>In most cases, you will have multiple reducers in your application. These will be organised in a tree, matching your state object. Actions dispatched to the store will be delegated to the top reducers which will cascade, if necessary, the actions to the bottom reducers. The result of all these calls will form the new state object.
If you forget to add the default case to your reducers, part of your state tree will dissapear. Take a look at the following example and imagine we’ve forgotten to implement the default case in our tweetsReducer.</p>

<pre><code class="language-typescript">// Current state tree where we manage an array of users
// and an array of tweets
let currentState: State = {
	"tweets": [
                 {
                    id: 1,
                    username:"@KwintenP",
                    content:"blogpost on clean reducers!"
                 }
	],
	"users": []
}

// we dispatch an action to add a user
store.dispatch({type: "ADD_USER", payload: {id: 1, name: "Kwinten"});
</code></pre>

<p>The store will send the action, not only to the usersReducers (left out for brevity), but also to our tweetsReducer.
When the action enters our tweetsReducer, none of the cases defined would match and since we have no default case, the reducer would return undefined. This would result in the following state object.</p>

<pre><code class="language-typescript">{ "tweets": undefined, "users": [{id: 1, name: "Kwinten"}]};
</code></pre>

<p>As you can see, the tweets that were previously there, are gone. So, remember to always implement the default case to avoid that parts of your state tree disappear.</p>

<h4 id="es6-syntax-sugar">ES6 syntax sugar</h4>
<p>A little bit of ES6 syntax sugar I like to use in my reducers is the following:</p>

<pre><code class="language-typescript">//example payload
action.payload = {tweet: new Tweet(....)};

// we map the single value to the tweet property
let tweet: Tweet;
({tweet} = action.payload);
// Non ES6 equivalent
tweet = action.payload.tweet;

// example payload
action.payload = {tweet: new Tweet(...), id: 1};

// We map multiple values to the properties
let tweet: Tweet;
let id: string;
({tweet, id} = action.payload);
// non ES6 equivalent
tweet = action.payload.tweet;
id = action.payload.id;
</code></pre>

<p>I always use this ES6 shorthand in my reducers. In my tweetsReducer (see snippet at the beginning), I define a few variables above my switch statement. I then use these inside my case statements to map the payload to. The reason I do this is to make the reducer more readable. If I now wish to add a tweet to my store, I just look at the top of my case statement and I can immediately see what parameters I need to add to the payload.</p>

<pre><code class="language-typescript">case "ADD_TWEET":
        ({tweet} = action.payload); // my payload needs a tweet object
        return [...state, action.payload.tweet];
</code></pre>

<p>In this particular example this might not seem that handy, but once your reducers become (a lot) bigger, you’ll be happy if you’ve done this.</p>

<p><strong>NOTE: If you’re using action creators (out of scope for this post), and you should, the problem that it’s not clear what parameters you should pass, becomes less applicable. But, I would strongly recommend to keep doing this for when you’re writing the action creators themselves and for your unit tests.</strong></p>

<h4 id="use-reducer-composition">Use reducer composition</h4>
<p>As soon as your application grows, your reducers will become more complex. To avoid having a single reducer that manages the entire state tree, you could use the concept of reducer composition.
Take a look at the next reducer (I removed the implementations of the case statements for brevity):</p>

<pre><code class="language-typescript">export function tweetsReducer(state:Array&lt;Tweet&gt; = [], action:Action):Array&lt;Tweet&gt; {
    let id:number, tweet:Tweet, tweets: Array&lt;Tweet&gt;;
    switch (action.type) {
        // first block
        case ADD_TWEET: // implementation
        case REMOVE_TWEET: // implementation
        case SET_TWEETS: // implementation
        case UPDATE_TWEET: // implementation

        // second block
        case TWEET_UN_LIKED: // implementation
        case TWEET_LIKED: // implementation
        case TWEET_UN_RETWEETED: // implementation
        case TWEET_RETWEETED: // implementation
        case TOGGLE_STAR_TWEET: // implementation
        default:
            return state;
    }
}
</code></pre>

<p>If we were to implement every case in the same reducer, this would already become quite big. If we look closely, we can see that the cases can be divided into two categories. The first block, handle the tweets collection. The second block handles an individual tweet.</p>
<h6 id="enter-reducer-composition">Enter reducer composition!</h6>
<p>This is an ideal example to demonstrate when you can use reducer composition. We can make the tweetsReducer handle the collection, and make a new tweetReducer, which handles a single tweet. This would look like this:</p>

<pre><code class="language-typescript">export function tweetsReducer(state:Array&lt;Tweet&gt; = [], action:Action):Array&lt;Tweet&gt; {
    let id:number, tweet:Tweet, tweets: Array&lt;Tweet&gt;;
    switch (action.type) {
        // collection block
        case ADD_TWEET: // implementation
        case REMOVE_TWEET: // implementation
        case SET_TWEETS: // implementation
        case UPDATE_TWEET: // implementation

        // single tweet block
        case TWEET_UN_LIKED:
        case TWEET_LIKED:
        case TWEET_UN_RETWEETED:
        case TWEET_RETWEETED:
        case TOGGLE_STAR_TWEET:
        // For the cases above, we delegate to the
        // tweetReducer. Here we loop the current
        // collection of tweets and if it's the one
        // we wish to update, we replace it with the
        // result of the tweetReducer.
            ({id} = action.payload);
            return state.map(tweet =&gt; tweet.id == id?
                   tweetReducer(tweet, {type: action.type, payload: {tweet}}):
                   tweet);
        default:
            return state;
    }
}

export function tweetReducer(state: Tweet = {}, action: Action) {
    let tweet: Tweet;
    switch (action.type) {
        case TOGGLE_STAR_TWEET: // implementation
        case TWEET_RETWEETED: // implementation
        case TWEET_UN_RETWEETED: // implementation
        case TWEET_LIKED: // implementation
        case TWEET_UN_LIKED: // implementation
        default: return state;
}

</code></pre>

<p>Working with reducer composition makes your individual reducers less complex to manage.</p>

<h4 id="other-tips">Other tips</h4>

<ol>
  <li>You MUST keep your reducers immutable! You can use the new <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank">‘Object.assign’</a> and the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank">spread operator</a> from ES6 or libraries as <a href="https://facebook.github.io/immutable-js/" target="_blank">Immutable.js</a> or <a href="https://github.com/rtfeldman/seamless-immutable" target="_blank">seamless-immutable</a> to do this.</li>
  <li>When you’re using reducer composition, combine your delegating cases at the bottom of your reducer. In the example of reducer composition, all the calls to the tweetReducer are combined at the bottom. This is merely a convention that I’ve found useful in the past.</li>
</ol>

<h4 id="how-to-test-them">How to test them</h4>
<p>Testing reducers is quite easy and straightforward. You send a state object and an action to the reducer en check your result. But, you cannot forget to test the immutability of your reducers. To ensure this, you can use a library called deepFreeze. Check out this next example.</p>

<pre><code class="language-typescript">describe("reducer: tweetsReducer", () =&gt; {
    describe("on ADD_TWEET", () =&gt; {
        it("should add a tweet to the
           current list of tweets", () =&gt; {
            // create the initial state object
            let tweet: Tweet = new Tweet(...);
            let initialState: Array&lt;Tweet&gt; = [tweet];

            // perform a deepFreeze on the initial state object
            deepFreeze(initialState);

            // create the payload
            let tweetToAdd: Tweet = new Tweet(...);
            let payload: any = {tweet: tweetToAdd};

            // Sent the action to the tweetsReducer
            let changedState: Array&lt;Tweet&gt; = tweetsReducer(initialState,
                {
                    type: ADD_TWEET,
                    payload
                });

            // Verify the changes are correct
            expect(changedState.length).toBe(2);
            expect(changedState[1]).toBe(payload.tweet);
        });
    });
});
</code></pre>

<p>As you can see, testing reducers consists of four steps:</p>
<ol>
  <li>Create an <code>initialState</code> object.</li>
  <li>Perform a deepFreeze on the <code>initialState</code> object. This library will perform a recursive <code>Object.freeze()</code> on the entire state object protecting it from mutation. This is an easily overlooked but extremely important step in the testing of your reducers!</li>
  <li>Call the reducer with the initial state and the correct action.</li>
  <li>Verify the result of your reducer.</li>
</ol>

<p>At least one test should be added for every case in your reducer’s switch statement. Besides those, you should also add a test for an unknown action to verify you’ve implemented the default case. And one more test for the <code>INIT</code>-action to make sure you’ve defined a default value for your state. In this particular test you pass undefined as your state value.</p>

<h4 id="summary">Summary</h4>
<ul>
  <li>Use <strong>default values</strong> for your state object in your reducer</li>
  <li>Implement the <strong>default case</strong> to just return the state</li>
  <li>Use ES6 syntax sugar to make your reducers look more clean</li>
  <li>Use <strong>reducer composition</strong> when necessary</li>
  <li>Reducers MUST be <strong>immutable</strong></li>
  <li>Use <strong>deepFreeze</strong> while testing to <strong>ensure immutability</strong></li>
  <li>Combine your delegating cases at the bottom of your reducer</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
