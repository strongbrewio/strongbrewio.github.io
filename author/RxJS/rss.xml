<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link>https://blog.strongbrew.io/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>RxJS patterns - Prematurely ending work</title>
	  <link>//rxjs-patterns-prematurely-ending-work/</link>
	  <author></author>
	  <pubDate>2019-01-30T00:00:00+00:00</pubDate>
	  <guid>//rxjs-patterns-prematurely-ending-work/</guid>
	  <description><![CDATA[
	     <p>This post is part of a series of blogpost on different RxJS patterns that I use quite often. Here are the previous ones:</p>

<ul>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-restarting-work/" target="_blank">Restarting work</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-mapping-function-calls-to-streams/" target="_blank">Mapping function calls to streams</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-conditionally-executing-work/" target="_blank">conditionally executing work</a></li>
</ul>

<p>The next pattern I want to discuss when we you want to prematurely end work. There are many scenarios when you would want to do this. We can start some work (aka an <code>Observable</code>) and want to kill that subscription if our  user navigates to a different page, the user changes something which should trigger a different call, â€¦</p>

<h2 id="how-can-we-do-it">How can we do it</h2>

<p>One thing I really like about RxJS is how declarative it is. You can quite often translate what you want into a sentence and translate that sentence into code.</p>

<p>Letâ€™s say that we want to listen to a certain stream, until a certain event happens. An extremely common scenario is when you are working with a UI framework that works with components. Often you want to: â€˜Listen to this specific <code>Observable</code> until the component gets destroyedâ€™.</p>

<p>Translated into code, we could have something like this:</p>

<pre><code class="language-typescript">workWeWantToDo$.pipe(
	listenTillThisEventHappens(componentDestroyed)
).subscribe();
</code></pre>
<p><strong>Note:</strong> <code>listenTillThisEventHappens</code> is not an operator :).</p>

<p>The <code>listenTillThisEventHappens</code> can be replaced by the <code>takeUntil</code> operator which does exactly this. And we can create a stream from a lifecycle hook that gets called via our UI framework. Checkout the other pattern â€˜mapping function calls to streamsâ€™ to see how you can accomplish this.</p>

<p>The resulting code is:</p>

<pre><code class="language-typescript">workWeWantToDo$.pipe(
	takeUntil(componentDestroy$)
).subscribe();
</code></pre>

<p>When creating this <code>Observable</code> we use the <code>takeUntil</code> operator. This operator will subscribe to the stream above (if it was subscribed to itself of course) and will proxy these values until the <code>componentDestroy$</code> emits. Then the <code>takeUntil</code> will kill the subscription.</p>

<h2 id="when-to-use-this">When to use this</h2>

<p>Everytime you are thinking: â€˜I want to stop this when that happensâ€™.</p>

<ul>
  <li>To kill subscriptions when a component is destroyed</li>
  <li>When trying to know when a user stopped dragging. You can have a stream that listens for â€˜dragDownâ€™ and take values until a â€˜dragUpâ€™ events happens.</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>RxJS patterns - Conditionally executing work</title>
	  <link>//rxjs-patterns-conditionally-executing-work/</link>
	  <author></author>
	  <pubDate>2019-01-29T00:00:00+00:00</pubDate>
	  <guid>//rxjs-patterns-conditionally-executing-work/</guid>
	  <description><![CDATA[
	     <p>This post is part of a series of blogpost on different RxJS patterns that I use quite often. Here are the other ones:</p>

<ul>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-restarting-work/" target="_blank">Restarting work</a></li>
  <li><a href="https://blog.strongbrew.io/xjs-patterns-mapping-function-calls-to-streams/" target="_blank">mapping a function to a stream</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-prematurely-ending-work/" target="_blank">prematurely ending work</a></li>
</ul>

<p>The next pattern I want to discuss is executing conditional work. Sometimes, you have a stream and if some condition is met, you want to do some extra step.</p>

<p>But, we do not have an <code>if-else</code> operator. And that makes sense. If we had such an operator, the entire <code>Observable</code> chain would be broken. Luckily there are a few ways to introduce conditional work inside of our <code>Observable</code> chains.</p>

<h2 id="executing-conditional-work">Executing conditional work</h2>

<p>Letâ€™s imagine that we have list of items in a webshop. In that list, we can check one or more items that we want to buy. When the user clicks on the â€˜buyâ€™ button, we first want to check if one of the items delays the delivery date by a huge amount. If so, we want to show a popup to notify the user. He can either decline and change his order or accept this.</p>

<p>In this use case, we have two <code>if-else</code>s.</p>
<ul>
  <li>If there is an order which has an item that pushes the delivery date we need to show a popup. Otherwise we donâ€™t.</li>
  <li>If the popup is shown, and the user accepts, we do a backend call to actually register the order. Otherwise we donâ€™t and the popup should close so the user can maybe remove that specific item.</li>
</ul>

<p>Letâ€™s first take a look at what the code could look like.</p>

<pre><code class="language-typescript">selectedItems$.pipe(
	'ifElse'(() =&gt; {
		// 
	}),
	switchMap(selectedItems =&gt; this.service.buy(selectedItems))
).subscribe(_ =&gt; // route to a different page here);
</code></pre>

<p><strong>Note:</strong> <code>ifElse</code> is not a real operator ðŸ™ƒ</p>

<p>So we start with our <code>selectedItems$</code>. We then want to add our conditional logic. If we pass our conditional logic (either no delay or we showed the popup and the user accepted), we can perform the backend call. We can do this with the <code>switchMap</code> operator and using the <code>selectedItems</code>. At last we subscribe and we route to a different page if the call was successfull.</p>

<p>Now, how can we plug 	in in that conditional logic? First of all, letâ€™s think about how we can show a popup. We can have a function, that adds a popup to the DOM and returns an Observable with the result. The type signature for that function could look like this:</p>

<pre><code class="language-typescript">showDialog(): Observable&lt;boolean&gt;;
</code></pre>

<p>So, inside of the <code>Observable</code> chain we had above, we want to conditionally execute the <code>Observable</code> that we get from the <code>showDialog</code> function so the dialog is shown. But, we only want to show this in case we have an item that delays the delivery date.</p>

<p>Letâ€™s first implement what we need to do when there is no delivery delay (happy path ðŸ˜„).</p>

<pre><code class="language-typescript">selectedItems$.pipe(
	map(selectedItems =&gt; {
		// if none of the items has a late delivery
		if(!selectedItems.find(item =&gt; item.lateDelivery)) {
			return selectedItems;
		}
	}),
	switchMap(selectedItems =&gt; this.service.buy(selectedItems))
);
</code></pre>

<p>We add an if statement inside of a <code>map</code> operator. If the condition is not met, so there is no delayed delivery, we just return the <code>selectedItems</code> so these can be used in the <code>switchMap</code> operator to do the backend call.</p>

<p>So far so good. BUT, how will we implement the else?</p>

<p>Inside of the <code>map</code> operator, we can implement the else case. In that else case, we want to show the dialog. This means, we are going to map to the result of the <code>showDialog</code> function.</p>

<pre><code class="language-typescript">selectedItems$.pipe(
	map(selectedItems =&gt; {
		// if none of the items has a late delivery
		if(!selectedItems.find(item =&gt; item.lateDelivery)) {
			return selectedItems;
		} else {
			return showDialog();
		}
	}),
	switchMap(selectedItems =&gt; this.service.buy(selectedItems))
);
</code></pre>

<p>Of course, this introduces a problem inside of our code. The if statement will still work, but the else statement is posing a problem here. If the else is executed, the stream that is returned by the <code>map</code> operator (so before the <code>switchMap</code>) is of type <code>Observable&lt;Observable&lt;&lt;boolean&gt;&gt;</code>. Thatâ€™s not what we need. The <code>switchMap</code> operator needs to be applied to an <code>Observable</code> with our selected items.</p>

<p>To fix this, we donâ€™t need to return the <code>dialog$</code> but:</p>

<ul>
  <li>Subscribe to this stream (remember, <code>Observable</code>s are lazy and subscribing will trigger the dialog to be shown)</li>
  <li>Listen for the result of that <code>dialog$</code>, remember, the user can either accept or decline, and handle this properly</li>
</ul>

<p>First step in fixing this, we can change the operator that we are using. If we change the <code>map</code> operator to a flattening operator such as <code>switchMap</code> or <code>concatMap</code>, we can return the <code>Observable</code> from the <code>showDialog</code> function and the operator will flatten it from an <code>Observable&lt;Observable&lt;boolean&gt;&gt;</code> to an <code>Observable&lt;boolean&gt;</code>.</p>

<p>Letâ€™s take a look at the code:</p>

<pre><code class="language-typescript">selectedItems$.pipe(
	switchMap(selectedItems =&gt; {
		// if none of the items has a late delivery
		if(!selectedItems.find(item =&gt; item.lateDelivery)) {
			return of(selectedItems);
		} else {
			return showDialog();
		}
	}),
	switchMap(selectedItems =&gt; this.service.buy(selectedItems))
);
</code></pre>

<p>As you can see we changed from a <code>map</code> to a <code>switchMap</code>. Because we changed the operator, we have to make sure that every branch in the function we pass to <code>switchMap</code> returns an <code>Observable</code>. Thatâ€™s why we changed the <code>selectedItems</code> to <code>of(selectedItems)</code>.</p>

<p>With this code, we are going to show the popup only if the condition is met. So we have a part of the conditional logic that we need. But, the overall code is not yet complete. The type of the <code>Observable</code> created by the first <code>switchMap</code> is <code>Observable&lt;boolean|Array&lt;Item&gt;</code>. And thatâ€™s not what we want. We donâ€™t want that boolean in there.</p>

<p>The last thing we need to do is check the value that we get back from the <code>dialog$</code>. This will return <code>true</code> if the user accepted the delay or <code>false</code> if the user denied. In that last case, we donâ€™t want to call the backend and this stream should stop.</p>

<p>Letâ€™s add this:</p>

<pre><code class="language-typescript">selectedItems$.pipe(
	switchMap(selectedItems =&gt; {
		// if none of the items has a late delivery
		if(!selectedItems.find(item =&gt; item.lateDelivery)) {
			return of(selectedItems);
		} else {
			return showDialog().pipe(
				map(res =&gt; {
					if(res) {
						return of(selectedItems);
					} else {
						return never();
					}
				}),
			);
		}
	}),
	switchMap(selectedItems =&gt; this.service.buy(selectedItems))
);
</code></pre>

<p>Before returning the stream we get from the <code>showDialog</code> function, we are going to map its result to what we want.</p>

<p>If the result was <code>true</code> we are going to return our <code>selectedItems</code>. But, since this is wrapped inside of a <code>switchMap</code> operator, we need to wrap this into an <code>Observable</code> using the static <code>of</code> operator.</p>

<p>If the result was <code>false</code>, we can return the <code>never()</code> <code>Observable</code>. This is an <code>Observable</code> that will have no events whatsover. By doing this, the <code>Observable</code> chain is interrupted and <code>switchMap</code> that executes the backend call will never get an event and thus will not get executed (the one doing the backend call ðŸ™ƒ).</p>

<p>As as a last step, we want to make sure that we only take a single value. We start from the <code>selectedItems$</code> which can have potentially multiple values. For example when:</p>

<ul>
  <li>the user gets the popup,</li>
  <li>decides to cancel</li>
  <li>selects or deselects a new item</li>
</ul>

<p>the subscription would still be active. If the user selects a new item, the logic in our stream would fire immediately. We can fix this quite easily with the <code>take</code> operator.</p>

<pre><code class="language-typescript">selectedItems$.pipe(
	take(1),
	switchMap(selectedItems =&gt; {
		// if none of the items has a late delivery
		if(!selectedItems.find(item =&gt; item.lateDelivery)) {
			return of(selectedItems);
		} else {
			return showDialog().pipe(
				map(res =&gt; {
					if(res) {
						return of(selectedItems);
					} else {
						return never();
					}
				}),
			);
		}
	}),
	switchMap(selectedItems =&gt; this.service.buy(selectedItems))
);
</code></pre>
<p>And thatâ€™s it. This code does what we want! ðŸŽ‰ðŸŽ‰</p>

<p>You can find a working (slightly contrived example) below. Click the buttons to trigger a delivery with or without delay. You can open the console to see a log statement being logged everytime the backend call would be executed.</p>

<iframe style="width: 100%; height: 450px" src="https://stackblitz.com/edit/rxjs-hsqluy?embed=1&amp;file=index.ts"></iframe>

<h2 id="using-the-tap-operator">Using the <code>tap</code> operator</h2>

<p>You can also hook into the <code>Observable</code> chain using the <code>tap</code> operator and maybe do some conditional work there. For example, to disable or enable a certain button:</p>

<pre><code class="language-typescript">const selectedItems$ = ...

selectedItems$.pipe(
	tap(selectedItems =&gt; {
		if(selectedItems.length === 5) {
			this.newOrderBtnDisabled = true;
		} else {
			this.newOrderBtnDisabled = false;
		}
	})
);
</code></pre>

<p>I would argue however that it is better to create a new stream that contains the â€˜disableâ€™ state of that button. This can be achieved like this:</p>

<pre><code class="language-typescript">const selectedItems$ = ...

const disabled$ = selectedItems$.pipe(
	map(selectedItems =&gt; selectedItems &gt; 5)
);
</code></pre>

<p>This gives you exactly the same result and we do not need â€˜if-elseâ€™ logic here.</p>

<h2 id="when-to-use-this">When to use this</h2>

<p>Some examples where to use this pattern is:</p>

<ul>
  <li>when a popup can decide if the action should be executed</li>
  <li>when creating a generic component that can show a spinner or not based on some configuration</li>
  <li>when creating a wizard and you only want to continue to the next step if the user current step is validated through a backend call</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>RxJS patterns - Mapping function calls to streams</title>
	  <link>//rxjs-patterns-mapping-function-calls-to-streams/</link>
	  <author></author>
	  <pubDate>2019-01-15T00:00:00+00:00</pubDate>
	  <guid>//rxjs-patterns-mapping-function-calls-to-streams/</guid>
	  <description><![CDATA[
	     <p>This post is part of a series of blogpost on different RxJS patterns that I use quite often. Here are the previous ones:</p>

<ul>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-restarting-work/" target="_blank">Restarting work</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-conditionally-executing-work/" target="_blank">conditionally executing work</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-prematurely-ending-work/" target="_blank">prematurely ending work</a></li>
</ul>

<p>Now, I want to cover how you map function calls to streams. Sometimes we need to transform a function call into a stream. Letâ€™s say that we are integrating with an external library. We can pass a function to this library and every time this function gets called, we need to perform an action.</p>

<p>For example, we have a date picker to which we can pass a function <code>dateChange</code> that gets called when the date is updated. Whenever our date changes, we want to perform a backend call to fetch some data and show it onto the screen.</p>

<p>In RxJS code, I would write something like this:</p>

<pre><code class="language-typescript">const dateChange$ = ...

const data$ = dateChange$.pipe(
	switchMap(date =&gt; this.service.getData(date),
);
</code></pre>

<p>In this scenario, Iâ€™m defining <code>data$</code> in terms of what it depends on, being the <code>dateChange$</code>. Because we define it like this and RxJS is a push based paradigm, every time the <code>dateChange$</code> changes, the <code>data$</code> will be updated and get a new value.</p>

<p>But the problem here is, how do we get a <code>dateChange$</code>. We are integrating with a third party library that is going to call a function every time the date changes, it does not give us a stream. And we need a stream to write the reactive code we had in the snippet above.</p>

<h2 id="transforming-a-function-into-an-observable">Transforming a function into an Observable</h2>

<p>An <code>Observable</code> is something that encapsulates â€˜workâ€™ (to understand what I mean with â€˜workâ€™ please read the first pattern I covered <a href="https://blog.strongbrew.io/rxjs-patterns-restarting-work/#what-is-work" target="_blank">here</a>). The encapsulation here means that we cannot define what that â€˜workâ€™ is. Once we get an <code>Observable</code> we can no longer change that â€˜workâ€™.</p>

<p>However, there is a building block in RxJS were we can decide whatever an <code>Observable</code> produces and this is called a <code>Subject</code>!</p>

<p>A complicated definition of a <code>Subject</code> is that it is both an <code>Observable</code> and an <code>Observer</code>. I like to think of it as being an <code>Observable</code> that has no work encapsulated and where you can produce the values. So you can send the next, error and/or complete event(s).</p>

<p>Letâ€™s see a code example on how we can leverage a <code>Subject</code> to transform a function call into an <code>Observable</code>.</p>

<pre><code class="language-typescript">const dateChange$ = new Subject();

someLibrary.onDateChange(
	(date) =&gt; dateChange$.next(date)
);
</code></pre>

<p>And thatâ€™s it! We pass a function to the third party library that only emits the value it gets onto the created <code>dateChange$</code> <code>Subject</code>. And because a <code>Subject</code> is also an <code>Observable</code>, we can just plug this into the snippet we had above.</p>

<pre><code class="language-typescript">const dateChange$ = new Subject();

someLibrary.onDateChange(
	(date) =&gt; dateChange$.next(date)
);

const data$ = dateChange$.pipe(
	switchMap(date =&gt; this.service.getData(date),
);
</code></pre>
<p>Tada!</p>

<h3 id="other-ways">Other ways</h3>

<p>There are two other operators you can use to accomplish the same thing. The first one is called <code>fromEvent</code>. This one is perfect to integrate with APIâ€™s that exposes functions where you can pass in a string describing the event type and a function to be called whenever such an event happens. This is ideal for DOM events for example (but not limited to as you can see <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent" target="_blank">here</a>):</p>

<pre><code class="language-typescript">const somethingElement = document.getElementById('something');

// a stream of all clicks on the somethingElement
const click$ = fromEvent(somethingElement, 'click');
</code></pre>

<p>The other operator is called <code>fromEventPattern</code>. This can be used to integrate with the exact example described above. The code with <code>fromEventPattern</code> looks like this:</p>

<pre><code class="language-typescript">fromEventPattern((handler) =&gt; someLibrary.onDateChange(handler))
 .subscribe(console.log);
</code></pre>

<p>You can pass it a function that receives a <code>handler</code>. You can pass that <code>handler</code> to any callback based API which will be transformed into a stream.</p>

<p><strong>Note</strong>: If you can use <code>fromEvent</code> or <code>fromEventPattern</code> you definitely should. The way to do it with a <code>Subject</code> is demonstrated since that is the most straight forward way and works in any scenario. But, if possible, use the operators.</p>

<h2 id="when-to-use-this">When to use this</h2>

<p>Some concrete examples where to use this are:</p>

<ul>
  <li>When a function gets called by a third party library and we need a stream</li>
  <li>To transform <code>@Output</code>s in Angular into streams</li>
  <li>Basically most scenarios where we need a stream but donâ€™t get it from some API</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>RxJS patterns - restarting work</title>
	  <link>//rxjs-patterns-restarting-work/</link>
	  <author></author>
	  <pubDate>2019-01-05T00:00:00+00:00</pubDate>
	  <guid>//rxjs-patterns-restarting-work/</guid>
	  <description><![CDATA[
	     <p>Having used RxJS for a while now, Iâ€™ve started to see patterns that Iâ€™m using over and over again. In this blogpost, or better, series of blogposts, I want to share those patterns that Iâ€™m frequently using so that you can apply them in your own code.</p>

<p>Here are the other patterns:</p>
<ul>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-mapping-function-calls-to-streams/" target="_blank">Mapping function calls to streams</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-conditionally-executing-work/" target="_blank">conditionally executing work</a></li>
  <li><a href="https://blog.strongbrew.io/rxjs-patterns-prematurely-ending-work/" target="_blank">prematurely ending work</a></li>
</ul>

<p>Iâ€™ll do this by describing them as high level as possible, but still provide you with some examples on where they can be applied.</p>

<h2 id="what-is-work">What is â€˜workâ€™?</h2>

<p>When conducting interviews and discussing RxJS, I tend to ask people how they would describe an <code>Observable</code> in only a couple of sentences. Iâ€™m well aware that this is difficult and quite hard to describe. Here is my personal attempt:</p>

<blockquote>
  <p>An <code>Observable</code> is a wrapper around some work. That work can be triggered by subscribing in response to which one or multiple results can be pushed towards us. This might happen both synchronously and asynchronously.</p>
</blockquote>

<p>The reason Iâ€™m mentioning this is because it will help me in explaining what I mean with the term â€˜workâ€™ in the context of an <code>Observable</code>. Whatever is being triggered by subscribing to an <code>Observable</code> is something that I will refer to as â€˜workâ€™.</p>

<h2 id="why-do-we-need-to-restart-work">Why do we need to restart work?</h2>

<p>Letâ€™s say that we have an <code>Observable</code> whose â€˜workâ€™ is actually triggering a backend call. We might want to execute this backend call multiple times, hence we want the â€˜workâ€™ that this specific <code>Observable</code> does to be executed multiple times.</p>

<p>Thanks to the fact that <code>Observables</code> are cold by default, we can accomplish this by subscribing to this <code>Observable</code> multiple times. Every subscription will trigger a backend call.</p>

<h2 id="how-can-we-do-this">How can we do this?</h2>

<h3 id="non-reactive">Non reactive</h3>

<p>A non-reactive solution to do so could be wrapping the subscription in a function and calling it over and over again every time we wish to subscribe.</p>

<pre><code class="language-typescript">const executeBackendCall = () =&gt; {
	this.someObs$.subscribe((result) =&gt; {
	   // do something here
	}
}
</code></pre>

<p>But this obviously has some downsides to it. Aside from the fact that is not reactive, we have a subscription to manage for every function call, we can no longer chain this with other operators (as we manually subscribe), and so on.</p>

<h3 id="reactive">Reactive</h3>

<p>We want to implement this in a more reactive way. We can do this by no longer thinking in terms of function calls but in term of a series of triggers where we want to do something. We need a stream that is triggered every time we want a certain action to occur.</p>

<p>Letâ€™s assume we have such a stream. Whenever that stream fires, we want to do some â€˜workâ€™. Remember that â€˜workâ€™ is something that is encapsulated in an <code>Observable</code>.</p>

<p>Translated to code this means that we want to map a next event to an <code>Observable</code>.</p>

<pre><code class="language-typescript">const work$: Observable&lt;T&gt; = ...
const trigger$ = ...

const workExecutedOnTrigger$: Observable&lt;Observable&lt;T&gt;&gt; = trigger$.pipe(
	map(triggerValue =&gt; work$)
);
</code></pre>

<p>In this piece of code we have an <code>Observable</code> called <code>work$</code>, containing the â€˜workâ€™ we want to do when the <code>trigger$</code> fires. 
We can create a new stream called <code>workExecutedOnTrigger$</code> that maps the trigger event to the <code>work$</code>.</p>

<p>The problem with this code is that the result of this action is an <code>Observable&lt;Observable&lt;T&gt;&gt;</code> (also called a higher order observable) whilst we would actually like to have an <code>Observable&lt;T&gt;</code>.</p>

<p>To accomplish this, we can use a flattening operator. We could use <code>switchMap</code> for example.</p>

<pre><code class="language-typescript">const work$ = ...
const trigger$ = ...

const workExecutedOnTrigger$: Observable&lt;T&gt; = trigger$.pipe(
	switchMap(triggerValue =&gt; work$)
);
</code></pre>

<p>And this is it! Now we have an observable <code>workExecutedOnTrigger$</code> that will execute our <code>work$</code> and will restart that every time our <code>trigger$</code> fires. It is restarted as the <code>switchMap</code> operator will do the following:</p>

<ol>
  <li>the <code>trigger$</code> fires a next event</li>
  <li>the <code>switchMap</code> operator takes that event and maps it to <code>work$</code></li>
  <li>the <code>switchMap</code> operator subscribes to that stream</li>
  <li>Every event emitted by the <code>work$</code> is being passed down</li>
  <li>if the <code>trigger$</code> fires a new event, the previous execution of <code>work$</code> is unsubscribed from</li>
  <li>Step 2 through 5 is repeated</li>
</ol>

<p>Thanks to the <code>switchMap</code> operator, we can restart the â€˜innerâ€™ <code>work$</code>. This means that we can <strong>restart our work</strong>.</p>

<p><strong>Note:</strong> To create the <code>trigger$</code> we can use a <code>Subject</code>. Iâ€™ll cover this in the next pattern â€˜mapping function calls to streamsâ€™.</p>

<h2 id="when-to-use-it">When to use it</h2>

<p>As promised, here are some concrete example when you would use this:</p>

<ul>
  <li>In an autocomplete, we want to execute a backend call every time the user types something new. We want to restart the call to the backend.</li>
  <li>We fetch some data when the page loads for the first time. When we want to do this a second time (after data has been updated for example), we want to re-execute that call.</li>
</ul>

<pre><code class="language-typescript">this.data$ = this.load$.pipe(
   switchMap(_ =&gt; this.service.loadData())
);
</code></pre>
<p>In this example <code>load$</code> will emit at start up and every time the data needs to be loaded. This is a very common scenario where this concept of restarting work can be used.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>Special thanks to <a href="https://twitter.com/elmd_" target="blank">Dominic Elm</a> for reviewing!</p>


	  ]]></description>
	</item>


</channel>
</rss>
