<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link>https://blog.strongbrew.io/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>A generic way of handling loading-status, saving-status and validation errors in Angular</title>
	  <link>//generic-way-of-handling-loading-saving-and-validationerrors-in-angular/</link>
	  <author></author>
	  <pubDate>2019-01-25T00:00:00+01:00</pubDate>
	  <guid>//generic-way-of-handling-loading-saving-and-validationerrors-in-angular/</guid>
	  <description><![CDATA[
	     <p>When writing Angular applications there are always pieces of functionality that are being rewritten over and over again. 3 common usecases are:</p>

<ul>
  <li>Showing a <em>loading</em> status</li>
  <li>Showing an <em>acting</em> status (whether the user is adding, updating or removing data)</li>
  <li>Showing validation errors</li>
</ul>

<p>In this article we are going to implement a generic solution on how to fix these usecases.</p>

<h2 id="a-non-generic-way-of-loading-saving-and-handling-validation-errors-in-angular">A non generic way of loading, saving and handling validation errors in Angular</h2>

<p>Before we jump to the solution, let‚Äôs have a look at the impact of a non generic way of handling the previous called functionalities.
A solution that is often used might look like the following: (keep in mind that this functionality has to be implemented over and over again for every component)</p>

<pre><code class="language-typescript">ngOnInit(): void {
    this.loading = true;
    const usersCompleted = false;
    const citiesCompleted = false;
    this.userService.fetch().subscribe(users =&gt; {
        usersCompleted = true;
        this.loading = usersCompleted &amp;&amp; citiesCompleted;
    });
    this.citiesService.fetch().subscribe(cities =&gt; {
        citiesCompleted = true;
        this.loading = usersCompleted &amp;&amp; citiesCompleted;
    });
}
</code></pre>
<p>We have to keep track of which call completes first because we can‚Äôt set loading to false, if there is call still busy. What happens when there is an error? We would have to implement that as well.</p>

<p>Now this code is only for fetching two lists of data, this becomes ugly pretty quickly and the worst thing about this is that we have to reimplement that for every component that does data fetching.</p>

<p>It becomes even worse if we want to update, add and remove data. Imagine that we have to handle validation errors as well:</p>

<pre><code class="language-typescript">remove(user: User): void {
    // TODO: set acting to true
    this.userService.remove(user).subscribe(res =&gt; {
        // TODO: set acting to false
    });
}
update(user: User): void {
    // TODO: set acting to true
    this.userService.update(user).subscribe(res =&gt; {
        // TODO: set acting to false
        // TODO: handle validation errors
    });
}
add(user: User): void {
    // TODO: set acting to true
    this.userService.add(user).subscribe(res =&gt; {
        // TODO: set acting to false
        // TODO: handle validation errors
    });
}
</code></pre>

<p>To handle validation errors we have to check if the HTTP status code is 400, manually map the data etc.</p>

<p>These code samples are in this article to prove a point. <strong>It‚Äôs dirty redundant logic that we have to implement over and over again</strong></p>

<h2 id="lets-clean-this-up">Let‚Äôs clean this up</h2>

<p>To achieve this we will use an Angular <em>service</em> in combination with an angular <em>interceptor</em> and Typescript <em>decorators</em>.</p>

<p>The first thing we need is a <code>HttpStatusService</code> that exposes 3 observables:</p>

<ul>
  <li><code>loading$</code>: whether the user is fetching data</li>
  <li><code>acting$</code>: whether the user is removing, updating or adding data</li>
  <li><code>validationErrors$</code>: whether there are validation errors or not</li>
</ul>

<pre><code class="language-typescript">// http-status.service.ts
@Injectable({
  // important to provide this service to the 
  // injector of the root module 
  providedIn: 'root'
})
export class HttpStatusService {
  // regular subject because we don't want to replay
  // the validationerrors
  private validationErrorsSub$ 
    = new Subject&lt;ValidationError[]&gt;();

  // 2 subjects that replays the last value 
  // (ideal for state)
  private loadingSub$ = new ReplaySubject&lt;boolean&gt;(1);
  private actingSub$ = new ReplaySubject&lt;boolean&gt;(1);

  // we don't want to expose the subject for
  // encapsulation purposes. That's why we convert them
  // into observables
  getvalidationErrors$ = 
    this.validationErrorsSub$.asObservable();
  loading$ = 
    this.loadingSub$.pipe(distinctUntilChanged());
  acting$ = 
    this.actingSub$.pipe(distinctUntilChanged());

  // these are just some regular setters to next 
  // the values in our subjects
  set validationErrors(errors: ValidationError[]) {
    this.validationErrorsSub$.next(errors);
  }

  set loading(val: boolean) {
    this.loadingSub$.next(val);
  }

  set acting(val: boolean) {
    this.actingSub$.next(val);
  }
}
</code></pre>

<p>So we have a service that basically holds the state of our three statuses.
Now we still have to make sure that the setters of these observables are being called at the right place and the right time.
We don‚Äôt want to manually implement that for every call, so let‚Äôs create an interceptor for that.</p>

<pre><code class="language-typescript">@Injectable({
    providedIn: 'root'
})
export class HttpStatusInterceptor implements HttpInterceptor {
  // keep track of the loading calls
  private loadingCalls = 0; 
  // keep track of the acting calls
  private actingCalls = 0; 

  constructor(
    private httpStatusService: HttpStatusService
  ) {}

  private changeStatus(val: boolean, method: string): void {
    if (['POST', 'PUT', 'DELETE', 'PATCH']
      .indexOf(method) &gt; -1) {
      val ? this.actingCalls++ : this.actingCalls--;
      this.httpStatusService.acting = this.actingCalls &gt; 0;
    } else if (method === 'GET') {
      val ? this.loadingCalls++ : this.loadingCalls--;
      this.httpStatusService.loading = this.loadingCalls &gt; 0;
    }
  }
  ...
}

</code></pre>

<p>As we can see, we have created a private <code>changeStatus()</code> function that will use the <code>loading</code> and <code>acting</code> 
setters of our <code>HttpStatusInterceptor</code> class.</p>

<p>If the HTTP-method is <code>POST</code>, <code>PUT</code>, <code>DELETE</code> or <code>PATCH</code> we have to update the counter of the <code>actingCalls</code> and if that count is bigger then 0, it means the user is acting and we have to update the <code>acting</code> property of the <code>HttpStatusService</code>.</p>

<p>If the HTTP-method is <code>GET</code> it should do the same for the <code>loadingCalls</code> property and <code>loading</code> setter of the <code>HttpStatusService</code>.</p>

<p>Of course we still have to implement the <code>intercept</code> function. Every time we intercept a call we have to change a status to <code>true</code>.
Because this means that the user is loading or acting.
The goal of an interceptor is to intercept a request, clone that request, do something with it and return it.
The <code>handle</code> function of the <code>HttpHandler</code> returns an observable. This is the perfect place to apply a <code>finalize</code> operator,
which we can use to set a status to <code>false</code>.</p>

<pre><code class="language-typescript">...
intercept(
  req: HttpRequest&lt;any&gt;,
  next: HttpHandler
): Observable&lt;HttpEvent&lt;any&gt;&gt; {
  // there is a new request, so we are definitely
  // loading or acting, we have to change the status
  this.changeStatus(true, req.method);
  return next.handle(req.clone()).pipe(
    // when the request completes, errors or times out,
    // we have to change the status as well
    finalize(() =&gt; {
      this.changeStatus(false, req.method);
    })
  );
}

</code></pre>

<p>This should automatically update the <code>loading$</code> and <code>acting$</code> observables in the <code>HttpStatusService</code>.
However, we have not fixed our validation errors issue yet. For that we can use the <code>catchError</code> operator that we place before the finalize operator:</p>

<pre><code class="language-typescript">intercept(
  req: HttpRequest&lt;any&gt;,
  next: HttpHandler
): Observable&lt;HttpEvent&lt;any&gt;&gt; {
  ..
  return next.handle(req.clone()).pipe(
    // catch the error
    catchError(e =&gt; {
      // if bad request &gt; validation erors
      if (e.status === 400) { 
        // use the validationErrors setter to update
        this.httpStatusService.validationErrors = 
          e.error.validationErrors;
        // make sure that this result never 
        // reaches the component
        return NEVER;
      }
      // throw the error back
      // or put that in the `HttpStatusService` as well ;-)      
      return throwError(e); 
    }),
    finalize(...)
  );
}
</code></pre>

<p>The entire interceptor class looks like this:</p>

<pre><code class="language-typescript">@Injectable({
    providedIn: 'root'
})
export class HttpStatusInterceptor implements HttpInterceptor {
  private loadingCalls = 0; 
  private actingCalls = 0; 

  constructor(
    private httpStatusService: HttpStatusService
  ) {}

  private changeStatus(v: boolean, method: string): void {
    if (['POST', 'PUT', 'DELETE', 'PATCH']
      .indexOf(method) &gt; -1) {
      v ? this.actingCalls++ : this.actingCalls--;
      this.httpStatusService.acting = this.actingCalls &gt; 0;
    } else if (method === 'GET') {
      v ? this.loadingCalls++ : this.loadingCalls--;
      this.httpStatusService.loading = this.loadingCalls &gt; 0;
    }
  }

  intercept(
    req: HttpRequest&lt;any&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(req.clone()).pipe(
      catchError(e =&gt; {
        if (e.status === 400) { 
          this.httpStatusService.validationErrors = 
            e.error.validationErrors;
          return NEVER;
        }
        return throwError(e); 
      }),
      finalize(() =&gt; {
        this.changeStatus(false, req.method);
      })
    );
  }
}
</code></pre>

<p>When registering the interceptor to the root module, the observables in the <code>HttpStatusService</code> will be updated automatically.</p>

<p>So in the rootModule we have to add the following code to the <code>providers</code> property of the <code>@NgModule</code> decorator:</p>

<pre><code class="language-typescript">providers: [
  ...
  {
    provide: HTTP_INTERCEPTORS,
    multi: true,
    deps: [HttpStatusService],
    useClass: HttpStatusInterceptor
  }
]
</code></pre>

<p>We can now use the <code>HttpStatusService</code> in our code as easy as this:</p>

<pre><code class="language-typescript">export class UserComponent {
  loading$ = this.httpStatus.loading;
  validationErrors$ = this.httpStatus.validationErrors;
  acting$ = this.httpStatus.loading;

  constructor(
    private httpStatusService: HttpStatusService) {
  }
}
</code></pre>

<p>We now have 3 observables that can easily be consumed in the template of the component with the use of the <a href="https://angular.io/api/common/AsyncPipe">async</a> pipe. Here is an example:</p>

<pre><code class="language-html">&lt;my-spinner *ngIf="loading$ | async"&gt;&lt;/my-spinner&gt;
&lt;my-user-form 
    [validationErrors]="validationErrors$ | async"
    [disabled]="acting$ | async"&gt;&lt;/my-user-form&gt;

</code></pre>

<h2 id="optimizing-with-decorators">Optimizing with decorators</h2>

<p>We have cleaned up a lot, we found an easy way to get the httpstatuses to the component, but we can make it even simpler with the use of decorators. let‚Äôs refactor the <code>UserComponent</code> class accordingly:</p>

<pre><code class="language-typescript">export class UserComponent {
  @Loading()loading$;
  @ValidationErrors() validationErrors$;
  @Acting() acting$;
}
</code></pre>

<p>This is very declarative way of working. The component is way cleaner and we don‚Äôt have to inject the <code>HttpStatusService</code> anymore.</p>

<p>But how do we create these decorators? I‚Äôm glad you asked, it‚Äôs pretty easy. A property decorator is simply a function that returns a function that gets the target and key as arguments.</p>

<pre><code class="language-typescript">export function Loading() {
  return function (target: any, key: string): void {
    // in this case the target is the component
    // instance and key the property name
    // target: userComponent, key: loading$
    // now we have to set the property to the actual 
    // loading$ observable that lives in the HttpStatusService
    target[key] = // todo
  }
};
</code></pre>

<p>To set the property of the target we need to inject the <code>HttpStatusService</code> instance that is registered on the root injector of our application. After all that‚Äôs the instance that contains the actual state. Currently there is no easy way to do that.
Until Angular provides us with functionality like <a href="https://github.com/angular/angular/issues/23301">that</a> we can use the following solution:</p>

<p>Next to the <code>http-status.service</code> file, create a file called <code>root-injector.ts</code> and add the following code:</p>

<pre><code class="language-typescript">import { Injector } from '@angular/core';

export let rootInjector: Injector;
export function setRootInjector(injector: Injector): void {
  rootInjector = injector;
}
</code></pre>

<p>The <code>setRootInjector()</code> function will be used by the rootModule to set the <code>rootInjector</code> variable that we expose here.
To make it work the rootModule will have to call the <code>setRootInjector()</code> function like this:</p>

<pre><code class="language-typescript">@NgModule({
    ...
})
export class AppModule {
  constructor(private injector: Injector) {
    setRootInjector(injector);
  }
}

</code></pre>

<p>The last step is to actually use the <code>rootInjector</code> variable inside the decorators. The result looks like this:</p>

<pre><code class="language-typescript">// loading.decorator.ts
export function Loading() {
  return function (target: any, key: string): void {
    const service = rootInjector.get(HttpStatusService);
    target[key] = service.loading$;
  }
};

// acting.decorator.ts
export function Acting() {
  return function (target: any, key: string): void {
    const service = rootInjector.get(HttpStatusService);
    target[key] = service.acting$;
  }
};

// validation-errors.decorator.ts
export function ValidationErrors() {
  return function (target: any, key: string): void {
    const service = rootInjector.get(HttpStatusService);
    target[key] = service.validationErrors$;
  }
};
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We have learned that we can remove the redundancy that comes with loading, acting and error handling statuses almost completely by the use of an interceptor, a simple service and a few decorators.</p>

<p>I hope you liked it!</p>

<h2 id="special-thanks">Special thanks</h2>

<p>A very special thanks to the reviewers:</p>

<ul>
  <li><a href="https://twitter.com/bobrov1989">Vitallii Bobrov (@bobrov1989)</a></li>
  <li><a href="https://twitter.com/webdave_de">David M√ºllerchen (@webdave_de)</a></li>
  <li><a href="https://twitter.com/maartentibau">Maarten Tibau (@maartentibau)</a></li>
  <li><a href="https://twitter.com/elmd_">Dominic Elm (@elmd_)</a></li>
  <li><a href="https://twitter.com/fabiangosebrink">Fabian Gosebrink (@FabianGosebrink)</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Migrating to Nx</title>
	  <link>//migrating-to-nx/</link>
	  <author></author>
	  <pubDate>2019-01-05T00:00:00+01:00</pubDate>
	  <guid>//migrating-to-nx/</guid>
	  <description><![CDATA[
	     <p>I have been using a monorepo with Nx for a while now (~1 year, an almost infinite period in javascript land üòÇ). And I must say, this has been a real eye opening experience. I‚Äôve gotten to the point that everyone that is remotely interested into talking to me is going to get a pitch on why monorepos are the best and how Nx can help us in achieving this. I even gave a talk about this very topic at NG-BE which you can find <a href="https://www.youtube.com/watch?v=d04U7SjORTI" target="_blank">here</a>.</p>

<p>The most common response that I‚Äôve gotten is: ‚ÄúThat all sounds great, but I‚Äôll never be able to convince everyone in my company to start using a monorepo‚Äù. And this is the reason that I‚Äôm writing this blogpost. Because moving to a monorepo doesn‚Äôt have to be a big bang change at all. In fact, this is something you could do gradually, at your own pace over a long time period (although, I would try to do this in a reasonable time frame).</p>

<h2 id="migrating">Migrating</h2>

<h3 id="current-situation">Current situation</h3>

<p>In most companies that I‚Äôve visited over the past years, the situation is as follows. There are multiple teams working on different applications or libraries. Every team has its own repository where they store the code that is written by that team. If code needs to be shared with different teams, some code is published to an (internal) npm registry by one team and loaded by another team as a dependency.</p>

<p>This situation could be referred to as a being a ‚Äòpolyrepo approach‚Äô and kind of looks like this:</p>

<p><img src="https://www.dropbox.com/s/lbf2k9rrd16mo42/polyrepo-migration-to-nx.png?raw=1" alt="polyrepo" /></p>

<p>In this scenario, we have three teams with three repos. Team 1 is working on a ‚Äòui-kit‚Äô that is being published to npm. The other teams load this ‚Äòui-kit‚Äô by downloading it from the (internal) npm registry.</p>

<p><strong>Note:</strong> Explaining why publishing to npm might not be the best idea in every situation and how a monorepo fixes this is not in the scope of this blogpost. For that, I would like to refer you to this <a href="https://www.youtube.com/watch?v=q4XmAy6_ucw" target="_blank">excellent talk</a> by Manfred Steyer.</p>

<h3 id="hybrid-situation">Hybrid situation</h3>

<p>Most people think that, when you want to move to a monorepo, all three teams in the example above need to do that in a single go. But this isn‚Äôt true at all. In fact, there is an obvious step between a polyrepo and a monorepo which I like to refer to as being a ‚Äòhybrid approach‚Äô. And it looks a little like this:</p>

<p><img src="https://www.dropbox.com/s/uxpdfxim81oz2x4/hybrid-migrating-to-nx.png?raw=1" alt="hybrid" /></p>

<p>In this specific scenario, as a first step towards a monorepo, the team responsible for ‚Äòapp 1‚Äô and the team responsible for the ‚Äòui-kit‚Äô have moved there code into a single repository. This repo is setup using Nx (hence the distinction between apps and libs inside of that repo).</p>

<p>The important thing to notice here is the fact that the ui-kit is both published to npm AND imported inside of ‚Äòapp 1‚Äô. This means that both inside the monorepo as outside of the monorepo this library is being used. This is exactly what is meant by the hybrid approach.</p>

<p>This allows us to gradually start with a ‚Äòmonorepo‚Äô. You can start with two teams, and as soon as these get accustomed to it and everything is starting to run smoothly, a new team can be added. In the mean time, libraries that need to be shared with teams outside of the monorepo can still be published to npm. The end goal is that everything is moved to the monorepo.</p>

<p>It is also an ideal way to convince the non-believers of this approach. If people see that two teams can work perfectly well together inside of a single repo, you have a viable and working example to sell the idea!</p>

<h3 id="complete-monorepo-situation">Complete monorepo situation</h3>

<p>When everyone has move to the monorepo, the situation could look like this:</p>

<p><img src="https://www.dropbox.com/s/wyc5703yts5ddp2/monorepo-migrating-to-nx.png?raw=1" alt="monorepo	" /></p>

<p>Here, we no longer use npm as a means to distribute code between different teams.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Migrating to a Nx or a monorepo is something you can do one small step at a time. After having demonstrated everything works for a small amount of teams/projects/code, you can convince everyone that this is in fact they way to go (not always of course) and keep on migrating towards a complete monorepo!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Opinionated guidelines for large nx angular projects</title>
	  <link>//opinionated-guidelines-for-large-nx-angular-projects/</link>
	  <author></author>
	  <pubDate>2018-12-08T00:00:00+01:00</pubDate>
	  <guid>//opinionated-guidelines-for-large-nx-angular-projects/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>This article contains a set of opinionated guidelines when it comes to building monorepos with <a href="https://nrwl.io/nx">Nx</a>.
I wrote this article because when I used Nx in the beginning, I struggled a lot with how to structure my workspace, and I‚Äôve hit quite a few walls. That being said, I‚Äôve been using it for a while now, and I finally have the feeling that I‚Äôve reached a structure where I feel comfortable with.</p>

<h2 id="a-word-about-nx">A word about Nx</h2>

<p>Nx is a thin layer on top of the <a href="https://angular.io">Angular</a> CLI that helps us with structuring large applications in the form of monorepos.
A monorepo contains only one <a href="https://nrwl.io/nx/guide-nx-workspace">Nx workspace</a> that can contain multiple apps and multiple libs (we will refer to apps and libs as Nx projects). An app is a deployable unit and a lib is meant to contain the actual logic that can be shared across the workspace. Nx is actively being developed and updated along with Angular by the amazing people of <a href="https://nrwl.io/">Nrwl</a>.</p>

<p>Nx is especially valuable when managing <strong>big Angular applications</strong> that have a lot of shared functionality, but even in smaller projects it can help organize your approach.</p>

<p>At StrongBrew we are using this technology for a bunch of our clients and even though Nx is already pretty opinionated, I decided to write down some best practices and guidelines that I try to take in consideration.</p>

<p>The rules and guidelines written down in this article <strong>might work for you</strong>, and should in no circumstances be treated as the <em>ultimate truth</em>. Best practices and guidelines are mostly a matter of perception and personal preference. Nevertheless, I would love to share how I architect large Angular applications with Nx.</p>

<h2 id="barrel-files">Barrel files</h2>

<p>When it comes to managing monorepos, barrel files are quite important.
A barrel file is a <code>index.ts</code> file that lives in the <code>src</code> directory of every Nx lib and is meant to expose logic to the rest of the workspace.</p>

<p>This file is really important when you understand one of the big potential risks of organizing code in monorepos - overexposure of implementation details.</p>

<p>With code being located right next to each other, it can be easy to import code with deeply nested relative paths and include things that the original author of the code never intended to be used outside of their specific context.</p>

<p>The Nx lib‚Äôs <code>index.ts</code> file allows each lib to define its effective public API - only symbols which are explicitly exported from this file should be eligible for consumption in other parts of the workspace.</p>

<p>Let‚Äôs say that we have a <code>@strongbrew/users</code> lib which exposes a <code>UserService</code>‚Ä¶
This is what the barrel file from  <code>@strongbrew/users</code> might look like.</p>

<pre><code class="language-typescript">// libs/users/src/index.ts
export * from './lib/services/user.service';
</code></pre>

<p>Although this might seem pretty straight forward, let‚Äôs go over a few best-practices‚Ä¶</p>

<h3 id="dont-ever-import-a-lib-from-a-relative-path">Don‚Äôt ever import a lib from a relative path</h3>

<p>When we want to import <code>UserService</code> inside another lib or app, we want to import it from <code>@strongbrew/users</code>. This is way cleaner then importing it from a relative path like <code>../../../users/lib/src/index.ts</code> and helps protect us from the overexposure problem described above. Nx also provides a linting rule out of the box to make sure that you are respecting a lib‚Äôs API and not doing deep imports.</p>

<p>Nx uses TypeScript <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping">path mapping</a> to map these module names to the correct barrel files.</p>

<pre><code class="language-json">"paths": {
    "@strongbrew/users": {
        "libs/users/src/index.ts"
    }
}
</code></pre>

<h3 id="only-1-barrel-file-per-lib">Only 1 barrel file per lib</h3>

<p>It‚Äôs a known fact that barrel files might become big, but it gives us a central place of handling all the exports + it drastically reduces the chance of getting circular reference errors. Therefore, a lib should only contain 1 single barrel file.</p>

<h3 id="never-let-a-lib-import-from-its-own-barrel-file">Never let a lib import from its own Barrel file</h3>

<p>The TypeScript modules within a particular lib should not care what functionality that lib exposes, so it shouldn‚Äôt use its own barrel file at any point.</p>

<p>If a module imports something from its own barrel file, it almost always results in circular reference errors. Therefore, imports from inside of the module should use relative path imports.</p>

<h2 id="structuring-the-workspace">Structuring the workspace</h2>

<p>When using Nx, we might already get pushed in an opinionated way of working, which is great. But how are we going to structure the workspace itself? For instance, looking into a directory of 100 libs inside of a libs directory might not really be pragmatic to work with‚Ä¶</p>

<h3 id="structuring-apps">Structuring apps</h3>

<h4 id="an-app-should-be-an-empty-shell">An app should be an empty shell</h4>

<p>Apps are deployable units that wire the different pieces of an application together. These apps are nearly empty shells that use libs to build an entire application. Therefore <strong>an app holds almost no logic</strong> and mostly uses lazy loading to load feature libs. Some feature libs can be seen as microfrontends.
That being said, our apps mostly not completely empty. In general they also contain:</p>
<ul>
  <li>The general layout (composed out of components from ‚Äòui-kit‚Äô)</li>
  <li>Routing</li>
</ul>

<h4 id="keep-the-apps-directory-as-flat-as-possible">Keep the apps directory as flat as possible</h4>

<p>Chances are small that our monorepo will contain 100+ apps and even if it does, chances are small that we can divide these apps into categories.</p>

<h4 id="apps-should-not-import-from-other-apps">Apps should not import from other apps</h4>

<p>Although it might seem obvious, let‚Äôs mention it anyway‚Ä¶ Shared logic should always live inside of libs, an not inside of apps. Apps are specific deployment targets.</p>

<h3 id="structuring-libs">Structuring libs</h3>

<p>Here comes the opinionated part, lets check how we can structure the libs inside of our workspace.</p>

<p>The directory structure of our workspace might look like this:</p>
<ul>
  <li><code>apps</code></li>
  <li><code>libs</code>
    <ul>
      <li><code>feature</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>ui-kit</code></li>
      <li><code>utils</code></li>
    </ul>
  </li>
  <li>A feature contains logic specific to a certain domain, like managing users or performing authentication.</li>
  <li>On the other hand, the <code>utils</code> lib contains logic that doesn‚Äôt have anything to do with any domain, E.g: HTTP interceptors, shared RxJS operators, a service that handles notifications etc‚Ä¶ Consider it a toolkit for your workspace.</li>
</ul>

<p>In the next few sections we are going to cover the 3 types of feature libs, the <code>ui-kit</code> lib and the <code>utils</code> lib.</p>

<h4 id="featureapi">feature/api</h4>

<p>This directory contains Nx libs with a very specific purpose:</p>
<ul>
  <li>These libs contain <strong>api logic</strong> or <strong>business logic</strong> that needs to be shared.</li>
  <li>These libs contain the types of the REST responses. Let‚Äôs call them <strong>domain types</strong>.</li>
  <li>If we want to work with models, or dto‚Äôs, these would also live here.</li>
</ul>

<p>Having a specific api lib is very handy when developing in a microservices platform. Every microservice would have its own <strong>api lib</strong> that can be used throughout the entire monorepo.</p>

<p>Another common use-case is that feature libs tend to use domain types from other feature libs. By extracting these domain types in to api libs, we solve that problem. That way, these domain types can be shared across different places inside of the monorepo.</p>

<h4 id="featurelazy">feature/lazy</h4>

<p>This directory contains all feature libs that can be lazyloaded. To make sure these libs can be lazy-loaded, they should expose an <code>NgModule</code> in the barrel file and are loaded as such:</p>

<pre><code class="language-typescript">RouterModule.forRoot([
    {
        path: 'users',
        loadChildren: '@strongbrew/feature/lazy/users'
    }
])
</code></pre>

<p>One of the advantages is that these modules can be loaded on demand or even preloaded upfront. The biggest advantage though is that these modules are completely standalone, and don‚Äôt share anything with the rest of the workspace. This means they have nothing inside of their barrel file, other then the <code>NgModule</code> being exported. 
<strong>Lazy loaded modules can never share logic with the workspace</strong>
If we feel that a lazyloaded module needs to export something, we should extract that logic into a separate <code>feature/shared</code> or <code>feature/api</code> lib.</p>

<p>When a <code>feature/lazy</code> module needs to perform XHR calls it should delegate it to a <code>feature/api</code> lib. Therefore a <code>feature/lazy</code> lib should never contain api logic.</p>

<p>When using a statemanagement library like <a href="https://github.com/ngrx/platform">ngrx/store</a>, <code>feature/lazy</code> libs would contain their own reducers and use <code>store.forFeature()</code> to attach these to the <code>store</code> instance. This would result in lazy-loaded reducers.</p>

<h4 id="featureshared">feature/shared</h4>

<p>Not every feature can be lazyloaded. Think about feature logic that needs to be shared for instance. In that case we would create an Nx lib that lives inside of the <code>feature/shared</code> directory.</p>

<p>When a <code>feature/shared</code> module needs to perform XHR calls it should delegate it to a <code>feature/api</code> lib. Therefore the <code>feature/lazy</code> lib should not contain api logic.</p>

<h4 id="ui-kit">ui-kit</h4>

<p>This lib contains all the shared presentational components that can be used in different applications. Think about dropdowns, datepickers and empty modals. A <code>user-detail</code> component for instance does NOT belong here. A monorepo can contain multiple <code>ui-kit</code> libraries. We should name them according to its purpose. E.g <code>ui-kit-mobile</code> is a common use case.</p>

<p>The Ui-kit module contains an <code>ngModule</code> since we need it to declare and export our components/directives. The barrel file generally only exposes the <code>ngModule</code> since this is the vessel used to export the functionality.</p>

<p>However, a <code>ui-kit</code> might also export certain types in its barrel file‚Ä¶ Like <code>DatepickerConfiguration</code> or other <code>ui-kit</code> specific types.</p>

<h4 id="utils">utils</h4>

<p>This lib can contain all kinds of utilities. It could contain shared interceptors, guards, services and custom RxJS operators. Think about it als a framework toolbox that could benefit any application. We will NOT use an <code>ngModule</code> here for tree-shaking purposes.</p>

<p>A <code>utils</code> lib will not contain any components. But if it contains pipes or directives we might need an <code>ngModule</code> for that.</p>

<p>When your workspace is small, one single <code>utils</code> lib might suffice, but it could become a good idea to split these up when the <code>utils</code> lib gets to big.</p>

<p>After splitting up, the directory structure of our workspace might look like this:</p>
<ul>
  <li><code>apps</code></li>
  <li><code>libs</code>
    <ul>
      <li><code>feature</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>ui-kit</code></li>
      <li><code>utils</code>
        <ul>
          <li><code>rxjs-operators</code></li>
          <li><code>forms</code></li>
          <li><code>http</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Do note, that the <code>forms</code> lib would not contain any forms or forms configuration, but it would contain general form logic that can be shared across the workspace.</p>

<h3 id="prefixing-libs">Prefixing libs</h3>

<p>Because of the fact that <code>selector</code> names for components and directives should be unique, prefixing them in a monorepo is quite important. 
Since every project in the <code>angular.json</code> file has a <code>prefix</code> property, we could set that prefix for every project.</p>

<p>Let‚Äôs assume that we need a <code>feature/shared</code> lib called <code>messages</code> then we could generate that lib by running <code>ng g lib messages --prefix sh-mes</code> for instance. 
<code>sh-mes</code> would be the prefix and if we create a message component in this lib it would have the selector: <code>sh-mes-message</code>.</p>

<h2 id="linting-and-tags">Linting and tags</h2>

<p>One thing that is absolutely critical when managing a monorepo is being able to determine, categorize, and constrain/run commands based on a dependency graph.</p>

<p>Nx determines the dependency graph for us out of the box, it infers it by statically analyzing our TypeScript import and export statements (as well as a few other things specific to the Angular CLI).</p>

<p>It has no way of automatically categorizing the dependency graph for it, because that is up to our subjective judgement, but it does provide helpers to make it easy.</p>

<p>Nx provides us with the ability to add tags to the different libs and apps and apply <a href="https://palantir.github.io/tslint/">tslint</a> rules to make sure we can‚Äôt import whatever we want wherever we want.	Nx provides us with the ability to add tags to the different libs and apps and apply <a href="https://palantir.github.io/tslint/">tslint</a> rules to make sure we can‚Äôt import whatever we want wherever we want (potentially leading to circular references and other problems (broken lazyloading, etc‚Ä¶)).</p>

<p>Tags can be added to projects in the <code>nx.json</code> file of the root directory.
Tags can be determined in numerous ways. Some of us might like a tag per team, other might like it per domain.</p>

<p>I like to have tags for every lib type. It might be opinionated but it works fine for me (again, that‚Äôs a matter of personal preference)</p>

<p>We define 5 types of tags:</p>

<ul>
  <li><code>app</code>: This tag is added to all the apps</li>
  <li><code>shared</code>: This tag is added to <code>uikit</code> and <code>utils</code> libs</li>
  <li><code>feature:lazy</code>: This tag is added to <code>feature/lazy</code> libs</li>
  <li><code>feature:shared</code>: This tag is added to <code>feature/shared</code> libs</li>
  <li><code>feature:api</code>: This tag is added to <code>feature/api</code> libs</li>
</ul>

<p>The rules could be the same for every workspace that we will create in the future:</p>

<ul>
  <li>Projects with the type <code>tag</code> can only depend on projects with the tags: <code>shared</code> or <code>feature:shared</code>.</li>
  <li>Projects with the type <code>shared</code> can only depend on projects with the tags: <code>shared</code> (we don‚Äôt want to import domain specific logic in there do we?)</li>
  <li>Projects with the type <code>feature:lazy</code> can only depend on projects with the tags: <code>shared</code>, <code>feature:shared</code> and <code>feature:api</code>.</li>
  <li>Projects with the type: <code>feature:shared</code> can only depend on projects with the tags: <code>shared</code> and <code>feature:api</code>.</li>
  <li>Projects with the type: <code>feature:api</code> can only depend on projects with the tags: <code>feature:api</code> and <code>shared</code>. (we never want to load <code>feature:shared</code> into an feature/api lib right?)</li>
</ul>

<h3 id="configuring-tslint">Configuring tslint</h3>

<p>To configure the tslint we have to use the <code>nx-enforce-module-boundaries</code> rule from tslint. If you like the rules defined above, you can just copy-paste the module boundaries defined below right in your <code>tslint.json</code> file that lives in the root directory.</p>

<pre><code class="language-json">"nx-enforce-module-boundaries": [
  true,
    {
      "allow": [],
      "depConstraints": [
      {
        "sourceTag": "app",
        "onlyDependOnLibsWithTags": ["shared", "feature:shared"]
      },
      {
        "sourceTag": "shared",
        "onlyDependOnLibsWithTags": ["shared"]
      },
      {
        "sourceTag": "feature:lazy",
        "onlyDependOnLibsWithTags": [
          "shared",
          "feature:shared",
          "feature:api"
        ]
      },
      {
        "sourceTag": "feature:api",
        "onlyDependOnLibsWithTags": ["feature:api", "shared"]
      },
      {
        "sourceTag": "feature:shared",
        "onlyDependOnLibsWithTags": ["shared", "feature:api"]
      }
      ]
    }
]
</code></pre>

<p>This tslint config will ensure that the rules defined above are mandatory.</p>

<h2 id="is-this-structure-the-only-way">Is this structure the only way?</h2>

<p>No, not at all, this would work perfectly for a monorepo with 5 applications. But if we are thinking about organisation wide monorepos, it might be a good idea to
combine features app per app. In that case we would have something like:</p>
<ul>
  <li><code>apps</code></li>
  <li><code>libs</code>
    <ul>
      <li><code>app1</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>app2</code>
        <ul>
          <li><code>api</code>
            <ul>
              <li><code>foo</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>lazy</code>
            <ul>
              <li><code>bar</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
          <li><code>shared</code>
            <ul>
              <li><code>baz</code></li>
              <li>‚Ä¶</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code>ui-kit</code></li>
      <li><code>utils</code>
        <ul>
          <li><code>rxjs-operators</code></li>
          <li><code>forms</code></li>
          <li><code>http</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="how-to-share-code-organisation-wide">How to share code organisation wide?</h2>

<p>Although an organisation wide monorepo has great benefits, they might be good reasons not to do it. These could be any combination of technical, cultural, legal or other reasons.</p>

<h3 id="scenario-a">Scenario A</h3>

<p>Our company has 10 angular projects that are actively developed and share a lot of code, but also had 5 legacy projects where there is no budget to bump them to the new Angular versions and so on. There might be a few <a href="https://vuejs.org/">Vue.js</a> or <a href="https://reactjs.org/">React</a> living there as well. It might be more trouble than it is worth for your organization to manage that complexity within one big workspace. In that case we could have a workspace for the non-legacy angular projects, and that workspace would gladly welcome new projects in the future.</p>

<h3 id="scenario-b">Scenario B</h3>

<p>Our company sells custom software to different clients. Every client wants its own custom look and feel, which a lot of custom logic, but we don‚Äôt want to reinvent the wheel every time.</p>

<p>In that case, we could create an Nx worspace for every client, and have one common toolkit that contains shared logic. That toolkit would live in its own monorepo and be published as an Angular package.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I hope we learned something today. How we structure our workspaces is completely up to us, and we should use something that works for us, not just pick whatever you read in some blog article ;-). If this structure doesn‚Äôt make sense to you, that‚Äôs perfectly fine‚Ä¶ And I would love to hear your thoughts about this approach.</p>

<h2 id="special-thanks-to">Special thanks to</h2>

<p>Thanks to the people that have reviewed the article and gave great input!
I couldn‚Äôt have done it without you!</p>

<ul>
  <li><a href="https://twitter.com/beeman_nl">@beeman_nl</a></li>
  <li><a href="https://twitter.com/mrjameshenry">@MrJamesHenry</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Using nx-etc checkout feature</title>
	  <link>//using-nx-etc-checkout-feature/</link>
	  <author></author>
	  <pubDate>2018-10-14T00:00:00+02:00</pubDate>
	  <guid>//using-nx-etc-checkout-feature/</guid>
	  <description><![CDATA[
	     <p>Using <a href="https://nrwl.io/nx">Nx</a> we can build applications using a monorepo style of development. If your monorepo contains a lot of applications and libraries, the development process might be impacted a little.</p>

<h3 id="problems">Problems</h3>

<ul>
  <li>Looking for files becomes somewhat annoying as you can find lots of them, even for apps or libs that you are not working one.</li>
  <li>Opening up 20 apps and 50 libs in your IDE will impact its performance. While you might be only working on one or two apps.</li>
</ul>

<h3 id="solution">Solution</h3>

<p>Nx-etc has a checkout feature that uses sparse checkouts and some scripts from Nx to only checkout apps and libs you are currently working on.
You can find an overview of the lib in the video below.</p>

<iframe src="https://player.vimeo.com/video/295018577" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
<p><a href="https://vimeo.com/295018577">Using nx-etc checkout feature</a> from <a href="https://vimeo.com/user79085465">Kwinten Pisman</a> on <a href="https://vimeo.com">Vimeo</a>.</p>

<p>You can find the code on <a href="https://github.com/KwintenP/nx-etc">github</a>.</p>

<p><strong>Note:</strong> Thanks to <a href="https://twitter.com/juristr">@juristr</a>, <a href="https://twitter.com/beeman_nl">@beeman</a>, <a href="https://twitter.com/chaos_monster">@chaos_monster</a> and <a href="https://twitter.com/jvandemo">@jvandemo</a> for testing and providing feedback!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Redux (@ngrx/store) best practices</title>
	  <link>//Redux-best-practices/</link>
	  <author></author>
	  <pubDate>2018-04-27T00:00:00+02:00</pubDate>
	  <guid>//Redux-best-practices/</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">@ngrx/store</a> is a library that tries to solve the problems of state management through the principles of <a href="https://redux.js.org/">Redux</a>. The difference between Redux and @ngrx/store is that @ngrx/store is written specifically for <a href="https://angular.io">Angular</a> and it embraces the use of Observables from <a href="http://reactivex.io/rxjs/">RxJS</a>.
The combination of redux principles and RxJS can be very powerful when it comes to writing reactive applications.
Since a lot of Angular projects use @ngrx/store, it might be a good idea to write down some best-practices.</p>

<p>Note: The best-practices and opinions described in this article are strictly personal. Best practices are almost always a matter of opinion. Nevertheless, we (StrongBrew) are using these best practices at all our customers on a daily basis and they certainly work for us.   From now on @ngrx/store will be reffered to as Redux in this article.</p>

<h2 id="to-redux-or-not-to-redux">To Redux or not to Redux?</h2>

<p>The first question that we might want to ask ourselves is do we really need Redux in our application.
It is a best practice to only use it when your application demands it.
<a href="https://blog.strongbrew.io/do-we-really-need-redux">This article</a> tackles this question separately.</p>

<h2 id="basic-best-practices">Basic best practices</h2>

<p>While the following list might be common sense for an experienced Redux developer, let‚Äôs sum those up as a refreshment for the sake of completeness.</p>
<ul>
  <li>Our application can only count one store, otherwise it would become too complex</li>
  <li>Reducers have to be pure, this is a principle from functional programming which makes functions predictable and avoids side effects</li>
  <li>Immutable datastructures are very important to optimise change detection cycles and avoid unexpected behavior, therefore reducers should handle data in an immutable manner</li>
  <li>Reducers always have to return a value! So don‚Äôt forget to implement the default case of the switch statement to return the original state</li>
</ul>

<h2 id="dont-add-models-to-the-store">Don‚Äôt add models to the store</h2>

<p>A model can be seen as a javascript object which has functionality, like the following example:</p>

<pre><code class="language-typescript">class User{
    constructor(private firstName: string, private lastName:string){
    }

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`; 
    }
}
</code></pre>

<p>While the Redux package written by Dan Abramov forbids sending these prototyped objects as a payload, @ngrx/store does not forbid it yet.
However, it is a bad practice because it adds a lot of complexity to the store and chances are big that the models will get broken because of the immutable way of handling data. Check this example for instance:</p>

<pre><code class="language-typescript">const user = new User('Brecht', 'Billiet');
console.log(user.fullName); // Brecht Billiet
const updatedUser = {...user, lastName: 'Doe'};
console.log(updatedUser.fullName); // undefined
</code></pre>

<p>Since we have updated the user in an immutable way, it has created a new reference and therefore all its functionality has been lost.
This is exactly what our reducers will do with the data that flows into them. So always send plain objects when it comes to sending payloads in the actions.</p>

<p>Another approach for models is using Interfaces. Interfaces are great because are only interpreted in compile time, doesn‚Äôt use memory in runtime and are very expressive. If your model doesn‚Äôt need to be computed (like <code>get fullName()</code> in the previous example), then is advisable to use Interfaces instead.</p>

<p>Using Interfaces allows us to get advantage of some TypeScript features like <code>Pick&lt;T&gt;</code>. With <code>Pick&lt;T&gt;</code> we can create Types from Interfaces, which is very handy in some situations, like creating a model and a record with fewer properties:</p>

<pre><code class="language-typescript">export interface User {
    id: number;
    name: string;
    middleName: string;
    lastName: string;
    fullName: string;
    address: string;
    city: string;
    state: string;
    zip: string;
}

export type UserRecord = Pick&lt;User, 'id' | 'fullName'&gt;;
</code></pre>

<p>If the endpoint to get a list of users is returning a partial object instead of the full object then we can create a new Type instead of two Classes or Interfaces. This is a cleaner approach and easier to maintain if your models are prepared for your UI.</p>

<h2 id="what-do-we-put-in-the-store">What do we put in the store?</h2>

<p>We shouldn‚Äôt put things in the store just because we can. We have to think about what state needs to be in there and why.
State that is being shared between components can sometimes be kept in the parent component for instance. We call that inner state:
The component keeps its own state, the component itself is responsible for that. If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux.</p>

<p>However, when state needs to be shared between different root components (rendered inside a router-outlet) we might want to keep that state in the store.</p>

<p>When we need to remember a value when navigating through the application we could put that in the store as well. An example here could be: Remembering if a sidebar was collapsed or not, so when we navigate back to the page with the sidebar, it would still be collapsed.</p>

<p>Complex state is something that we might want to put in the store as well, since Redux can handle complex state management in an elegant way.
The general rule of thumb here could be, <strong>Only keep shared state, values that we want to remember and complex state in the store</strong>. Don‚Äôt add state in the store if we don‚Äôt need to, it would result in unneeded boilerplate and complexity.</p>

<p>That being said, there are 2 more reasons where we might want to add extra state into the store:</p>
<ul>
  <li>When we want to make our application real-time. Check out <a href="https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/">How we made our app real time in 6 lines of code</a>.</li>
  <li>When we want to do optimistic updates. Check out <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">Cancellable optimistic updates in Angular2 and Redux</a></li>
</ul>

<h2 id="dont-forget-about-router-params">Don‚Äôt forget about router params</h2>

<p>A common mistake is putting things inside the store that could easily be added in the url.
The benefit of keeping state in the url is:</p>

<ul>
  <li>We can use the browser navigation buttons</li>
  <li>We can bookmark the url</li>
  <li>We can share that url with other people</li>
</ul>

<p>If we can put simple things into the url, we should at least consider it.</p>

<h2 id="avoid-huge-lists">Avoid HUGE lists</h2>

<p>Redux can not be seen as a local in-memory database, so we can‚Äôt put all our data into the store for performance reasons.
Redux can be seen as an abstraction of state and data that our application needs at a certain time.</p>

<p>For instance if we have a list of 10000 users, we don‚Äôt want to put them all in the store. What we could do is keep track of a list of 500 users in the store, which the user can see at that specific time, and load more users on the background and update that buffered list.</p>

<h2 id="designing-the-state">Designing the state</h2>

<p>Designing the state of our application is an important step, and we recommend to draw that state on a whiteboard first. The most important rule here is: <strong>Keep the state as flat as possible</strong></p>

<p>One of the most common bad practices is deep-nesting the state into something that becomes rather complex:</p>

<pre><code class="language-typscript">
// this is an example of how not to design state
export interface ApplicationState {
    moduleA: {
        data: {
            foo: {
                bar: {
                    users: User[],
                    cars: Car[]
                }
            }
        }
    }
}  

// keeping it flat makes the application way easier
export interface ApplicationState {
    users: User[],
    cars: Car[]
}  
</code></pre>

<p>I‚Äôm not saying you cannot nest state, I am saying we have to be very careful when we do. The general rule of thumb here is: <strong>keep the state as flat as possible</strong>
If we want to compose state in @ngrx/store we can work with feature module reducers and lazy load them as we can see in <a href="https://github.com/ngrx/platform/blob/master/docs/store/api.md#feature-module-state-composition">Feature Module State Composition</a>.</p>

<h2 id="make-everything-readonly">Make everything readonly</h2>

<p>We already covered the reason why we need to work immutable, but how can we enforce this?
Typescript comes with a readonly keyword which we can use to make a property readonly</p>

<pre><code class="language-typescript">type User = {
    readonly firstName: string;
    readonly lastName: string;
}

const user: User = {firstName: 'Brecht', lastName: 'Billiet'};
user.lastName = 'Doe';//cannot assign to 'lastName' 
// because it is a constant of read-only property
</code></pre>

<p>This would certainly make sure we aren‚Äôt updating properties in our reducers by accident. It does suck that we have to write readonly for every property.
The cool thing is that typescript offers us something called ‚Äúadvanced types‚Äù where we can do something like this:</p>

<pre><code class="language-typescript">// By using the Readonly&lt;&gt; advanced types all the properties inside the type
// are readonly by default
type User = Readonly&lt;{
    firstName: string;
    lastName: string;
}&gt;;
</code></pre>

<h2 id="action-design">Action design</h2>

<h3 id="actiontypes">Actiontypes</h3>

<p>An action type should be a string that explains what the action should change in the store. Keep these strings consistent. Don‚Äôt make the actiontypes too long, keep them short and clear.</p>

<pre><code class="language-typescript">// This is bad
const DATA_USERS_SET_USER_ADDRESS = 'DATA_USERS_SET_USER_ADDRESS';

// This is better
const SET_USER_ADDRESS = 'SET_USER_ADDRESS';

</code></pre>

<p>Another cool idea might be to suffix the action with square brackets and put the whole thing into an action object:</p>

<pre><code class="language-typescript">
// Easy to read/debug
const UserActions = {
  SET_ADDRESS: '[USER] ADDRESS'
}

</code></pre>

<p>If the state managment would become very large we could prefix the action, but let‚Äôs keep it simple and small as long as we can.</p>

<h3 id="action-creator-classes">Action creator classes</h3>

<p>When we use plain action types and payloads it becomes quite painful to remember all the action type names and all the payloads that belong to them. This example for instance:</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(
    {
        type: 'SET_USER_ADDRESS', 
        payload: {user_id, address}
    });
</code></pre>

<p>That‚Äôs pretty nasty if we want remember all that stuff, so let‚Äôs create action creator classes for these. What if we could do this?</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(new SetUserAddressAction(user_id, address));
</code></pre>

<p>That‚Äôs just became way easier to use and we don‚Äôt have to remember the payload of the action.</p>

<p>If we wanted to implement the actioncreator class for this action it would look like this:</p>

<pre><code class="language-typescript">class SetUserAddressAction implements Action {
    type = SET_USER_ADDRESS;
    payload: {user_id: string, address: Address};
    constructor(user_id: string, address: Address){
        this.payload = {user_id, address};
    }
}
</code></pre>

<h3 id="payload-design">Payload design</h3>

<p>When the action would only have one property for the payload we might be encouraged to use the payload directly instead of creating a property in it. However that would lead to inconsistency, so it might be better to always use subproperties</p>

<pre><code class="language-typescript">// This is bad (inconsistent with the rest of the actions)
class UpdateUserAction implements Action {
    type = UPDATE_USER;
    payload: User;
    constructor(user: User){
        this.payload = user;
    }
}
// This is better
class UpdateUserAction implements Action{
    type = UPDATE_USER;
    payload: {user: User};
    constructor(user: User){
        this.payload = {user};
    }
}
</code></pre>

<h3 id="type-safety">Type Safety</h3>

<p>Type Safety is a huge win when using Redux with typescript, it requires a bit of boilerplate but it makes developing reducers feel like a walk in the park. It makes sure that our applications won‚Äôt compile if they have type errors and it gives us great autocompletion inside our reducers.
Therefore I would definitely consider it a must. Since <a href="https://twitter.com/KwintenP">Kwinten Pisman</a> already wrote an <a href="https://blog.strongbrew.io/type-safe-actions-in-reducers/">awesome article</a> about this we won‚Äôt go in to much detail here.</p>

<h2 id="reducer-design">Reducer design</h2>

<h3 id="destructuring-the-payload">Destructuring the payload</h3>

<p>If we want to make the reducer code more readable and shorter we could use javascript destructuring for that.
This might be personal preference, but it sure as hell makes our reducers easier to read. Take this example for instance:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS':
        return state.map(v =&gt; 
          v.id === action.payload.user_id ? 
          {...user, address: action.payload.address} : 
          v
        )
    }
}
</code></pre>
<p>The <code>action.payload.</code>code comes back a few times, resulting in longer codelines.
The following piece of code might be more readable:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS': {
        const {user_id, address} = action.payload;
        return state.map(v =&gt; 
          v.id === user_id ? 
          {...user, address} : 
          v
        )
      }
    }
}
</code></pre>

<p>As we can see have have used destructuring to extract the properties of the payload into variables.
Cleaner right? Let‚Äôs imagine that our actions has 5 or even more properties on their payloads. In that case this would definitely help.
Something to note here is that the case implementation is wrapped inside a block statement. This is important because our reducer can have the same payload properties for different actions.</p>

<p>This means that <code>user_id</code> and <code>address</code> won‚Äôt be available in the other case statements, which is exactly what we want.</p>

<h3 id="dont-write-business-logic-inside-our-reducers">Don‚Äôt write business logic inside our reducers</h3>

<p>Reducers should not contain business logic, they are used to handle the state in an immutable fashion. We won‚Äôt write business logic inside reducers because:</p>

<ul>
  <li>It would become very complex</li>
  <li>Business logic has nothing to do with state management</li>
  <li>We have services for that</li>
</ul>

<h3 id="child-reducers">Child reducers</h3>

<p>When reducers need to update a piece of state a few levels down in the tree it can become complex in no-time. Take this example for instance:</p>

<pre><code class="language-typescript">type User = {
    id: string;
    contracts: Contract[];
}
type Contract = {
    id: string;
    assignees: Assignee[];
}
type ApplicationState = {
    users: User[];
}   
...
</code></pre>

<p>If we would put all the logic to add an assignee to a specific contract of a specific user, the code would be hard to read. Checkout the following piece of code:</p>

<pre><code class="language-typescript">// This is bad
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: user.contracts.map(contract =&gt; 
            contract.id === contract_id ?
            {
              ...contract, 
              assignees: [...contract.assignees, assignee]
            } : 
            contract
          )
        } : 
        v
      )
    }
    default:
      return state;
  }
}
</code></pre>

<p>When reducers become complex it might be a good idea to split the reducer up into child reducers. Check the refactored version of the previous example:</p>

<pre><code class="language-typescript">// This is better
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: contractsReducer(contracts, action.payload)
        } : 
        v
      )
    }
    default:
      return state;
  }
}

function contractsReducer
  (state: Contract[], action: UserActions): Contract []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const { contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === contract_id ? 
        {
          ...contract, 
          assignees: [...assignees, assignee]
        } : 
        v
      )
    }
    default:
      return state;
  }
}

</code></pre>

<p>As we can see, we have extracted the handling of contracts into its own reducer, which follows the exact same principles of a regular reducer.</p>

<p>The example just became a lot easier to read and way more maintainable. When traversing complex data structures, reducer nesting can be a really elegant way of managing state.</p>

<h2 id="testing">Testing</h2>

<p>Since reducers are pure functions, unit testing them is very easy.
We won‚Äôt need to mock out any dependencies and we only have to test the value that the reducer returns.</p>

<p>We can also use <a href="https://www.npmjs.com/package/deep-freeze">deepfreeze</a> to freeze the state that when the reducer accidently mutates data, the tests will throw an error. Deepfreeze is nothing more than a recursive <code>Object.freeze</code></p>

<pre><code class="language-typescript">describe('reducer: usersReducer', () =&gt; {
  describe('case UPDATE_USER', () =&gt; {
    it('should return a new instance with the correct state', 
    () =&gt; {
      const initialState = [new User('1'), new User('2')];
      // deepfreeze makes sure the reducer 
      // doesn't mutate anything by accident
      deepfreeze(initialState); 
      const user = new User('2');
      const action = new UpdateUserAction(user);
      const newState = usersReducer(initialState, action);
      // check if the result of the array is a new ref
      expect(newState).not.toBe(initialState); 
      // check if the result of the user is a new ref
      expect(newState[1]).not.toBe(initialState[1]);
      // check if the user got updated automatically
      expect(newState[1]).toEqual(user);
    });
  });
});
  
</code></pre>

<p><strong>Note: Don‚Äôt forget to test the default action</strong></p>

<h2 id="decoupling-redux-from-the-presentation-layer">Decoupling redux from the presentation layer</h2>

<p>Having the store injected everywhere in our application is not a good idea. We want to create an Angular, Vue or React application. Not a Redux application.</p>

<p>Therefore we could consider the following as best practices:</p>
<ul>
  <li>Components don‚Äôt need to know we are using Redux, don‚Äôt inject the store in them.</li>
  <li>Services generally don‚Äôt need to know we are using Redux, don‚Äôt inject the store in them.</li>
  <li>We want to be able to refactor Redux away from our application without to much effort</li>
</ul>

<p>Therefore we want to have some kind of abstraction layer between the presentation layer and the state management layer.</p>

<p>How to abstract away the statemanagement layer can be read in the following two articles: <a href="https://blog.strongbrew.io/A-scalable-angular2-architecture/">A scalable angular architecture</a> and <a href="https://blog.strongbrew.io/A-scalable-angular-architecture-part2/">A scalable angular architecture part 2</a>.
This is an architecture that we are using at our customers that really works for us.</p>

<h2 id="redux-as-a-messaging-bus-vs-redux-as-a-state-management-layer">Redux as a messaging bus VS redux as a state management layer</h2>

<p>This might be a personal preference, but I like to use Redux as a pure state management layer. Yes, there are tools like @ngrx/effects where
we can send actions to our application and those actions won‚Äôt just perform state management but will do XHR calls among other things.</p>

<p>The nice thing about this approach is that we use some kind of messaging bus. However, I mostly like to keep it simple and abstract Redux away as much as possible. Therefore I don‚Äôt use @ngrx/effects and only use Redux to update pieces of state and consume theses pieces. Some part of me believes that Redux shouldn‚Äôt be used to perform backend calls nor decide when to optimistically update. I usually tackle optimistic updates <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">this way</a>.</p>

<p>That being said, I wouldn‚Äôt call my approach a best practice, but it is a best practice to really think about which way we want it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We learned a lot! Once again, the best practices explained in this article are based on personal experiences and projects we have worked on. These are practices that work for us. They are not meant to be seen as the only way of doing things.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>A very warm and much appreciated special thanks to the following people:</p>

<p><a href="https://twitter.com/ncjamieson">Nicholas Jamieson</a>, <a href="https://twitter.com/elecash">Ra√∫l Jim√©nez</a> and <a href="https://twitter.com/FabianGosebrink">Fabian Gosebrink</a>: Thank you all so much for reviewing and pointing out some awesome ideas</p>

<p>Your input makes blogging worth while!</p>

	  ]]></description>
	</item>

	<item>
	  <title>RxJS polling strategies</title>
	  <link>//rxjs-polling/</link>
	  <author></author>
	  <pubDate>2018-04-19T00:00:00+02:00</pubDate>
	  <guid>//rxjs-polling/</guid>
	  <description><![CDATA[
	     <p>Polling is a common scenario in a lot of Single Page Applications. We want our user to see the latest data without them taking any actions. In some scenarios, we might even want to display this data real time. In most cases however, this is overkill and requires changes at the backend of our application. Polling is a really good ‚Äònear immediate‚Äô alternative.</p>

<p>Polling is something where RxJS really shines. We will look at different polling strategies and how we can implement them.</p>

<p><strong>Note:</strong> The examples in this post will use Angular but the concepts can be ported everywhere.</p>

<ul>
  <li><a href="#simple-polling">Simple polling</a></li>
  <li><a href="#polling-and-refresh-button">Combining polling with refresh button</a></li>
  <li><a href="#polling-and-reset">Polling and reset</a></li>
  <li><a href="#polling-when-data-is-resolved">Polling when data is resolved</a></li>
</ul>

<h3 id="simple-polling">Simple polling</h3>

<p>First we will take a look at a simple example where we want to fetch new data every 5 seconds. Let‚Äôs first try and think about what we need.</p>

<ul>
  <li>a backend call</li>
  <li>a trigger that tells us when we need to execute our backend call</li>
</ul>

<h4 id="backend-call">Backend call</h4>

<p>Executing a backend call is easy. We can create a stream that will execute a backend call when subscribed to like this.</p>

<pre><code class="language-typescript">const bitcoin$ = this.http.get('https://blockchain.info/ticker');
</code></pre>

<h4 id="trigger">Trigger</h4>

<p>Next thing we need is a trigger that will tell us when it is time to fetch our data. In a world without RxJS we would probably use <code>setInterval</code>. This function allows us to pass it a callback that gets executed every ‚Äòx‚Äô seconds.
With RxJS however, we have to change the way we think. We can no longer think in terms of callbacks, we have to think in terms of streams. If we apply this to the trigger we need, we want a stream that fires every ‚Äòx‚Äô seconds. 
Drawn in a ASCII marble diagram, this is what we want:</p>

<pre><code>----1----2----3----4----5...
</code></pre>

<p>RxJS has a static <code>interval</code> function that will create this streams for us. We can pass it a number which will denote the time between the events.</p>

<pre><code class="language-typescript">const trigger$ = interval(1000);
</code></pre>

<p>This is not enough however. Our trigger stream should also trigger at start time. Otherwise, we would only fetch data after ‚Äò1000ms‚Äô (with the example above).</p>

<p>RxJS provides another static function, ‚Äòtimer‚Äô, that will help us to create the following stream:</p>

<pre><code>0----1----2----3----4----5...
</code></pre>

<p>Code wise, this looks like this:</p>

<pre><code class="language-typescript">const trigger$ = timer(0, 1000);
</code></pre>

<h4 id="combine-to-polling-stream">Combine to polling stream</h4>

<p>Now we have the two streams that we need, it is time to combine them. If we think about it, we basically want to re-execute our <code>bitcoin$</code> to refetch the data, every time our <code>trigger$</code> fires. We want to map our trigger value to another observable/async action. To do that, we need to use a flattening operator. As flattening operators are not part of this post, you can read more about them <a href="https://blog.angularindepth.com/switchmap-bugs-b6de69155524" target="_blank">here</a>.</p>

<p>In our case, we are going to use the <code>concatMap</code> operator. This operator will execute all the <code>bitcoin$</code> without cancelling them. Let‚Äôs take a look at the code:</p>

<pre><code class="language-typescript">this.polledBitcoin$ = timer(0, 1000).pipe(
        concatMap(_ =&gt; bitcoin$),
        map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      );
</code></pre>
<p>We create a new stream, <code>this.polledBitcoin$</code> by mapping every event that the <code>trigger$</code> emits to our <code>bitcoin$</code>. The <code>concatMap</code> operator will subscribe to the <code>bitcoin$</code> internally and emit the result of that stream as events on the <code>polledBitcoin$</code>.</p>

<p>When we draw this out into a ASCII marble diagram, it looks like this:</p>

<pre><code>bitcoin:            -(b|)
trigger$:           0------1------2------3------4------5...
                    \      \      \      \      \      \
                     -(b|)  -(b|)  -(b|)  -(b|)  -(b|)  -(b|)
 
 
polledBitcoin$     ----b------b------b------b------b------b 
</code></pre>

<p>We have our <code>bitcoin$</code> that will, when subscribed to, take some time, and then emit the event and complete.</p>

<p>We have our <code>trigger$</code> where we map the values to the <code>bitcoin$</code>. The <code>concatMap</code> operator flattens the result and we get our <code>polledBitcoin$</code>. A stream that will fetch the value of bitcoin every second.</p>

<p>The live example can be found here:</p>

<iframe style="width: 100%; height: 500px" src="https://stackblitz.com/edit/angular-abcqen?embed=1&amp;file=app/app.component.ts"></iframe>

<p><strong>Note:</strong> You can open the devtools on the network tab to see the network requests. There are other Stackblitz demos in this post so you might want to open it in Stackblitz to be sure that the network tab only shows requests from a single demo.</p>

<h3 id="polling-and-refresh-button">Polling and refresh button</h3>

<p>Sometimes, users can be pretty impatient and want to have the control to fetch the data. We can accomplish this by adding a button that, when clicked, will fetch the data as well. But we want also want to keep our polling.</p>

<p>Let‚Äôs first try to think reactive on how we can accomplish this. We already have a stream that polls the data. We can create a stream that fetches the data whenever the button is clicked. When we have both of these streams, we can actually just combine them using the <code>merge</code> operator to get one stream that is both triggered by the polling and the button click.</p>

<p>We can simply add a button to our example and a click listener. When the button is clicked, we need to convert this click into a stream, since we will need a stream to ‚Äòstart with‚Äô. For this we can leverage a <code>Subject</code>.</p>

<pre><code class="language-typescript">manualRefresh = new Subject();

refreshDataClick() {
    this.manualRefresh.next('');
}
</code></pre>

<p>Now that we have a stream that is fired every time the button is clicked, we can simply use the same way of working that we had before. But now, our ‚Äòsource‚Äô stream is not a <code>timer</code> but a <code>subject</code>.</p>

<pre><code class="language-typescript">this.manualRefresh
	.pipe(
       concatMap(_ =&gt; bitcoin$),
   );
</code></pre>

<p>Next thing we need to do is combine both of our streams that can trigger a backend call (and remove the double <code>concatMap</code> operator).</p>

<pre><code class="language-typescript">this.polledBitcoin$ = timer(0, 10000).pipe(
        merge(this.manualRefresh),
        concatMap(_ =&gt; bitcoin$),
        map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      );
</code></pre>

<p>That‚Äôs it. Now whenever the button is clicked or the timer triggers, a backend call will be done.</p>

<p>The live code example can be found here:</p>

<iframe src="https://stackblitz.com/edit/angular-zytccc?embed=1&amp;file=app/app.component.ts" style="height: 500px; width:100%"></iframe>

<h3 id="polling-and-reset">Polling and reset</h3>

<p>The previous polling strategy can introduce some unnecessary backend calls. Let‚Äôs think about the following scenario. Our timer stream triggers every 10s. After the app has started and has been running for 19s, the user clicks the button, triggering a backend call. And after 20s our timer stream fires as well, also triggering a backend call. This means that at both the 19th and the 20th second, we are fetching the data. This might be a little overkill.</p>

<p>Let‚Äôs think about how we can fix this. We already have a stream that will fetch the data immediately and then again and again with 10s in between. And actually, that‚Äôs all we need. When we have this stream, and the user clicks the button, we can just restart this stream. Since, when we restart this stream, we are fetching the data immediately (which is what we want when the user clicks), and again after 10 seconds. The ASCII marble diagram looks like this:</p>

<pre><code>bitcoin:            -(b|)
user clicks:                            C 
trigger$:           0------1------2-----!0------1------2-----|
                    \      \      \      \      \      \      
                     -(b|)  -(b|)  -(b|)  -(b|)  -(b|)  -(b|)
 
 
polledBitcoin$     ----b------b------b------b------b------b-- 
</code></pre>

<p><strong>Note:</strong> In ASCII marble diagrams, the ‚Äò!‚Äô means that the stream is unsubscribed from.</p>

<p>In the marble diagram above, ‚ÄòC‚Äô denotes the user click. In that case, we want to unsubscribe from the previous execution of our <code>trigger$</code> and execute it again. Let‚Äôs see how we can do this in the code:</p>

<pre><code>load$ = new BehaviorSubject('');

this.polledBitcoin$ = this.load$.pipe(
      switchMap(_ =&gt; timer(0, 10000).pipe(
         concatMap(_ =&gt; bitcoin$),
         map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      )
   )
);
</code></pre>
<p>First thing we need to change is move from a <code>Subject</code> to a <code>BehaviorSubject</code>. A <code>BehaviorSubject</code> has an initial value and will replay the last value when subscribed to. Here, we are interested in the fact that it has an initial value.</p>

<p>Next thing we do is use this subject to create our <code>polledBitcoin$</code>. We wrapped the stream from our previous examples in a <code>switchMap</code>. Whenever the <code>load$</code> emits, this stream will be started. If there was a previous execution still working, this execution will be stopped in favor of a new one. And that‚Äôs exactly what we need. Thanks to the initial value in the <code>BehaviorSubject</code>, we know that the stream will be started whenever the stream is initially subscribed to.</p>

<p>Now, whenever the user clicks on the reload button, the data will be fetched and the timer is reset! We can use this technique in different scenarios as well. For example, when the user swipes down on a mobile device. Nice right!</p>

<p>You can find the example code here:</p>
<iframe src="https://stackblitz.com/edit/angular-srtgmv" style="width: 100%; height: 500px"></iframe>

<h3 id="polling-when-data-is-resolved">Polling when data is resolved</h3>

<p>The last polling strategy I want to take a look at is one where we only start a next request after the first one has finished plus ‚Äòx‚Äô seconds. This can be helpful in some cases.</p>

<p>With the previous example in mind, Let‚Äôs say we poll every 5 seconds and at one point, our backend call takes 4 seconds. This would mean that, 1 second after we finally gotten our result, we fetch it again. This might not always be what we want.</p>

<p>Again, Let‚Äôs start by thinking about what we want in a reactive way. First of all, we need to know when our backend call has ended. When it has ended, we need to wait ‚Äòx‚Äô seconds before starting the next one. Let‚Äôs break it down.</p>

<p>Knowing when our backend call has ended is pretty easy. Whenever a value passes the <code>bitcoin$</code>, we know the backend call is done. After that has happened, we need to create a stream that, waits ‚Äòx‚Äô seconds and then triggers a new call. Let‚Äôs try and create a stream that, when subscribed to, waits 5 seconds, has the option to trigger a new call and then completes.</p>

<pre><code class="language-typescript">load$ = new BehaviorSubject('');

const whenToRefresh$ = of('').pipe(
      delay(5000),
      tap(_ =&gt; load$.next(''),
      skip(1),
);
</code></pre>

<p>We created a stream using the static <code>of</code>. This will fire an event immediately when subscribed to. We then delay this event with 5000ms by using the <code>delay</code> operator. We then use a <code>tap</code> where we can actually trigger the next request, and finally <code>skip</code> since we do not want to use the <code>''</code> event anywhere, it was just a trigger.</p>

<p>Next thing we need to do is integrate this into our other code. Let‚Äôs see how we can accomplish this:</p>

<pre><code class="language-typescript">const poll$ = concat(bitcoin$, whenToRefresh$);

this.polledBitcoin$ = this.load$.pipe(
  concatMap(_ =&gt; poll$),
  map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
);
</code></pre>

<p>We removed the <code>timer</code> operator here and replaced it with our <code>BehaviorSubject</code>. We changed our stream inside the <code>concatMap</code> operator. Here we used <code>concat</code> to combine the <code>bitcoin$</code> with our <code>whenToRefresh$</code> we created above. What <code>concat</code> does is, execute the <code>bitcoin$</code> first and whenever that one completes, starts the other stream.</p>

<p>This is ideal, since we need to wait for the <code>whenToRefresh$</code> to start till the backend call completes. When it completed, the <code>whenToRefresh$</code> is started and will wait 5000ms and then next the <code>load$</code> to start the whole thing again.</p>

<p>Drawn out into an ASCII marble diagram, it looks like this.</p>

<pre><code>bitcoin$:         -----(b|)
load$:       f-------------f-------------f....
(poll$)                    \
(poll$)      \              -----b-------N....
              -----b-------N
                   
                   
polledBitcoin$:   ------b-------------b-------....
</code></pre>

<p>We can see that, whenever the first backend call was started, we wait 5000ms (here an amount of ‚Äò-‚Äò) before next‚Äôing the <code>load$</code> to start the thing again.</p>

<p>A live example of the code can be found here:</p>

<iframe src="https://stackblitz.com/edit/angular-4nqhgq?embed=1&amp;file=src/app/app.component.ts" style="width: 100%; height: 500px"></iframe>

<p><strong>Note:</strong> to really see that the next call is only scheduled 5000ms after the previous one finished, you can use the network tab and throttle the network to ‚Äòslow 3g‚Äô.</p>

<h3 id="conclusion">Conclusion</h3>

<p>RxJS and polling is a match made in heaven. There a number of different ways to implement polling which all have there trade offs. Understanding the differences between the ones described above will get you a long way.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Nx on your CI, how does it work?</title>
	  <link>//how-nx-affected-apps-works/</link>
	  <author></author>
	  <pubDate>2018-03-13T00:00:00+01:00</pubDate>
	  <guid>//how-nx-affected-apps-works/</guid>
	  <description><![CDATA[
	     <p>Nx from Nrwl is a collection of tools that can help us build Angular applications using a monorepo. In essence, Nx is a set of <a href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" target="_blank">schematics</a> that work on top of the @angular/cli. These schematics can be used to create apps and libs inside of a single @angular/cli project. Having multiple apps is supported by default and Nx leverages this feature and makes the process a little easier.</p>

<p>This post however is not about the basic working of Nx. If you want to learn more about Nx itself, go to their official website <a href="https://nrwl.io/nx" target="_blank">here</a> or watch this <a target="_blank" href="https://www.youtube.com/watch?v=bMkKz8AedHc">very informative talk</a> by <a href="https://twitter.com/MrJamesHenry">James Henry</a> at NgVikings.</p>

<p>This post will cover a different aspect of Nx. When all our applications are in the same repository, this poses some problems for your CI environment. Whenever a PR is merged into the master, the CI environment must rebuild your applications and ideally publish them to your DEV environment. But how do we handle it if we have a lot of apps in the same monorepo and we only want to build the apps that were affected by a certain PR? Nx provides us with a script to handle this situation.</p>

<h2 id="problem-description">Problem description</h2>

<p>Let‚Äôs take a look at the following Nx workspace. It has 2 apps and 2 libs.</p>

<p><img src="https://www.dropbox.com/s/4qohmskumvwa8k2/Screenshot%202018-03-13%2019.04.20.png?raw=1" alt="nx-workspace-image" /></p>

<p>As we can see ‚Äòapp1‚Äô depends on ‚Äòlib1‚Äô and ‚Äòlib2‚Äô and ‚Äòapp2‚Äô only depends on ‚Äòlib1‚Äô. When we change something to ‚Äòlib2‚Äô we only need to rebuild our ‚Äòapp1‚Äô. Nx provides us with a script that will, based on two git commit hashes, tell us all the apps that need to be build. You can run the script like this:</p>

<pre><code class="language-bash">./node_modules/.bin/nx affected apps SHA1 SHA2
</code></pre>
<p>SHA1 is the previous commit hash and SHA2 is the next commit hash. If, in our example, we change something to lib2, this script will output:</p>

<pre><code class="language-typescript">app1
</code></pre>

<p>In this post, we will take a look at the script you can use for this and look at some code snippets to understand how it works.</p>

<h2 id="how-do-they-know-what-apps-to-build">How do they know what apps to build</h2>

<h3 id="knowing-what-files-are-changed">Knowing what files are changed</h3>

<p>To know the files that have changed, they leverage the <code>git diff</code> command. Let‚Äôs look at the code:</p>

<pre><code class="language-typescript">function getFilesFromShash(sha1: string, sha2: string): string[] {
  return execSync(`git diff --name-only ${sha1} ${sha2}`)
    .toString('utf-8')
    .split('\n')
    .map(a =&gt; a.trim())
    .filter(a =&gt; a.length &gt; 0);
}
</code></pre>

<p>The <code>git diff</code> command returns all the files that have changed between two commits. This is transformed into a list of files.</p>

<h3 id="knowing-the-apps-these-touched-files-belong-to">Knowing the apps these touched files belong to</h3>

<p>Now it is clear which files are touched, it‚Äôs time to identify the ‚Äòprojects‚Äô these files belong to. In the script, both Nx apps and libs are referenced to as projects. They implement this using the following code.</p>

<pre><code class="language-typescript">export function touchedProjects(projects: ProjectNode[], touchedFiles: string[]) {
  projects = normalizeProjects(projects);
  touchedFiles = normalizeFiles(touchedFiles);
  return touchedFiles.map(f =&gt; {
    const p = projects.filter(project =&gt; project.files.indexOf(f) &gt; -1)[0];
    return p ? p.name : null;
  });
}
</code></pre>
<p>This will give us all the projects that have files that have changed, a.k.a. the ‚ÄòtouchedProjects‚Äô.</p>

<h3 id="identifying-all-the-apps">Identifying all the apps</h3>

<p>Next step is identifying the different apps of the project. For this, they simply parse the ‚Äò.angular-cli.json‚Äô file which has an entry with all the apps. Notice that ‚Äòapps‚Äô in this context means entries in the ‚Äò.angular-cli.json‚Äô. Both the ‚Äòapps‚Äô and ‚Äòlibs‚Äô in Nx terminology are ‚Äòapps‚Äô in the ‚Äò.angular-cli.json‚Äô.</p>

<pre><code class="language-typescript">export function getAffectedApps(touchedFiles: string[]): string[] {
  const config = JSON.parse(fs.readFileSync('.angular-cli.json', 'utf-8'));
  const projects = getProjectNodes(config);
  
  ...
} 

export function getProjectNodes(config) {
  return (config.apps ? config.apps : []).filter(p =&gt; p.name !== '$workspaceRoot').map(p =&gt; {
    return {
      name: p.name,
      root: p.root,
      type: p.root.startsWith('apps/') ? ProjectType.app : ProjectType.lib,
      files: allFilesInDir(path.dirname(p.root))
    };
  });
}
</code></pre>
<p>They fetch all the apps, loop over them, and create an object containing information about this app:</p>
<ul>
  <li>the name</li>
  <li>the root folder</li>
  <li>is it a real App or a Lib</li>
  <li>all the files it holds.</li>
</ul>

<h3 id="knowing-the-dependencies-of-the-apps-and-libs">Knowing the dependencies of the apps and libs</h3>

<p>Now that the apps are identified and we know the files inside those apps, it‚Äôs time to identify the dependencies the apps have on the different libs in the Nx workspace. To do that, they loop over every file in every project and parse those files using typescript. Then they visit every typescript node and if they encounter an import declaration or a <code>loadChildren</code> property they call the <code>addDeppIfNeeded</code> method since these are indicators that we might have a dependency on a lib in the monorepo.</p>

<pre><code class="language-typescript"> private processAllFiles() {
    this.projects.forEach(p =&gt; {
      p.files.forEach(f =&gt; {
        this.processFile(p.name, f);
      });
    });
  }

  private processFile(projectName: string, filePath: string): void {
    if (path.extname(filePath) === '.ts') {
      const tsFile = ts.createSourceFile(filePath, this.fileRead(filePath), ts.ScriptTarget.Latest, true);
      this.processNode(projectName, tsFile);
    }
  }
  
private processNode(projectName: string, node: ts.Node): void {
    if (node.kind === ts.SyntaxKind.ImportDeclaration) {
      const imp = this.getStringLiteralValue((node as ts.ImportDeclaration).moduleSpecifier);
      this.addDepIfNeeded(imp, projectName, DependencyType.es6Import);
      return; // stop traversing downwards
    }

    if (node.kind === ts.SyntaxKind.PropertyAssignment) {
      const name = this.getPropertyAssignmentName((node as ts.PropertyAssignment).name);
      if (name === 'loadChildren') {
        const init = (node as ts.PropertyAssignment).initializer;
        if (init.kind === ts.SyntaxKind.StringLiteral) {
          const childrenExpr = this.getStringLiteralValue(init);
          this.addDepIfNeeded(childrenExpr, projectName, DependencyType.loadChildren);
          return; // stop traversing downwards
        }
      }
    }
    /**
     * Continue traversing down the AST from the current node
     */
    ts.forEachChild(node, child =&gt; this.processNode(projectName, child));
  }  
</code></pre>
<p>Let‚Äôs look at the ‚ÄòaddDepIfNeeded‚Äô method.</p>

<pre><code class="language-typescript"> private addDepIfNeeded(expr: string, projectName: string, depType: DependencyType) {
    const matchingProject = this.projectNames.filter(
      a =&gt;
        expr === `@${this.npmScope}/${a}` ||
        expr.startsWith(`@${this.npmScope}/${a}#`) ||
        expr.startsWith(`@${this.npmScope}/${a}/`)
    )[0];

    if (matchingProject) {
      this.deps[projectName].push({projectName: matchingProject, type: depType});
    }
  }
</code></pre>

<p>This method checks if the <code>loadChildren</code> property or the import declaration is linked to one of our own libs. In that case, we add the dependency to the list of dependencies per project using the ‚ÄòprojectName‚Äô identifier.</p>

<h3 id="putting-the-pieces-together">Putting the pieces together</h3>

<p>We found the files that were changed and to which projects they belong to. We figured out all the dependencies the different projects have. Now it just a matter of cross referencing these to figure out which ‚Äòapps‚Äô need to be rebuild. Let‚Äôs look at the code:</p>

<pre><code class="language-typescript">  if (tp.indexOf(null) &gt; -1) {
    return projects.filter(p =&gt; p.type === ProjectType.app).map(p =&gt; p.name);
  } else {
    return projects
    			.filter(p =&gt; p.type === ProjectType.app)
    			.map(p =&gt; p.name)
    			.filter(name =&gt; hasDependencyOnTouchedProjects(name, tp, deps, []));
  }
</code></pre>

<p>There is an interesting part in this snippet. There is a check to see if ‚Äònull‚Äô is in the ‚ÄòtouchedProjects‚Äô. This happens when there is a change to a file outside of the ‚Äòapps‚Äô or ‚Äòlibs‚Äô directory. This can happen if, for example, the package.json file has been updated. In that case, every ‚Äòapp‚Äô needs to be rebuild.</p>

<p>Finally, we can look at the <code>hasDependencyOnTouchedProjects</code> function.</p>

<pre><code class="language-typescript">function hasDependencyOnTouchedProjects(project: string, touchedProjects: string[], deps: { [projectName: string]: Dependency[] }, visisted: string[]) {
  if (touchedProjects.indexOf(project) &gt; -1) return true;
  if (visisted.indexOf(project) &gt; -1) return false;
  return deps[project]
  	.map(d =&gt; d.projectName)
  	.filter(k =&gt; 
  		hasDependencyOnTouchedProjects(
  			k, 
  			touchedProjects, 
  			deps, 
  			[...visisted, project]
  		)
  	).length &gt; 0;
}
</code></pre>

<p>Using recursion, they cross-reference the affected files and the projects they belong to with the dependencies all the projects have. This will return a list of all the apps that need to build.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Using git, typescript and a little javascript code, the guys at Nx created a script that can help us to only rebuild apps that are affected by a PR reducing the build time on our CI environments.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Pre-rendering Angular Applications</title>
	  <link>//prerendering-angular-apps/</link>
	  <author></author>
	  <pubDate>2018-03-04T00:00:00+01:00</pubDate>
	  <guid>//prerendering-angular-apps/</guid>
	  <description><![CDATA[
	     <h2 id="why-should-we-pre-render-angular-applications">Why should we pre-render Angular applications?</h2>

<p>At the moment of writing this article, there are several ways of optimizing Angular applications - We could compile them <a href="https://angular.io/guide/aot-compiler">ahead-of-time</a> through AOT compilation.
We could use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service workers</a> to optimize caching. And there are plenty of other PWA (progressive web app) features that can increase the quality and overall performance of our Angular applications.</p>

<p>However, there are a still a few problems that these optimizations won‚Äôt fix:</p>
<ul>
  <li><strong>SEO</strong> (search engine optimization): At the time of writing, SPAs (single-page applications) are harder to index by search engines because the content isn‚Äôt available on load time. Therefore, the application is likely to fail on several SEO requirements.</li>
  <li><strong>Initial page load</strong> could be faster: Since the application still needs to be bootstrapped after the page is loaded, there is an initial waiting time until the user can use the application. This results in a bad user experience.</li>
</ul>

<p>These two problems can be fixed by implementing <a href="https://angular.io/guide/universal">SSR (server-side rendering)</a>. SSR executes the Angular application on the server. That way the server will actually serve the compiled content in a way that search engine crawlers can read it. This is really the best of both worlds: The application will be rendered on the server, but when the JavaScript bundle is loaded, it will turn into a SPA. That way the application is rich and fast at the same time!</p>

<p>To optimize our <a href="https://strongbrew.io">StrongBrew</a> website, we started using this approach. It was pretty fast when we ran it locally. However, the StrongBrew website is hosted on <a href="https://firebase.google.com">Firebase</a> and the SSR part was hosted by Firebase functions.</p>

<p>We really love Firebase and everything it stands for, but for us, SSR on Firebase functions was just too slow. Sometimes it took 4 seconds to serve the content‚Ä¶ Since the loading time of a website is very important for keeping our visitors, we had to find another way to serve the content in a more effective manner.</p>

<p>SSR works like this: A user navigates to a URL =&gt; the server compiles the application and serves it.
But instead of compiling every route when the server receives a request, what if we could execute the SSR logic for every route at build time? That would certainly fix our problem.</p>

<p>That way we would run generated static HTML files, which is insanely fast, and when the JavaScript bundles are loaded, the browser would take over.
This also uses the best of both worlds: Ultra fast loading time + we don‚Äôt need to give up our rich SPA experience.
The result went from several seconds to 30 milliseconds.
<img src="/assets/images/posts/prerendering-angular-apps/ssr-vs-prerender.png" alt="SSR vs Prerender" /></p>

<p>This is a super fast and super effective improvement but it has one very important limitation.
<strong>It‚Äôs not possible to prerender dynamic content</strong>. The data in the StrongBrew website isn‚Äôt fetched by AJAX calls (at least not the data that has to be indexed). It rather works with simple webpack imports of JSON files. These are inserted at build time.</p>

<p>This does not mean that loading content dynamically isn‚Äôt possible at all, it just won‚Äôt get prerendered.</p>

<h2 id="lets-dive-in">Let‚Äôs dive in</h2>

<p>Enough chit chat! Let‚Äôs dive into some code.
I‚Äôve created this <a href="https://github.com/strongbrewio/prerender-angular-example">GitHub repository</a> just for you! It‚Äôs a simple website with a few pages and the build system doesn‚Äôt know how to pre-render yet.
Checkout the branch <code>runtime</code> by running the command <code>git checkout runtime</code>. When running <code>npm i &amp;&amp; npm run start</code>, the bash should install all the NPM dependencies and host the application on <code>http://localhost:4200</code>, just like any default Angular CLI application.</p>

<h3 id="installing-the-dependencies">Installing the dependencies</h3>

<p>Great! We have a running website, but nothing is pre-rendered yet.
The first thing we need to do is to install @angular/platform-server by running
<code>npm i @angular/platform-server -D</code>. This is the most important bundle for SSR. This module contains the basics to run the Angular application on the server.</p>

<h3 id="applying-the-server-transition">Applying the server transition</h3>

<p>Next, we need to update the <code>app.module.ts</code> to enable server transition. This will make sure that Angular takes over on the frontend when the JavaScript bundles are loaded.</p>

<pre><code class="language-typescript">// src/app/app.module.ts
@NgModule({
  ...
  imports: [
    BrowserModule.withServerTransition(
        // this is just the name of our application
        // configured in angular-cli.json
        { appId: 'prerender-angular-example' }
    ),
    ...
  ],
  ...
})
export class AppModule { }
</code></pre>

<h3 id="creating-the-prerender-module">Creating the prerender module</h3>

<p>Then, we need to create a specific prerender module that will use the AppModule we have just adjusted. Let‚Äôs create an <code>app.prerender.module.ts</code> where we can tell which component it has to bootstrap.</p>

<pre><code class="language-typescript">// src/app/app.prerender.module.ts
import { NgModule } from '@angular/core';
import { ServerModule, ServerTransferStateModule } from '@angular/platform-server';

import { AppModule } from './app.module';
import { AppComponent } from './app.component';

@NgModule({
  imports: [
    AppModule,
    ServerModule,
    ServerTransferStateModule
  ],
  bootstrap: [AppComponent]
})
export class AppPrerenderModule {
}
</code></pre>

<h3 id="defining-a-prerender-entrypoint">Defining a prerender entrypoint</h3>

<p>To use the SSR logic at build time, we need to have a specific bundle. Since the <code>main.ts</code> file is used to bootstrap the application for the browser, we also need a <code>main.prerender.ts</code> file that will be used to create the prerender bundle.
Let‚Äôs create that file, shall we?</p>

<pre><code class="language-typescript">// src/app/main.prerender.ts
import { enableProdMode } from '@angular/core';
export { AppPrerenderModule } from './app/app.prerender.module';

enableProdMode();
</code></pre>
<h3 id="a-prerender-tsconfigjson">A prerender tsconfig.json</h3>

<p>We are almost there, I promise, but we need a few more things. We need a specific <strong>tsconfig</strong> file that compiles the bundle to something that the node server can read. It‚Äôs important for the compiler to compile to a <strong>commonjs</strong> package. This is because node.js uses this by default. So we need to create a <code>tsconfig.prerender.json</code> file:</p>

<pre><code class="language-json">/* src/tsconfig.prerender.json */
{
  "extends": "./tsconfig.app.json",
  "compilerOptions": {
    "outDir": "../out-tsc/prerender",
    /* node only understands commonjs for now*/
    "module": "commonjs"
  },
  "exclude": [
    "test.ts",
    "**/*.spec.ts"
  ],
  /* Additional informations to bootstrap Angular */
  "angularCompilerOptions": {
    "entryModule": "app/app.prerender.module#AppPrerenderModule"
  }
}

</code></pre>

<h3 id="letting-angular-cli-know-and-generating-the-bundle">Letting Angular CLI know and generating the bundle</h3>

<p>In the apps entry of the <code>angular-cli.json</code> file, we need to add a new app where we refer to the <code>main.prerender.ts</code> file and the <code>tsconfig.prerender.json</code> file. The app section should look like this:</p>

<pre><code class="language-json">{
      "name": "prerender",
      "platform": "server",
      "root": "src",
      "outDir": "dist-prerender",
      "main": "main.prerender.ts",
      "tsconfig": "tsconfig.prerender.json",
      "environmentSource": "environments/environment.ts",
      "environments": {
        "dev": "environments/environment.ts",
        "prod": "environments/environment.prod.ts"
      }
    }
</code></pre>

<p>Update the package JSON so it builds both the normal package and the server package. Set the <strong>output-hashing</strong> to none so that the build generates a clean <code>main.bundle.js</code> without any hash.</p>
<pre><code>    "build": "ng build --prod &amp;&amp; ng build --prod --app prerender --output-hashing=none",
</code></pre>
<p>When running <code>npm run build</code> the following files should be created:</p>
<ul>
  <li>dist (this contains the normal build)</li>
  <li><code>dist-prerender/main.bundle.js</code></li>
</ul>

<p>This <code>main.bundle.js</code> file exports a module called <code>AppPrerenderModuleNgFactory</code>. This is the module that we can use to pre-render the whole thing.</p>

<h2 id="generating-the-static-files">Generating the static files</h2>

<p>We have just generated the <code>main.bundle.js</code>, the file that we need to perform server-side rendering. However we don‚Äôt want to do server-side rendering in this case, we want to <strong>pre-render</strong> the html at build time. To do that we need a script that will complete the following steps.</p>

<ul>
  <li>Create an array with routes (we could automate this if we want)</li>
  <li>Loop over that array and for every entry:
    <ul>
      <li>create a folder in the dist map with that route name</li>
      <li>use the <code>main.bundle.js</code> to render the html and store that html as an <code>index.html</code> in the folder we just created.</li>
      <li>Overwrite the <code>dist/index.html</code> file.</li>
    </ul>
  </li>
</ul>

<p>Let‚Äôs call that script <code>prerender.ts</code>. Since I‚Äôm a typescript enthusiast, I want to develop the prerender script in typescript and use <a href="https://www.npmjs.com/package/ts-node">ts-node</a> to run it.
We can start with creating an empty <code>prerender.ts</code> file in the root folder and installing ts-node with <code>npm i -D ts-node</code></p>

<p>Now we can update the scripts section of the package.json so that the render function is called when the build is completed:</p>

<pre><code class="language-json"> "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build --prod &amp;&amp; ng build --prod --app prerender --output-hashing=none",
    "postbuild": "npm run render",
    "render": "ts-node prerender.ts",
    ...
  },
</code></pre>

<p>The only puzzle piece that is still missing is implementing the <code>prerender.ts</code> file.</p>

<h3 id="completing-the-prerenderts-file">Completing the prerender.ts file</h3>

<p>The following code should be self-explanatory:</p>

<pre><code class="language-typescript">import 'zone.js/dist/zone-node';
import * as path from 'path';
import * as fs from 'fs';
import { enableProdMode } from '@angular/core';
import { renderModuleFactory } from '@angular/platform-server';
import { AppPrerenderModuleNgFactory } from './dist-prerender/main.bundle';

const distFolder = './dist';
const index = fs
    .readFileSync(path.resolve(__dirname, `${distFolder}/index.html`), 'utf8')
    .toString();

// we could automate this based on the app.routes.ts file but
// to keep it simple let's just create an array with the routes we want
// to prerender
const paths = [
    '/about',
    '/brews',
    '/consultancy'];
enableProdMode();

// for every route render the html and save it in the correct folder
paths.forEach(p =&gt; renderToHtml(p, distFolder + p));

// don't forget to overwrite the index.html as well
renderToHtml('/index.html', distFolder);

function renderToHtml(url: string, folderPath: string): void {
  // Render the module with the correct url just 
  // as the server would do
  renderModuleFactory(AppPrerenderModuleNgFactory, {
    url,
    document: index
  }).then(html =&gt; {
    // create the route directory
    if (url !== '/index.html') {
    fs.mkdirSync(folderPath);
    }
    fs.writeFile(folderPath + '/index.html', html,  (err =&gt;  {
      if (err) {
        throw err;
      }
      console.log(`success`);
    });
  });
}

</code></pre>
<h3 id="testing-the-pre-rendered-application">Testing the pre-rendered application</h3>

<p>To test the website, we can build the project with <code>npm run build</code>. To serve it, we can use http-server. We can install http-server by running <code>npm i -g http-server</code>. By navigating into the <code>dist</code> directory and running <code>http-server</code>, the application will be hosted on port 8080.</p>

<p>If we navigate to http://localhost:8080 in the browser, we will see the pre-rendered application. We can test the SPA experience by navigating between the different pages and we can test the pre-rendered part by looking at the source code.</p>

<p><img src="/assets/images/posts/prerendering-angular-apps/sourcecode.png" alt="SSR sourcecode" /></p>

<h2 id="closing-words">Closing words</h2>

<p>I hope you liked this article and learned something.
We can find the full pre-rendered version by checking out branch <code>prerendered</code> by running <code>git checkout prerendered</code>. To test this example, checkout the previous section.</p>

<p>Note: to optimize the HTML even more, we could use an HTML minifier like <a href="https://www.npmjs.com/package/html-minifier">this one</a> to shrink the HTML where possible. The example could look something like this:</p>

<pre><code class="language-typescript">const minify = require('html-minifier').minify;
function renderToHtml(url: string, folderPath: string): void {
    // Render the module with the correct url just 
    // as the server would do
    renderModuleFactory(AppPrerenderModuleNgFactory, {
        url,
        document: index
    }).then(html =&gt; {
        ...
        // minify the html
        fs.writeFile(folderPath + '/index.html', minify(html),  (err =&gt;  {
          ...
        });
    });
}
</code></pre>

<h2 id="special-thanks">Special thanks</h2>

<p>A very special thanks to the awesome people that have helped me with their reviews:</p>

<ul>
  <li>Laurant Duveau <a href="https://twitter.com/laurentduveau">@laurentduveau</a></li>
  <li>Dominic Elm <a href="https://twitter.com/elmd_">@elmd_</a></li>
  <li>Sam Vloeberghs <a href="https://twitter.com/samvloeberghs">@samvloeberghs</a></li>
  <li>Ana Cidre <a href="https://twitter.com/anacidre_">@AnaCidre_</a></li>
  <li>Ruben Vermeulen <a href="https://twitter.com/CrushTheButton">@CrushTheButton</a></li>
  <li>Klaas Cuvelier <a href="https://twitter.com/klaascuvelier">@klaascuvelier</a></li>
</ul>

<h2 id="sources">Sources</h2>

<p><a href="https://hackernoon.com/deploy-angular-universal-w-firebase-ad70ea2413a1">deploy angular universal with firebase</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Displaying components based on the role of a user</title>
	  <link>//display-a-component-based-on-role/</link>
	  <author></author>
	  <pubDate>2018-01-15T00:00:00+01:00</pubDate>
	  <guid>//display-a-component-based-on-role/</guid>
	  <description><![CDATA[
	     <p>At some moment in time, almost every application will have certain parts that need to be restricted to users with the proper roles. When we need to protect a certain route from unauthorized access, Angular provides us with a guard.</p>

<p>But what if it‚Äôs only a single component that cannot be rendered when the user does not have the proper role? Angular does not provide something out of the box for this. Luckily this is something we can easily implement using directives.</p>

<iframe src="https://player.vimeo.com/video/251380600" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>

<h3 id="defining-what-we-want">Defining what we want</h3>
<p>We want to create a directive that accepts a role. This is the role the user must have to see this specific component.
It might look something like this:</p>

<pre><code class="language-html">&lt;app-normal-users-can-view *appHasRole="'user'"&gt;
&lt;/app-normal-users-can-view&gt;
</code></pre>

<h3 id="defining-how-it-should-work">Defining how it should work</h3>

<p>Let‚Äôs define the characteristics for our directive:</p>
<ul>
  <li>If the user has the proper role, the component should be shown.</li>
  <li>If the user does not have the proper role, the component shouldn‚Äôt be added to the DOM.</li>
</ul>

<p>If you think about it, that‚Äôs pretty much what an <code>*ngIf</code> directive does. Based on a certain condition, a component or native element must be added to the DOM or removed from the DOM.</p>

<h3 id="what-does-our-directive-need-to-make-it-work">What does our directive need to make it work?</h3>
<p>Our directive needs several things to make it work properly. First of all, we need a reference to the element that needs to be added to the DOM. On a secondary note, we need a place where we can insert the element to the DOM if needed. And lastly, we need to know the roles the user has.</p>

<h4 id="getting-a-reference-to-the-element-that-needs-to-be-added">Getting a reference to the element that needs to be added</h4>

<p>To get a reference to the element we need to add, we can use a ‚Äòtemplate directive‚Äô (or <a href="https://angular.io/guide/structural-directives" target="blank">structural directive</a>). We can make any directive a ‚Äòtemplate directive‚Äô by prefixing the directive with an asterisk (<code>*</code>) when we use it. This is syntactic sugar for the angular compiler. If we do this, this is what the compiler actually sees:</p>

<pre><code class="language-html">&lt;!-- what we write --&gt;
&lt;app-normal-users-can-view *appHasRole="'user'"&gt;
&lt;/app-normal-users-can-view&gt;

&lt;!-- how the compiler interprets it --&gt;
&lt;ng-template [appHasRole]="'user'"&gt;
      &lt;app-normal-users-can-view&gt;&lt;/app-normal-users-can-view&gt;
&lt;/ng-template&gt;
</code></pre>

<p>We can see that the compiler puts our directive onto an <code>ng-template</code>. This is ideal because it allows our directive to inject the <code>TemplateRef</code> containing the element we need to add (if the user has the role), which is what we want.</p>

<h4 id="finding-the-dom-entry-point">Finding the DOM entry point</h4>
<p>To know where we can inject the <code>TemplateRef</code>, our directive can just inject the <code>ViewContainerRef</code>. This represents the container where we can attach one or more views. For more information on the <code>ViewContainerRef</code> you can read <a href="https://netbasal.com/angular-2-understanding-viewcontainerref-acc183f3b682" target="blank">this</a> post.</p>

<h4 id="knowing-the-roles-a-user-has">Knowing the roles a user has</h4>
<p>To know the roles a certain user has, we could leverage a service (in the example code <code>rolesService</code>) that exposes a stream with all the roles that user has.</p>

<h3 id="the-hasrole-directive-end-result">The hasRole directive end result</h3>
<p>Now that we have identified all the different things we need to properly implement our directive, we can start. See the comments for more information.</p>

<pre><code class="language-typescript">@Directive({
  selector: '[appHasRole]'
})
export class HasRoleDirective implements OnInit, OnDestroy {
  // the role the user must have 
  @Input() appHasRole: string;

  stop$ = new Subject();

  isVisible = false;

  /**
   * @param {ViewContainerRef} viewContainerRef 
   * 	-- the location where we need to render the templateRef
   * @param {TemplateRef&lt;any&gt;} templateRef 
   *   -- the templateRef to be potentially rendered
   * @param {RolesService} rolesService 
   *   -- will give us access to the roles a user has
   */
  constructor(
    private viewContainerRef: ViewContainerRef,
    private templateRef: TemplateRef&lt;any&gt;,
    private rolesService: RolesService
  ) {}

  ngOnInit() {
    //  We subscribe to the roles$ to know the roles the user has
    this.rolesService.roles$.pipe(
    	takeUntil(this.stop$)
    ).subscribe(roles =&gt; {
      // If he doesn't have any roles, we clear the viewContainerRef
      if (!roles) {
        this.viewContainerRef.clear();
      }
      // If the user has the role needed to 
      // render this component we can add it
      if (roles.includes(this.appHasRole)) {
        // If it is already visible (which can happen if
        // his roles changed) we do not need to add it a second time
        if (!this.isVisible) {
          // We update the `isVisible` property and add the 
          // templateRef to the view using the 
          // 'createEmbeddedView' method of the viewContainerRef
          this.isVisible = true;
          this.viewContainerRef.createEmbeddedView(this.templateRef);
        }
      } else {
        // If the user does not have the role, 
        // we update the `isVisible` property and clear
        // the contents of the viewContainerRef
        this.isVisible = false;
        this.viewContainerRef.clear();
      }
    });
  }
  
  // Clear the subscription on destroy
  ngOnDestroy() {
    this.stop$.next();
  }
}

</code></pre>
<p>You can find the full source code <a href="https://github.com/KwintenP/display-or-hide-components-based-on-role" target="_blank">here</a>. You can play with a live example <a href="" target="_blank">here</a>. You can change the roles on top by clicking the checkboxes. If a role is granted, a new element is added to the DOM.</p>

<h3 id="conclusion">Conclusion</h3>
<p>Leveraging a few somewhat more advanced concepts as ‚Äòtemplate directives‚Äô, <code>viewContainerRef</code> and <code>TemplateRef</code>, we were able to easily implement our own <code>*ngIf</code> like directive that works based on the roles with a limited amount of code.</p>

<p><strong>Note:</strong> In this example I‚Äôm using roles. Applying a role based strategy for authorization poses some problems. There will always be cases where a user should have role ‚ÄòX‚Äô but should also be able to see a portion of the functionality that users with role ‚ÄòY‚Äô see. In that case, you would have to create a new role, ‚ÄòZ‚Äô, that holds properties of ‚ÄòX‚Äô and ‚ÄòY‚Äô.</p>

<p>In growing applications, this will mean a lot of roles, that might be only used by a single person. With that in mind, it‚Äôs always better to give the user certain ‚Äòrights‚Äô. If the user can see the ‚ÄòUser management‚Äô part of the application, he should have the ‚Äòright‚Äô ‚Äòuser_mgmt‚Äô for example. Using ‚Äòrights‚Äô avoids the problem described above with the roles.</p>

	  ]]></description>
	</item>

	<item>
	  <title>RxJS best practices in Angular</title>
	  <link>//rxjs-best-practices-in-angular/</link>
	  <author></author>
	  <pubDate>2018-01-04T00:00:00+01:00</pubDate>
	  <guid>//rxjs-best-practices-in-angular/</guid>
	  <description><![CDATA[
	     <p>This article is all about the do‚Äôs and don‚Äôts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#pipeable-operators">Pipeable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don‚Äôt pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don‚Äôt pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code>$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code>$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="pipeable-operators">Pipeable operators</h2>

<p>The first best practice is the use of pipeable operators. The operators being used in this article are pipeable.
Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about pipeable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<pre><code class="language-typescript">// BAD: This is the old way and should be avoided (patch operators)
// as we can see the operators (filter, map) are part of the
// Observable prototype
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
const new$ = Observable.interval$
    .filter(v =&gt; v % 2 === 0)
    .map(v =&gt; v * 2);

// GOOD: This is the new and improved way (lettable operators)
// we just use the pipe operator where we pass operators that
// we can import from 'rxjs/operators'
import {filter, map} from 'rxjs/operators';
const new$ = interval$
    .pipe(
        filter(v =&gt; v % 2 === 0),
        map(v =&gt; v *2)
    )
</code></pre>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: ‚ÄúGreat code should be self-explanatory, writing documentation is something that we might want to avoid.‚Äù
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it‚Äôs hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it‚Äôs supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<pre><code class="language-typescript">// ---a--b--c--d---e---...
// ---a--b--c--d---e|
// ---a--b--c--d---e#
// ---a--b-^-c--d---e
</code></pre>
<ul>
  <li><code>-</code> (stands for a time frame)</li>
  <li><code>a-z</code> (are the values that are next‚Äôed in the stream)</li>
  <li><code>|</code> (indicates that the stream has completed)</li>
  <li><code>...</code> (indicates that the stream will keep on living)</li>
  <li><code>#</code> (indicates that an error occurred)</li>
  <li><code>^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it‚Äôs time to check a real example and how we might document it:</p>

<pre><code class="language-typescript">const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
const new$ = interval$
    .pipe(
        skip(1),                            // ---1--2--3--4--5--6...
        take(5),                            // ---1--2--3--4--5|
        filter(v =&gt; v % 2 === 0),           // ------2-----4---|
        map(v =&gt; v + 1)                     // ------3-----5---|
    )
</code></pre>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it‚Äôs fairly easy to comprehend what happens, and how every operator affects the <code>new$</code> stream we can see above. There is no ‚Äúone way of doing things‚Äù when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn‚Äôt mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn‚Äôt have any side effects. It can‚Äôt mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren‚Äôt fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit {
   ngOnInit() {
        // The following stream will produce values every second
        // 0--1--2--3--4--5--6--...
        const interval$ = interval(1000);
        // Even when this component gets destroyed,
        // the stream will keep producing values...
        // This means the console will keep on logging
        // This is a classic example of a memory-leak
        const subscription = interval$.subscribe(r =&gt; console.log(r));
    }
}
</code></pre>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    subscriptions = [];
    ngOnInit() {
        const interval$ = interval(1000);
        const subscription = interval$.subscribe(r =&gt; console.log(r));
        // manually keep track of the subscriptions in a subscription array
        this.subscriptions.push(subscription);
    }

    ngOnDestroy() {
        // when the component get's destroyed, unsubscribe all the subscriptions
        this.subscriptions.forEach(sub =&gt; sub.unsubscribe());
    }
}
</code></pre>

<p>However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    destroy$ = new Subject();
    ngOnInit() {
        // interval$: 0--1--2--3--4--5--6--...
        // destroy$:  -------------true|
        // result:    0--1--2--3--4|
        const interval$ = interval(1000);
        interval$
            // let the interval$ stream live 
            // until the destroy$ Subject gets a value
            .pipe(takeUntil(this.destroy$))
            .subscribe(r =&gt; console.log(r));
    }

    ngOnDestroy() {
        // when the component get's destroyed, pass something to the
        // destroy$ Subject
        this.destroy$.next(true);
    }
}
</code></pre>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService)
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // VERY BAD: nesting subscribes is ugly and takes away
        // the control over a stream
        this.route.params
            .pipe(map(v =&gt; v.id))
            .subscribe(id =&gt; 
                this.userService.fetchById(id)
                    .subscribe(user =&gt; this.user = user))
    }
}
</code></pre>

<p>The previous implementation is considered a bad-practice. It‚Äôs recommended to use <strong>higher-order streams</strong> like <code>mergeMap</code> or <code>switchMap</code>. Let‚Äôs have a look at this example:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) 
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // GOOD: we have created a single subscribe which makes
        // the flow way easier and gives us the control we need
        this.route.params
            .pipe(
                map(v =&gt; v.id),
                switchMap(id =&gt; this.userService.fetchById(id))
            )
            .subscribe(user =&gt; this.user = user)
    }
}
</code></pre>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that‚Äôs simply how observables work. But what if a component needs values from 5 different streams‚Ä¶ Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code>async pipe</code>. It‚Äôs used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don‚Äôt have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let‚Äôs have a look at the cleaned up previous example:</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // expose a user$ stream that will be 
    // subscribed in the template with the async pipe
    user$ = this.route.params.pipe(
        map(v =&gt; v.id),
        switchMap(id =&gt; this.userService.fetchById(id))
    );

    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) {
    }
}
</code></pre>

<p>If you are into <a href="https://reactjs.org/">React</a>, I‚Äôve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don‚Äôt pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That‚Äôs the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // this http call will get called when the 
    // user-detail component subscribes to users$
    // We don't want that
    users$ = this.http.get(...);
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent implements OnInit {
    @Input() user$: Observable&lt;User&gt;;
    user: User;
    ngOnInit(){
        // WHOOPS! This child component subscribes to the stream
        // of the parent component which will do an automatic XHR call
        // because Angular HTTP returns a cold stream
        this.user$.subscribe(u =&gt; this.user = u);
    }
}
</code></pre>

<p>It would be better to handle the subscription in the parent component itself:</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent implements OnInit {
    users$: Observable&lt;User[]&gt; = this.http.get(...);
    user: User;
    ngOnInit(){
        // the app component (smart) subscribes to the user$ which will
        // do an XHR call here
        this.users$ = this.http.get(...);
    }
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent {
    // This component doesn't even know that we are using RxJS which
    // results in better decoupling
    @Input() user: User;
}
</code></pre>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don‚Äôt pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don‚Äôt know what‚Äôs going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don‚Äôt care that your components are using streams. Take this example for instance:</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
class AppComponent {
     users$ = this.http.get(...)
     filteredusers$ = this.fooService
        .filterUsers(this.users$); // Passing stream directly: BAD
    ...
}

// foo.service.ts
class FooService {
    // return a stream based on a stream
    // BAD! because we don't know what will happen here
    filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; {
        return users$.pipe(
            map(users =&gt; users.filter(user =&gt; user.age &gt;= 18))
    }
}
</code></pre>

<p>It would be better to use higher order streams for these situations.
Use <code>switchMap</code> over <code>mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
class AppComponent {
    users$ = this.http.get(...)
    filteredusers$ = this.users$
        .pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));
    ...
}

// foo.service.ts
class FooService {
    // this is way cleaner: this service doesn't even know
    // about streams now
    filterUsers(users: User[]): User[] {
        return users.filter(user =&gt; user.age &gt;= 18);
    }
}
</code></pre>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code>http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code>numberOfUsers$</code> depends on <code>users$</code>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// BAD
class AppComponent {
    users$ = this.http.get(...)
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>In those cases we might want to share the subscriptions. The following example uses the <code>share()</code> operator:</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// GOOD
class AppComponent {
    users$ = this.http.get(...).pipe(share());
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code>shareReplay(1)</code> instead of <code>share()</code>. This will keep the last value in memory for us.</p>

<p>It‚Äôs a common mistake to share everything. We don‚Äôt always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code>async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `
})
class AppComponent {
    // This stream will only subscribed to once
    users$ = this.http.get(...);
}
</code></pre>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn‚Äôt make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it‚Äôs ok to use Subjects in the following scenarios:</p>
<h4 id="when-mocking-streams-in-tests">When mocking streams in tests</h4>

<pre><code class="language-typescript">const fetchAll$ = new Subject(); // use a Subject as a mock
usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
fetchAll$.next(fakeUser);
</code></pre>

<h4 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h4>

<pre><code class="language-typescript">@Component({
    ...
    template: `
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `
})
class AppComponent {
search$ = new Subject(); // ----t-----te-----ter----term...
}
</code></pre>

<h4 id="when-handling-circular-references">When handling circular references</h4>

<p>I‚Äôm not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code>getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<pre><code class="language-typescript">    foo$.pipe(
        map(...)
        filter(...)
        tap(...)
    )
</code></pre>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that‚Äôs personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it‚Äôs recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code>ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code>Form</code> and <code>FormControl</code> both have a <code>valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code>ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the ‚ÄúAdvanced RxJS in Angular workshop‚Äù from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>

	  ]]></description>
	</item>


</channel>
</rss>
