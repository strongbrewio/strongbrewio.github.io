<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link></link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Redux (@ngrx/store) best practices</title>
	  <link>//Redux-best-practices/</link>
	  <author></author>
	  <pubDate>2018-04-27T00:00:00+00:00</pubDate>
	  <guid>//Redux-best-practices/</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/ngrx/platform/blob/master/docs/store/README.md">@ngrx/store</a> is a library that tries to solve the problems of state management through the principles of <a href="https://redux.js.org/">Redux</a>. The difference between Redux and @ngrx/store is that @ngrx/store is written specifically for <a href="https://angular.io">Angular</a> and it embraces the use of Observables from <a href="http://reactivex.io/rxjs/">RxJS</a>.
The combination of redux principles and RxJS can be very powerful when it comes to writing reactive applications.
Since a lot of Angular projects use @ngrx/store, it might be a good idea to write down some best-practices.</p>

<p>Note: The best-practices and opinions described in this article are strictly personal. Best practices are almost always a matter of opinion. Nevertheless, we (StrongBrew) are using these best practices at all our customers on a daily basis and they certainly work for us.   From now on @ngrx/store will be reffered to as Redux in this article.</p>

<h2 id="to-redux-or-not-to-redux">To Redux or not to Redux?</h2>

<p>The first question that we might want to ask ourselves is do we really need Redux in our application.
It is a best practice to only use it when your application demands it.
<a href="https://blog.strongbrew.io/do-we-really-need-redux">This article</a> tackles this question separately.</p>

<h2 id="basic-best-practices">Basic best practices</h2>

<p>While the following list might be common sense for an experienced Redux developer, let’s sum those up as a refreshment for the sake of completeness.</p>
<ul>
  <li>Our application can only count one store, otherwise it would become too complex</li>
  <li>Reducers have to be pure, this is a principle from functional programming which makes functions predictable and avoids side effects</li>
  <li>Immutable datastructures are very important to optimise change detection cycles and avoid unexpected behavior, therefore reducers should handle data in an immutable manner</li>
  <li>Reducers always have to return a value! So don’t forget to implement the default case of the switch statement to return the original state</li>
</ul>

<h2 id="dont-add-models-to-the-store">Don’t add models to the store</h2>

<p>A model can be seen as a javascript object which has functionality, like the following example:</p>

<pre><code class="language-typescript">class User{
    constructor(private firstName: string, private lastName:string){
    }

    get fullName(): string {
        return `${this.firstName} ${this.lastName}`; 
    }
}
</code></pre>

<p>While the Redux package written by Dan Abramov forbids sending these prototyped objects as a payload, @ngrx/store does not forbid it yet.
However, it is a bad practice because it adds a lot of complexity to the store and chances are big that the models will get broken because of the immutable way of handling data. Check this example for instance:</p>

<pre><code class="language-typescript">const user = new User('Brecht', 'Billiet');
console.log(user.fullName); // Brecht Billiet
const updatedUser = {...user, lastName: 'Doe'};
console.log(updatedUser.fullName); // undefined
</code></pre>

<p>Since we have updated the user in an immutable way, it has created a new reference and therefore all its functionality has been lost.
This is exactly what our reducers will do with the data that flows into them. So always send plain objects when it comes to sending payloads in the actions.</p>

<p>Another approach for models is using Interfaces. Interfaces are great because are only interpreted in compile time, doesn’t use memory in runtime and are very expressive. If your model doesn’t need to be computed (like <code>get fullName()</code> in the previous example), then is advisable to use Interfaces instead.</p>

<p>Using Interfaces allows us to get advantage of some TypeScript features like <code>Pick&lt;T&gt;</code>. With <code>Pick&lt;T&gt;</code> we can create Types from Interfaces, which is very handy in some situations, like creating a model and a record with fewer properties:</p>

<pre><code class="language-typescript">export interface User {
    id: number;
    name: string;
    middleName: string;
    lastName: string;
    fullName: string;
    address: string;
    city: string;
    state: string;
    zip: string;
}

export type UserRecord = Pick&lt;User, 'id' | 'fullName'&gt;;
</code></pre>

<p>If the endpoint to get a list of users is returning a partial object instead of the full object then we can create a new Type instead of two Classes or Interfaces. This is a cleaner approach and easier to maintain if your models are prepared for your UI.</p>

<h2 id="what-do-we-put-in-the-store">What do we put in the store?</h2>

<p>We shouldn’t put things in the store just because we can. We have to think about what state needs to be in there and why.
State that is being shared between components can sometimes be kept in the parent component for instance. We call that inner state:
The component keeps its own state, the component itself is responsible for that. If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux.</p>

<p>However, when state needs to be shared between different root components (rendered inside a router-outlet) we might want to keep that state in the store.</p>

<p>When we need to remember a value when navigating through the application we could put that in the store as well. An example here could be: Remembering if a sidebar was collapsed or not, so when we navigate back to the page with the sidebar, it would still be collapsed.</p>

<p>Complex state is something that we might want to put in the store as well, since Redux can handle complex state management in an elegant way.
The general rule of thumb here could be, <strong>Only keep shared state, values that we want to remember and complex state in the store</strong>. Don’t add state in the store if we don’t need to, it would result in unneeded boilerplate and complexity.</p>

<p>That being said, there are 2 more reasons where we might want to add extra state into the store:</p>
<ul>
  <li>When we want to make our application real-time. Check out <a href="https://blog.strongbrew.io/How-we-made-our-app-real-time-in-6-lines-of-code/">How we made our app real time in 6 lines of code</a>.</li>
  <li>When we want to do optimistic updates. Check out <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">Cancellable optimistic updates in Angular2 and Redux</a></li>
</ul>

<h2 id="dont-forget-about-router-params">Don’t forget about router params</h2>

<p>A common mistake is putting things inside the store that could easily be added in the url.
The benefit of keeping state in the url is:</p>

<ul>
  <li>We can use the browser navigation buttons</li>
  <li>We can bookmark the url</li>
  <li>We can share that url with other people</li>
</ul>

<p>If we can put simple things into the url, we should at least consider it.</p>

<h2 id="avoid-huge-lists">Avoid HUGE lists</h2>

<p>Redux can not be seen as a local in-memory database, so we can’t put all our data into the store for performance reasons.
Redux can be seen as an abstraction of state and data that our application needs at a certain time.</p>

<p>For instance if we have a list of 10000 users, we don’t want to put them all in the store. What we could do is keep track of a list of 500 users in the store, which the user can see at that specific time, and load more users on the background and update that buffered list.</p>

<h2 id="designing-the-state">Designing the state</h2>

<p>Designing the state of our application is an important step, and we recommend to draw that state on a whiteboard first. The most important rule here is: <strong>Keep the state as flat as possible</strong></p>

<p>One of the most common bad practices is deep-nesting the state into something that becomes rather complex:</p>

<pre><code class="language-typscript">
// this is an example of how not to design state
export interface ApplicationState {
    moduleA: {
        data: {
            foo: {
                bar: {
                    users: User[],
                    cars: Car[]
                }
            }
        }
    }
}  

// keeping it flat makes the application way easier
export interface ApplicationState {
    users: User[],
    cars: Car[]
}  
</code></pre>

<p>I’m not saying you cannot nest state, I am saying we have to be very careful when we do. The general rule of thumb here is: <strong>keep the state as flat as possible</strong>
If we want to compose state in @ngrx/store we can work with feature module reducers and lazy load them as we can see in <a href="https://github.com/ngrx/platform/blob/master/docs/store/api.md#feature-module-state-composition">Feature Module State Composition</a>.</p>

<h2 id="make-everything-readonly">Make everything readonly</h2>

<p>We already covered the reason why we need to work immutable, but how can we enforce this?
Typescript comes with a readonly keyword which we can use to make a property readonly</p>

<pre><code class="language-typescript">type User = {
    readonly firstName: string;
    readonly lastName: string;
}

const user: User = {firstName: 'Brecht', lastName: 'Billiet'};
user.lastName = 'Doe';//cannot assign to 'lastName' 
// because it is a constant of read-only property
</code></pre>

<p>This would certainly make sure we aren’t updating properties in our reducers by accident. It does suck that we have to write readonly for every property.
The cool thing is that typescript offers us something called “advanced types” where we can do something like this:</p>

<pre><code class="language-typescript">// By using the Readonly&lt;&gt; advanced types all the properties inside the type
// are readonly by default
type User = Readonly&lt;{
    firstName: string;
    lastName: string;
}&gt;;
</code></pre>

<h2 id="action-design">Action design</h2>

<h3 id="actiontypes">Actiontypes</h3>

<p>An action type should be a string that explains what the action should change in the store. Keep these strings consistent. Don’t make the actiontypes too long, keep them short and clear.</p>

<pre><code class="language-typescript">// This is bad
const DATA_USERS_SET_USER_ADDRESS = 'DATA_USERS_SET_USER_ADDRESS';

// This is better
const SET_USER_ADDRESS = 'SET_USER_ADDRESS';

</code></pre>

<p>Another cool idea might be to suffix the action with square brackets and put the whole thing into an action object:</p>

<pre><code class="language-typescript">
// Easy to read/debug
const UserActions = {
  SET_ADDRESS: '[USER] ADDRESS'
}

</code></pre>

<p>If the state managment would become very large we could prefix the action, but let’s keep it simple and small as long as we can.</p>

<h3 id="action-creator-classes">Action creator classes</h3>

<p>When we use plain action types and payloads it becomes quite painful to remember all the action type names and all the payloads that belong to them. This example for instance:</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(
    {
        type: 'SET_USER_ADDRESS', 
        payload: {user_id, address}
    });
</code></pre>

<p>That’s pretty nasty if we want remember all that stuff, so let’s create action creator classes for these. What if we could do this?</p>

<pre><code class="language-typescript">const user_id = '1234', address = {whatevz};
this.store.dispatch(new SetUserAddressAction(user_id, address));
</code></pre>

<p>That’s just became way easier to use and we don’t have to remember the payload of the action.</p>

<p>If we wanted to implement the actioncreator class for this action it would look like this:</p>

<pre><code class="language-typescript">class SetUserAddressAction implements Action {
    type = SET_USER_ADDRESS;
    payload: {user_id: string, address: Address};
    constructor(user_id: string, address: Address){
        this.payload = {user_id, address};
    }
}
</code></pre>

<h3 id="payload-design">Payload design</h3>

<p>When the action would only have one property for the payload we might be encouraged to use the payload directly instead of creating a property in it. However that would lead to inconsistency, so it might be better to always use subproperties</p>

<pre><code class="language-typescript">// This is bad (inconsistent with the rest of the actions)
class UpdateUserAction implements Action {
    type = UPDATE_USER;
    payload: User;
    constructor(user: User){
        this.payload = user;
    }
}
// This is better
class UpdateUserAction implements Action{
    type = UPDATE_USER;
    payload: {user: User};
    constructor(user: User){
        this.payload = {user};
    }
}
</code></pre>

<h3 id="type-safety">Type Safety</h3>

<p>Type Safety is a huge win when using Redux with typescript, it requires a bit of boilerplate but it makes developing reducers feel like a walk in the park. It makes sure that our applications won’t compile if they have type errors and it gives us great autocompletion inside our reducers.
Therefore I would definitely consider it a must. Since <a href="https://twitter.com/KwintenP">Kwinten Pisman</a> already wrote an <a href="https://blog.strongbrew.io/type-safe-actions-in-reducers/">awesome article</a> about this we won’t go in to much detail here.</p>

<h2 id="reducer-design">Reducer design</h2>

<h3 id="destructuring-the-payload">Destructuring the payload</h3>

<p>If we want to make the reducer code more readable and shorter we could use javascript destructuring for that.
This might be personal preference, but it sure as hell makes our reducers easier to read. Take this example for instance:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS':
        return state.map(v =&gt; 
          v.id === action.payload.user_id ? 
          {...user, address: action.payload.address} : 
          v
        )
    }
}
</code></pre>
<p>The <code>action.payload.</code>code comes back a few times, resulting in longer codelines.
The following piece of code might be more readable:</p>

<pre><code class="language-typescript">function usersReducer
  (state: User[], action: UserActions): User []{
    switch(action.type) {
      case 'SET_USER_ADDRESS': {
        const {user_id, address} = action.payload;
        return state.map(v =&gt; 
          v.id === user_id ? 
          {...user, address} : 
          v
        )
      }
    }
}
</code></pre>

<p>As we can see have have used destructuring to extract the properties of the payload into variables.
Cleaner right? Let’s imagine that our actions has 5 or even more properties on their payloads. In that case this would definitely help.
Something to note here is that the case implementation is wrapped inside a block statement. This is important because our reducer can have the same payload properties for different actions.</p>

<p>This means that <code>user_id</code> and <code>address</code> won’t be available in the other case statements, which is exactly what we want.</p>

<h3 id="dont-write-business-logic-inside-our-reducers">Don’t write business logic inside our reducers</h3>

<p>Reducers should not contain business logic, they are used to handle the state in an immutable fashion. We won’t write business logic inside reducers because:</p>

<ul>
  <li>It would become very complex</li>
  <li>Business logic has nothing to do with state management</li>
  <li>We have services for that</li>
</ul>

<h3 id="child-reducers">Child reducers</h3>

<p>When reducers need to update a piece of state a few levels down in the tree it can become complex in no-time. Take this example for instance:</p>

<pre><code class="language-typescript">type User = {
    id: string;
    contracts: Contract[];
}
type Contract = {
    id: string;
    assignees: Assignee[];
}
type ApplicationState = {
    users: User[];
}   
...
</code></pre>

<p>If we would put all the logic to add an assignee to a specific contract of a specific user, the code would be hard to read. Checkout the following piece of code:</p>

<pre><code class="language-typescript">// This is bad
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: user.contracts.map(contract =&gt; 
            contract.id === contract_id ?
            {
              ...contract, 
              assignees: [...contract.assignees, assignee]
            } : 
            contract
          )
        } : 
        v
      )
    }
    default:
      return state;
  }
}
</code></pre>

<p>When reducers become complex it might be a good idea to split the reducer up into child reducers. Check the refactored version of the previous example:</p>

<pre><code class="language-typescript">// This is better
function usersReducer
  (state: User[], action: UserActions): User []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const {user_id, contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === user_id ? 
        {
          ...user, 
          contracts: contractsReducer(contracts, action.payload)
        } : 
        v
      )
    }
    default:
      return state;
  }
}

function contractsReducer
  (state: Contract[], action: UserActions): Contract []{
  switch(action.type) {
    case 'ADD_USER_CONTRACT_ASSIGNEE': {
      const { contract_id, assignee} = action.payload;
      return state.map(v =&gt; 
        v.id === contract_id ? 
        {
          ...contract, 
          assignees: [...assignees, assignee]
        } : 
        v
      )
    }
    default:
      return state;
  }
}

</code></pre>

<p>As we can see, we have extracted the handling of contracts into its own reducer, which follows the exact same principles of a regular reducer.</p>

<p>The example just became a lot easier to read and way more maintainable. When traversing complex data structures, reducer nesting can be a really elegant way of managing state.</p>

<h2 id="testing">Testing</h2>

<p>Since reducers are pure functions, unit testing them is very easy.
We won’t need to mock out any dependencies and we only have to test the value that the reducer returns.</p>

<p>We can also use <a href="https://www.npmjs.com/package/deep-freeze">deepfreeze</a> to freeze the state that when the reducer accidently mutates data, the tests will throw an error. Deepfreeze is nothing more than a recursive <code>Object.freeze</code></p>

<pre><code class="language-typescript">describe('reducer: usersReducer', () =&gt; {
  describe('case UPDATE_USER', () =&gt; {
    it('should return a new instance with the correct state', 
    () =&gt; {
      const initialState = [new User('1'), new User('2')];
      // deepfreeze makes sure the reducer 
      // doesn't mutate anything by accident
      deepfreeze(initialState); 
      const user = new User('2');
      const action = new UpdateUserAction(user);
      const newState = usersReducer(initialState, action);
      // check if the result of the array is a new ref
      expect(newState).not.toBe(initialState); 
      // check if the result of the user is a new ref
      expect(newState[1]).not.toBe(initialState[1]);
      // check if the user got updated automatically
      expect(newState[1]).toEqual(user);
    });
  });
});
  
</code></pre>

<p><strong>Note: Don’t forget to test the default action</strong></p>

<h2 id="decoupling-redux-from-the-presentation-layer">Decoupling redux from the presentation layer</h2>

<p>Having the store injected everywhere in our application is not a good idea. We want to create an Angular, Vue or React application. Not a Redux application.</p>

<p>Therefore we could consider the following as best practices:</p>
<ul>
  <li>Components don’t need to know we are using Redux, don’t inject the store in them.</li>
  <li>Services generally don’t need to know we are using Redux, don’t inject the store in them.</li>
  <li>We want to be able to refactor Redux away from our application without to much effort</li>
</ul>

<p>Therefore we want to have some kind of abstraction layer between the presentation layer and the state management layer.</p>

<p>How to abstract away the statemanagement layer can be read in the following two articles: <a href="https://blog.strongbrew.io/A-scalable-angular2-architecture/">A scalable angular architecture</a> and <a href="https://blog.strongbrew.io/A-scalable-angular-architecture-part2/">A scalable angular architecture part 2</a>.
This is an architecture that we are using at our customers that really works for us.</p>

<h2 id="redux-as-a-messaging-bus-vs-redux-as-a-state-management-layer">Redux as a messaging bus VS redux as a state management layer</h2>

<p>This might be a personal preference, but I like to use Redux as a pure state management layer. Yes, there are tools like @ngrx/effects where
we can send actions to our application and those actions won’t just perform state management but will do XHR calls among other things.</p>

<p>The nice thing about this approach is that we use some kind of messaging bus. However, I mostly like to keep it simple and abstract Redux away as much as possible. Therefore I don’t use @ngrx/effects and only use Redux to update pieces of state and consume theses pieces. Some part of me believes that Redux shouldn’t be used to perform backend calls nor decide when to optimistically update. I usually tackle optimistic updates <a href="https://blog.strongbrew.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/">this way</a>.</p>

<p>That being said, I wouldn’t call my approach a best practice, but it is a best practice to really think about which way we want it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We learned a lot! Once again, the best practices explained in this article are based on personal experiences and projects we have worked on. These are practices that work for us. They are not meant to be seen as the only way of doing things.</p>

<h2 id="special-thanks">Special thanks</h2>

<p>A very warm and much appreciated special thanks to the following people:</p>

<p><a href="https://twitter.com/ncjamieson">Nicholas Jamieson</a>, <a href="https://twitter.com/elecash">Raúl Jiménez</a> and <a href="https://twitter.com/FabianGosebrink">Fabian Gosebrink</a>: Thank you all so much for reviewing and pointing out some awesome ideas</p>

<p>Your input makes blogging worth while!</p>

	  ]]></description>
	</item>

	<item>
	  <title>RxJS polling strategies</title>
	  <link>//rxjs-polling/</link>
	  <author></author>
	  <pubDate>2018-04-19T00:00:00+00:00</pubDate>
	  <guid>//rxjs-polling/</guid>
	  <description><![CDATA[
	     <p>Polling is a common scenario in a lot of Single Page Applications. We want our user to see the latest data without them taking any actions. In some scenarios, we might even want to display this data real time. In most cases however, this is overkill and requires changes at the backend of our application. Polling is a really good ‘near immediate’ alternative.</p>

<p>Polling is something where RxJS really shines. We will look at different polling strategies and how we can implement them.</p>

<p><strong>Note:</strong> The examples in this post will use Angular but the concepts can be ported everywhere.</p>

<ul>
  <li><a href="#simple-polling">Simple polling</a></li>
  <li><a href="#polling-and-refresh-button">Combining polling with refresh button</a></li>
  <li><a href="#polling-and-reset">Polling and reset</a></li>
  <li><a href="#polling-when-data-is-resolved">Polling when data is resolved</a></li>
</ul>

<h3 id="simple-polling">Simple polling</h3>

<p>First we will take a look at a simple example where we want to fetch new data every 5 seconds. Let’s first try and think about what we need.</p>

<ul>
  <li>a backend call</li>
  <li>a trigger that tells us when we need to execute our backend call</li>
</ul>

<h4 id="backend-call">Backend call</h4>

<p>Executing a backend call is easy. We can create a stream that will execute a backend call when subscribed to like this.</p>

<pre><code class="language-typescript">const bitcoin$ = this.http.get('https://blockchain.info/ticker');
</code></pre>

<h4 id="trigger">Trigger</h4>

<p>Next thing we need is a trigger that will tell us when it is time to fetch our data. In a world without RxJS we would probably use <code>setInterval</code>. This function allows us to pass it a callback that gets executed every ‘x’ seconds.
With RxJS however, we have to change the way we think. We can no longer think in terms of callbacks, we have to think in terms of streams. If we apply this to the trigger we need, we want a stream that fires every ‘x’ seconds. 
Drawn in a ASCII marble diagram, this is what we want:</p>

<pre><code>----1----2----3----4----5...
</code></pre>

<p>RxJS has a static <code>interval</code> function that will create this streams for us. We can pass it a number which will denote the time between the events.</p>

<pre><code class="language-typescript">const trigger$ = interval(1000);
</code></pre>

<p>This is not enough however. Our trigger stream should also trigger at start time. Otherwise, we would only fetch data after ‘1000ms’ (with the example above).</p>

<p>RxJS provides another static function, ‘timer’, that will help us to create the following stream:</p>

<pre><code>0----1----2----3----4----5...
</code></pre>

<p>Code wise, this looks like this:</p>

<pre><code class="language-typescript">const trigger$ = timer(0, 1000);
</code></pre>

<h4 id="combine-to-polling-stream">Combine to polling stream</h4>

<p>Now we have the two streams that we need, it is time to combine them. If we think about it, we basically want to re-execute our <code>bitcoin$</code> to refetch the data, every time our <code>trigger$</code> fires. We want to map our trigger value to another observable/async action. To do that, we need to use a flattening operator. As flattening operators are not part of this post, you can read more about them <a href="https://blog.angularindepth.com/switchmap-bugs-b6de69155524" target="_blank">here</a>.</p>

<p>In our case, we are going to use the <code>concatMap</code> operator. This operator will execute all the <code>bitcoin$</code> without cancelling them. Let’s take a look at the code:</p>

<pre><code class="language-typescript">this.polledBitcoin$ = timer(0, 1000).pipe(
        concatMap(_ =&gt; bitcoin$),
        map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      );
</code></pre>
<p>We create a new stream, <code>this.polledBitcoin$</code> by mapping every event that the <code>trigger$</code> emits to our <code>bitcoin$</code>. The <code>concatMap</code> operator will subscribe to the <code>bitcoin$</code> internally and emit the result of that stream as events on the <code>polledBitcoin$</code>.</p>

<p>When we draw this out into a ASCII marble diagram, it looks like this:</p>

<pre><code>bitcoin:            -(b|)
trigger$:           0------1------2------3------4------5...
                    \      \      \      \      \      \
                     -(b|)  -(b|)  -(b|)  -(b|)  -(b|)  -(b|)
 
 
polledBitcoin$     ----b------b------b------b------b------b 
</code></pre>

<p>We have our <code>bitcoin$</code> that will, when subscribed to, take some time, and then emit the event and complete.</p>

<p>We have our <code>trigger$</code> where we map the values to the <code>bitcoin$</code>. The <code>concatMap</code> operator flattens the result and we get our <code>polledBitcoin$</code>. A stream that will fetch the value of bitcoin every second.</p>

<p>The live example can be found here:</p>

<iframe style="width: 100%; height: 500px" src="https://stackblitz.com/edit/angular-abcqen?embed=1&amp;file=app/app.component.ts"></iframe>

<p><strong>Note:</strong> You can open the devtools on the network tab to see the network requests. There are other Stackblitz demos in this post so you might want to open it in Stackblitz to be sure that the network tab only shows requests from a single demo.</p>

<h3 id="polling-and-refresh-button">Polling and refresh button</h3>

<p>Sometimes, users can be pretty impatient and want to have the control to fetch the data. We can accomplish this by adding a button that, when clicked, will fetch the data as well. But we want also want to keep our polling.</p>

<p>Let’s first try to think reactive on how we can accomplish this. We already have a stream that polls the data. We can create a stream that fetches the data whenever the button is clicked. When we have both of these streams, we can actually just combine them using the <code>merge</code> operator to get one stream that is both triggered by the polling and the button click.</p>

<p>We can simply add a button to our example and a click listener. When the button is clicked, we need to convert this click into a stream, since we will need a stream to ‘start with’. For this we can leverage a <code>Subject</code>.</p>

<pre><code class="language-typescript">manualRefresh = new Subject();

refreshDataClick() {
    this.manualRefresh.next('');
}
</code></pre>

<p>Now that we have a stream that is fired every time the button is clicked, we can simply use the same way of working that we had before. But now, our ‘source’ stream is not a <code>timer</code> but a <code>subject</code>.</p>

<pre><code class="language-typescript">this.manualRefresh
	.pipe(
       concatMap(_ =&gt; bitcoin$),
   );
</code></pre>

<p>Next thing we need to do is combine both of our streams that can trigger a backend call (and remove the double <code>concatMap</code> operator).</p>

<pre><code class="language-typescript">this.polledBitcoin$ = timer(0, 10000).pipe(
        merge(this.manualRefresh),
        concatMap(_ =&gt; bitcoin$),
        map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      );
</code></pre>

<p>That’s it. Now whenever the button is clicked or the timer triggers, a backend call will be done.</p>

<p>The live code example can be found here:</p>

<iframe src="https://stackblitz.com/edit/angular-zytccc?embed=1&amp;file=app/app.component.ts" style="height: 500px; width:100%"></iframe>

<h3 id="polling-and-reset">Polling and reset</h3>

<p>The previous polling strategy can introduce some unnecessary backend calls. Let’s think about the following scenario. Our timer stream triggers every 10s. After the app has started and has been running for 19s, the user clicks the button, triggering a backend call. And after 20s our timer stream fires as well, also triggering a backend call. This means that at both the 19th and the 20th second, we are fetching the data. This might be a little overkill.</p>

<p>Let’s think about how we can fix this. We already have a stream that will fetch the data immediately and then again and again with 10s in between. And actually, that’s all we need. When we have this stream, and the user clicks the button, we can just restart this stream. Since, when we restart this stream, we are fetching the data immediately (which is what we want when the user clicks), and again after 10 seconds. The ASCII marble diagram looks like this:</p>

<pre><code>bitcoin:            -(b|)
user clicks:                            C 
trigger$:           0------1------2-----!0------1------2-----|
                    \      \      \      \      \      \      
                     -(b|)  -(b|)  -(b|)  -(b|)  -(b|)  -(b|)
 
 
polledBitcoin$     ----b------b------b------b------b------b-- 
</code></pre>

<p><strong>Note:</strong> In ASCII marble diagrams, the ‘!’ means that the stream is unsubscribed from.</p>

<p>In the marble diagram above, ‘C’ denotes the user click. In that case, we want to unsubscribe from the previous execution of our <code>trigger$</code> and execute it again. Let’s see how we can do this in the code:</p>

<pre><code>load$ = new BehaviorSubject('');

this.polledBitcoin$ = this.load$.pipe(
      switchMap(_ =&gt; timer(0, 10000).pipe(
         concatMap(_ =&gt; bitcoin$),
         map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
      )
   )
);
</code></pre>
<p>First thing we need to change is move from a <code>Subject</code> to a <code>BehaviorSubject</code>. A <code>BehaviorSubject</code> has an initial value and will replay the last value when subscribed to. Here, we are interested in the fact that it has an initial value.</p>

<p>Next thing we do is use this subject to create our <code>polledBitcoin$</code>. We wrapped the stream from our previous examples in a <code>switchMap</code>. Whenever the <code>load$</code> emits, this stream will be started. If there was a previous execution still working, this execution will be stopped in favor of a new one. And that’s exactly what we need. Thanks to the initial value in the <code>BehaviorSubject</code>, we know that the stream will be started whenever the stream is initially subscribed to.</p>

<p>Now, whenever the user clicks on the reload button, the data will be fetched and the timer is reset! We can use this technique in different scenarios as well. For example, when the user swipes down on a mobile device. Nice right!</p>

<p>You can find the example code here:</p>
<iframe src="https://stackblitz.com/edit/angular-srtgmv" style="width: 100%; height: 500px"></iframe>

<h3 id="polling-when-data-is-resolved">Polling when data is resolved</h3>

<p>The last polling strategy I want to take a look at is one where we only start a next request after the first one has finished plus ‘x’ seconds. This can be helpful in some cases.</p>

<p>With the previous example in mind, Let’s say we poll every 5 seconds and at one point, our backend call takes 4 seconds. This would mean that, 1 second after we finally gotten our result, we fetch it again. This might not always be what we want.</p>

<p>Again, Let’s start by thinking about what we want in a reactive way. First of all, we need to know when our backend call has ended. When it has ended, we need to wait ‘x’ seconds before starting the next one. Let’s break it down.</p>

<p>Knowing when our backend call has ended is pretty easy. Whenever a value passes the <code>bitcoin$</code>, we know the backend call is done. After that has happened, we need to create a stream that, waits ‘x’ seconds and then triggers a new call. Let’s try and create a stream that, when subscribed to, waits 5 seconds, has the option to trigger a new call and then completes.</p>

<pre><code class="language-typescript">load$ = new BehaviorSubject('');

const whenToRefresh$ = of('').pipe(
      delay(5000),
      tap(_ =&gt; load$.next(''),
      skip(1),
);
</code></pre>

<p>We created a stream using the static <code>of</code>. This will fire an event immediately when subscribed to. We then delay this event with 5000ms by using the <code>delay</code> operator. We then use a <code>tap</code> where we can actually trigger the next request, and finally <code>skip</code> since we do not want to use the <code>''</code> event anywhere, it was just a trigger.</p>

<p>Next thing we need to do is integrate this into our other code. Let’s see how we can accomplish this:</p>

<pre><code class="language-typescript">this.polledBitcoin$ = this.load$.pipe(
       concatMap(_ =&gt; bitcoin$.pipe(concat(whenToRefresh$))),
       map((response: {EUR: {last: number}}) =&gt; response.EUR.last),
);
</code></pre>

<p>We removed the <code>timer</code> operator here and replaced it with our <code>BehaviorSubject</code>. We changed our stream inside the <code>concatMap</code> operator. Here we used <code>concat</code> to combine the <code>bitcoin$</code> with our <code>whenToRefresh$</code> we created above. What <code>concat</code> does is, execute the <code>bitcoin$</code> first and whenever that one completes, starts the other stream.</p>

<p>This is ideal, since we need to wait for the <code>whenToRefresh$</code> to start till the backend call completes. When it completed, the <code>whenToRefresh$</code> is started and will wait 5000ms and then next the <code>load$</code> to start the whole thing again.</p>

<p>Drawn out into an ASCII marble diagram, it looks like this.</p>

<pre><code>bitcoin$:         -----(b|)
load$:       f-------------f-------------f....
                                \
                  \              -----b-------N....
                   -----b-------N
                   
                   
polledBitcoin$:   ------b-------------b-------....
</code></pre>

<p>We can see that, whenever the first backend call was started, we wait 5000ms (here an amount of ‘-‘) before next’ing the <code>load$</code> to start the thing again.</p>

<p>A live example of the code can be found here:</p>

<iframe src="https://stackblitz.com/edit/angular-5mplks?file=app/app.component.ts" style="width: 100%; height: 500px"></iframe>

<p><strong>Note:</strong> to really see that the next call is only scheduled 5000ms after the previous one finished, you can use the network tab and throttle the network to ‘slow 3g’.</p>

<h3 id="conclusion">Conclusion</h3>

<p>RxJS and polling is a match made in heaven. There a number of different ways to implement polling which all have there trade offs. Understanding the differences between the ones described above will get you a long way.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Nx on your CI, how does it work?</title>
	  <link>//how-nx-affected-apps-works/</link>
	  <author></author>
	  <pubDate>2018-03-13T00:00:00+00:00</pubDate>
	  <guid>//how-nx-affected-apps-works/</guid>
	  <description><![CDATA[
	     <p>Nx from Nrwl is a collection of tools that can help us build Angular applications using a monorepo. In essence, Nx is a set of <a href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" target="_blank">schematics</a> that work on top of the @angular/cli. These schematics can be used to create apps and libs inside of a single @angular/cli project. Having multiple apps is supported by default and Nx leverages this feature and makes the process a little easier.</p>

<p>This post however is not about the basic working of Nx. If you want to learn more about Nx itself, go to their official website <a href="https://nrwl.io/nx" target="_blank">here</a> or watch this <a target="_blank" href="https://www.youtube.com/watch?v=bMkKz8AedHc">very informative talk</a> by <a href="https://twitter.com/MrJamesHenry">James Henry</a> at NgVikings.</p>

<p>This post will cover a different aspect of Nx. When all our applications are in the same repository, this poses some problems for your CI environment. Whenever a PR is merged into the master, the CI environment must rebuild your applications and ideally publish them to your DEV environment. But how do we handle it if we have a lot of apps in the same monorepo and we only want to build the apps that were affected by a certain PR? Nx provides us with a script to handle this situation.</p>

<h2 id="problem-description">Problem description</h2>

<p>Let’s take a look at the following Nx workspace. It has 2 apps and 2 libs.</p>

<p><img src="https://www.dropbox.com/s/4qohmskumvwa8k2/Screenshot%202018-03-13%2019.04.20.png?raw=1" alt="nx-workspace-image" /></p>

<p>As we can see ‘app1’ depends on ‘lib1’ and ‘lib2’ and ‘app2’ only depends on ‘lib1’. When we change something to ‘lib2’ we only need to rebuild our ‘app1’. Nx provides us with a script that will, based on two git commit hashes, tell us all the apps that need to be build. You can run the script like this:</p>

<pre><code class="language-bash">./node_modules/.bin/nx affected apps SHA1 SHA2
</code></pre>
<p>SHA1 is the previous commit hash and SHA2 is the next commit hash. If, in our example, we change something to lib2, this script will output:</p>

<pre><code class="language-typescript">app1
</code></pre>

<p>In this post, we will take a look at the script you can use for this and look at some code snippets to understand how it works.</p>

<h2 id="how-do-they-know-what-apps-to-build">How do they know what apps to build</h2>

<h3 id="knowing-what-files-are-changed">Knowing what files are changed</h3>

<p>To know the files that have changed, they leverage the <code>git diff</code> command. Let’s look at the code:</p>

<pre><code class="language-typescript">function getFilesFromShash(sha1: string, sha2: string): string[] {
  return execSync(`git diff --name-only ${sha1} ${sha2}`)
    .toString('utf-8')
    .split('\n')
    .map(a =&gt; a.trim())
    .filter(a =&gt; a.length &gt; 0);
}
</code></pre>

<p>The <code>git diff</code> command returns all the files that have changed between two commits. This is transformed into a list of files.</p>

<h3 id="knowing-the-apps-these-touched-files-belong-to">Knowing the apps these touched files belong to</h3>

<p>Now it is clear which files are touched, it’s time to identify the ‘projects’ these files belong to. In the script, both Nx apps and libs are referenced to as projects. They implement this using the following code.</p>

<pre><code class="language-typescript">export function touchedProjects(projects: ProjectNode[], touchedFiles: string[]) {
  projects = normalizeProjects(projects);
  touchedFiles = normalizeFiles(touchedFiles);
  return touchedFiles.map(f =&gt; {
    const p = projects.filter(project =&gt; project.files.indexOf(f) &gt; -1)[0];
    return p ? p.name : null;
  });
}
</code></pre>
<p>This will give us all the projects that have files that have changed, a.k.a. the ‘touchedProjects’.</p>

<h3 id="identifying-all-the-apps">Identifying all the apps</h3>

<p>Next step is identifying the different apps of the project. For this, they simply parse the ‘.angular-cli.json’ file which has an entry with all the apps. Notice that ‘apps’ in this context means entries in the ‘.angular-cli.json’. Both the ‘apps’ and ‘libs’ in Nx terminology are ‘apps’ in the ‘.angular-cli.json’.</p>

<pre><code class="language-typescript">export function getAffectedApps(touchedFiles: string[]): string[] {
  const config = JSON.parse(fs.readFileSync('.angular-cli.json', 'utf-8'));
  const projects = getProjectNodes(config);
  
  ...
} 

export function getProjectNodes(config) {
  return (config.apps ? config.apps : []).filter(p =&gt; p.name !== '$workspaceRoot').map(p =&gt; {
    return {
      name: p.name,
      root: p.root,
      type: p.root.startsWith('apps/') ? ProjectType.app : ProjectType.lib,
      files: allFilesInDir(path.dirname(p.root))
    };
  });
}
</code></pre>
<p>They fetch all the apps, loop over them, and create an object containing information about this app:</p>
<ul>
  <li>the name</li>
  <li>the root folder</li>
  <li>is it a real App or a Lib</li>
  <li>all the files it holds.</li>
</ul>

<h3 id="knowing-the-dependencies-of-the-apps-and-libs">Knowing the dependencies of the apps and libs</h3>

<p>Now that the apps are identified and we know the files inside those apps, it’s time to identify the dependencies the apps have on the different libs in the Nx workspace. To do that, they loop over every file in every project and parse those files using typescript. Then they visit every typescript node and if they encounter an import declaration or a <code>loadChildren</code> property they call the <code>addDeppIfNeeded</code> method since these are indicators that we might have a dependency on a lib in the monorepo.</p>

<pre><code class="language-typescript"> private processAllFiles() {
    this.projects.forEach(p =&gt; {
      p.files.forEach(f =&gt; {
        this.processFile(p.name, f);
      });
    });
  }

  private processFile(projectName: string, filePath: string): void {
    if (path.extname(filePath) === '.ts') {
      const tsFile = ts.createSourceFile(filePath, this.fileRead(filePath), ts.ScriptTarget.Latest, true);
      this.processNode(projectName, tsFile);
    }
  }
  
private processNode(projectName: string, node: ts.Node): void {
    if (node.kind === ts.SyntaxKind.ImportDeclaration) {
      const imp = this.getStringLiteralValue((node as ts.ImportDeclaration).moduleSpecifier);
      this.addDepIfNeeded(imp, projectName, DependencyType.es6Import);
      return; // stop traversing downwards
    }

    if (node.kind === ts.SyntaxKind.PropertyAssignment) {
      const name = this.getPropertyAssignmentName((node as ts.PropertyAssignment).name);
      if (name === 'loadChildren') {
        const init = (node as ts.PropertyAssignment).initializer;
        if (init.kind === ts.SyntaxKind.StringLiteral) {
          const childrenExpr = this.getStringLiteralValue(init);
          this.addDepIfNeeded(childrenExpr, projectName, DependencyType.loadChildren);
          return; // stop traversing downwards
        }
      }
    }
    /**
     * Continue traversing down the AST from the current node
     */
    ts.forEachChild(node, child =&gt; this.processNode(projectName, child));
  }  
</code></pre>
<p>Let’s look at the ‘addDepIfNeeded’ method.</p>

<pre><code class="language-typescript"> private addDepIfNeeded(expr: string, projectName: string, depType: DependencyType) {
    const matchingProject = this.projectNames.filter(
      a =&gt;
        expr === `@${this.npmScope}/${a}` ||
        expr.startsWith(`@${this.npmScope}/${a}#`) ||
        expr.startsWith(`@${this.npmScope}/${a}/`)
    )[0];

    if (matchingProject) {
      this.deps[projectName].push({projectName: matchingProject, type: depType});
    }
  }
</code></pre>

<p>This method checks if the <code>loadChildren</code> property or the import declaration is linked to one of our own libs. In that case, we add the dependency to the list of dependencies per project using the ‘projectName’ identifier.</p>

<h3 id="putting-the-pieces-together">Putting the pieces together</h3>

<p>We found the files that were changed and to which projects they belong to. We figured out all the dependencies the different projects have. Now it just a matter of cross referencing these to figure out which ‘apps’ need to be rebuild. Let’s look at the code:</p>

<pre><code class="language-typescript">  if (tp.indexOf(null) &gt; -1) {
    return projects.filter(p =&gt; p.type === ProjectType.app).map(p =&gt; p.name);
  } else {
    return projects
    			.filter(p =&gt; p.type === ProjectType.app)
    			.map(p =&gt; p.name)
    			.filter(name =&gt; hasDependencyOnTouchedProjects(name, tp, deps, []));
  }
</code></pre>

<p>There is an interesting part in this snippet. There is a check to see if ‘null’ is in the ‘touchedProjects’. This happens when there is a change to a file outside of the ‘apps’ or ‘libs’ directory. This can happen if, for example, the package.json file has been updated. In that case, every ‘app’ needs to be rebuild.</p>

<p>Finally, we can look at the <code>hasDependencyOnTouchedProjects</code> function.</p>

<pre><code class="language-typescript">function hasDependencyOnTouchedProjects(project: string, touchedProjects: string[], deps: { [projectName: string]: Dependency[] }, visisted: string[]) {
  if (touchedProjects.indexOf(project) &gt; -1) return true;
  if (visisted.indexOf(project) &gt; -1) return false;
  return deps[project]
  	.map(d =&gt; d.projectName)
  	.filter(k =&gt; 
  		hasDependencyOnTouchedProjects(
  			k, 
  			touchedProjects, 
  			deps, 
  			[...visisted, project]
  		)
  	).length &gt; 0;
}
</code></pre>

<p>Using recursion, they cross-reference the affected files and the projects they belong to with the dependencies all the projects have. This will return a list of all the apps that need to build.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Using git, typescript and a little javascript code, the guys at Nx created a script that can help us to only rebuild apps that are affected by a PR reducing the build time on our CI environments.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Pre-rendering Angular Applications</title>
	  <link>//prerendering-angular-apps/</link>
	  <author></author>
	  <pubDate>2018-03-04T00:00:00+00:00</pubDate>
	  <guid>//prerendering-angular-apps/</guid>
	  <description><![CDATA[
	     <h2 id="why-should-we-pre-render-angular-applications">Why should we pre-render Angular applications?</h2>

<p>At the moment of writing this article, there are several ways of optimizing Angular applications - We could compile them <a href="https://angular.io/guide/aot-compiler">ahead-of-time</a> through AOT compilation.
We could use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service workers</a> to optimize caching. And there are plenty of other PWA (progressive web app) features that can increase the quality and overall performance of our Angular applications.</p>

<p>However, there are a still a few problems that these optimizations won’t fix:</p>
<ul>
  <li><strong>SEO</strong> (search engine optimization): At the time of writing, SPAs (single-page applications) are harder to index by search engines because the content isn’t available on load time. Therefore, the application is likely to fail on several SEO requirements.</li>
  <li><strong>Initial page load</strong> could be faster: Since the application still needs to be bootstrapped after the page is loaded, there is an initial waiting time until the user can use the application. This results in a bad user experience.</li>
</ul>

<p>These two problems can be fixed by implementing <a href="https://angular.io/guide/universal">SSR (server-side rendering)</a>. SSR executes the Angular application on the server. That way the server will actually serve the compiled content in a way that search engine crawlers can read it. This is really the best of both worlds: The application will be rendered on the server, but when the JavaScript bundle is loaded, it will turn into a SPA. That way the application is rich and fast at the same time!</p>

<p>To optimize our <a href="https://strongbrew.io">StrongBrew</a> website, we started using this approach. It was pretty fast when we ran it locally. However, the StrongBrew website is hosted on <a href="https://firebase.google.com">Firebase</a> and the SSR part was hosted by Firebase functions.</p>

<p>We really love Firebase and everything it stands for, but for us, SSR on Firebase functions was just too slow. Sometimes it took 4 seconds to serve the content… Since the loading time of a website is very important for keeping our visitors, we had to find another way to serve the content in a more effective manner.</p>

<p>SSR works like this: A user navigates to a URL =&gt; the server compiles the application and serves it.
But instead of compiling every route when the server receives a request, what if we could execute the SSR logic for every route at build time? That would certainly fix our problem.</p>

<p>That way we would run generated static HTML files, which is insanely fast, and when the JavaScript bundles are loaded, the browser would take over.
This also uses the best of both worlds: Ultra fast loading time + we don’t need to give up our rich SPA experience.
The result went from several seconds to 30 milliseconds.
<img src="/assets/images/posts/prerendering-angular-apps/ssr-vs-prerender.png" alt="SSR vs Prerender" /></p>

<p>This is a super fast and super effective improvement but it has one very important limitation.
<strong>It’s not possible to prerender dynamic content</strong>. The data in the StrongBrew website isn’t fetched by AJAX calls (at least not the data that has to be indexed). It rather works with simple webpack imports of JSON files. These are inserted at build time.</p>

<p>This does not mean that loading content dynamically isn’t possible at all, it just won’t get prerendered.</p>

<h2 id="lets-dive-in">Let’s dive in</h2>

<p>Enough chit chat! Let’s dive into some code.
I’ve created this <a href="https://github.com/strongbrewio/prerender-angular-example">GitHub repository</a> just for you! It’s a simple website with a few pages and the build system doesn’t know how to pre-render yet.
Checkout the branch <code>runtime</code> by running the command <code>git checkout runtime</code>. When running <code>npm i &amp;&amp; npm run start</code>, the bash should install all the NPM dependencies and host the application on <code>http://localhost:4200</code>, just like any default Angular CLI application.</p>

<h3 id="installing-the-dependencies">Installing the dependencies</h3>

<p>Great! We have a running website, but nothing is pre-rendered yet.
The first thing we need to do is to install @angular/platform-server by running
<code>npm i @angular/platform-server -D</code>. This is the most important bundle for SSR. This module contains the basics to run the Angular application on the server.</p>

<h3 id="applying-the-server-transition">Applying the server transition</h3>

<p>Next, we need to update the <code>app.module.ts</code> to enable server transition. This will make sure that Angular takes over on the frontend when the JavaScript bundles are loaded.</p>

<pre><code class="language-typescript">// src/app/app.module.ts
@NgModule({
  ...
  imports: [
    BrowserModule.withServerTransition(
        // this is just the name of our application
        // configured in angular-cli.json
        { appId: 'prerender-angular-example' }
    ),
    ...
  ],
  ...
})
export class AppModule { }
</code></pre>

<h3 id="creating-the-prerender-module">Creating the prerender module</h3>

<p>Then, we need to create a specific prerender module that will use the AppModule we have just adjusted. Let’s create an <code>app.prerender.module.ts</code> where we can tell which component it has to bootstrap.</p>

<pre><code class="language-typescript">// src/app/app.prerender.module.ts
import { NgModule } from '@angular/core';
import { ServerModule, ServerTransferStateModule } from '@angular/platform-server';

import { AppModule } from './app.module';
import { AppComponent } from './app.component';

@NgModule({
  imports: [
    AppModule,
    ServerModule,
    ServerTransferStateModule
  ],
  bootstrap: [AppComponent]
})
export class AppPrerenderModule {
}
</code></pre>

<h3 id="defining-a-prerender-entrypoint">Defining a prerender entrypoint</h3>

<p>To use the SSR logic at build time, we need to have a specific bundle. Since the <code>main.ts</code> file is used to bootstrap the application for the browser, we also need a <code>main.prerender.ts</code> file that will be used to create the prerender bundle.
Let’s create that file, shall we?</p>

<pre><code class="language-typescript">// src/app/main.prerender.ts
import { enableProdMode } from '@angular/core';
export { AppPrerenderModule } from './app/app.prerender.module';

enableProdMode();
</code></pre>
<h3 id="a-prerender-tsconfigjson">A prerender tsconfig.json</h3>

<p>We are almost there, I promise, but we need a few more things. We need a specific <strong>tsconfig</strong> file that compiles the bundle to something that the node server can read. It’s important for the compiler to compile to a <strong>commonjs</strong> package. This is because node.js uses this by default. So we need to create a <code>tsconfig.prerender.json</code> file:</p>

<pre><code class="language-json">/* src/tsconfig.prerender.json */
{
  "extends": "./tsconfig.app.json",
  "compilerOptions": {
    "outDir": "../out-tsc/prerender",
    /* node only understands commonjs for now*/
    "module": "commonjs"
  },
  "exclude": [
    "test.ts",
    "**/*.spec.ts"
  ],
  /* Additional informations to bootstrap Angular */
  "angularCompilerOptions": {
    "entryModule": "app/app.prerender.module#AppPrerenderModule"
  }
}

</code></pre>

<h3 id="letting-angular-cli-know-and-generating-the-bundle">Letting Angular CLI know and generating the bundle</h3>

<p>In the apps entry of the <code>angular-cli.json</code> file, we need to add a new app where we refer to the <code>main.prerender.ts</code> file and the <code>tsconfig.prerender.json</code> file. The app section should look like this:</p>

<pre><code class="language-json">{
      "name": "prerender",
      "platform": "server",
      "root": "src",
      "outDir": "dist-prerender",
      "main": "main.prerender.ts",
      "tsconfig": "tsconfig.prerender.json",
      "environmentSource": "environments/environment.ts",
      "environments": {
        "dev": "environments/environment.ts",
        "prod": "environments/environment.prod.ts"
      }
    }
</code></pre>

<p>Update the package JSON so it builds both the normal package and the server package. Set the <strong>output-hashing</strong> to none so that the build generates a clean <code>main.bundle.js</code> without any hash.</p>
<pre><code>    "build": "ng build --prod &amp;&amp; ng build --prod --app prerender --output-hashing=none",
</code></pre>
<p>When running <code>npm run build</code> the following files should be created:</p>
<ul>
  <li>dist (this contains the normal build)</li>
  <li><code>dist-prerender/main.bundle.js</code></li>
</ul>

<p>This <code>main.bundle.js</code> file exports a module called <code>AppPrerenderModuleNgFactory</code>. This is the module that we can use to pre-render the whole thing.</p>

<h2 id="generating-the-static-files">Generating the static files</h2>

<p>We have just generated the <code>main.bundle.js</code>, the file that we need to perform server-side rendering. However we don’t want to do server-side rendering in this case, we want to <strong>pre-render</strong> the html at build time. To do that we need a script that will complete the following steps.</p>

<ul>
  <li>Create an array with routes (we could automate this if we want)</li>
  <li>Loop over that array and for every entry:
    <ul>
      <li>create a folder in the dist map with that route name</li>
      <li>use the <code>main.bundle.js</code> to render the html and store that html as an <code>index.html</code> in the folder we just created.</li>
      <li>Overwrite the <code>dist/index.html</code> file.</li>
    </ul>
  </li>
</ul>

<p>Let’s call that script <code>prerender.ts</code>. Since I’m a typescript enthusiast, I want to develop the prerender script in typescript and use <a href="https://www.npmjs.com/package/ts-node">ts-node</a> to run it.
We can start with creating an empty <code>prerender.ts</code> file in the root folder and installing ts-node with <code>npm i -D ts-node</code></p>

<p>Now we can update the scripts section of the package.json so that the render function is called when the build is completed:</p>

<pre><code class="language-json"> "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build --prod &amp;&amp; ng build --prod --app prerender --output-hashing=none",
    "postbuild": "npm run render",
    "render": "ts-node prerender.ts",
    ...
  },
</code></pre>

<p>The only puzzle piece that is still missing is implementing the <code>prerender.ts</code> file.</p>

<h3 id="completing-the-prerenderts-file">Completing the prerender.ts file</h3>

<p>The following code should be self-explanatory:</p>

<pre><code class="language-typescript">import 'zone.js/dist/zone-node';
import * as path from 'path';
import * as fs from 'fs';
import { enableProdMode } from '@angular/core';
import { renderModuleFactory } from '@angular/platform-server';
import { AppPrerenderModuleNgFactory } from './dist-prerender/main.bundle';

const distFolder = './dist';
const index = fs
    .readFileSync(path.resolve(__dirname, `${distFolder}/index.html`), 'utf8')
    .toString();

// we could automate this based on the app.routes.ts file but
// to keep it simple let's just create an array with the routes we want
// to prerender
const paths = [
    '/about',
    '/brews',
    '/consultancy'];
enableProdMode();

// for every route render the html and save it in the correct folder
paths.forEach(p =&gt; renderToHtml(p, distFolder + p));

// don't forget to overwrite the index.html as well
renderToHtml('/index.html', distFolder);

function renderToHtml(url: string, folderPath: string): void {
  // Render the module with the correct url just 
  // as the server would do
  renderModuleFactory(AppPrerenderModuleNgFactory, {
    url,
    document: index
  }).then(html =&gt; {
    // create the route directory
    if (url !== '/index.html') {
    fs.mkdirSync(folderPath);
    }
    fs.writeFile(folderPath + '/index.html', html,  (err =&gt;  {
      if (err) {
        throw err;
      }
      console.log(`success`);
    });
  });
}

</code></pre>
<h3 id="testing-the-pre-rendered-application">Testing the pre-rendered application</h3>

<p>To test the website, we can build the project with <code>npm run build</code>. To serve it, we can use http-server. We can install http-server by running <code>npm i -g http-server</code>. By navigating into the <code>dist</code> directory and running <code>http-server</code>, the application will be hosted on port 8080.</p>

<p>If we navigate to http://localhost:8080 in the browser, we will see the pre-rendered application. We can test the SPA experience by navigating between the different pages and we can test the pre-rendered part by looking at the source code.</p>

<p><img src="/assets/images/posts/prerendering-angular-apps/sourcecode.png" alt="SSR sourcecode" /></p>

<h2 id="closing-words">Closing words</h2>

<p>I hope you liked this article and learned something.
We can find the full pre-rendered version by checking out branch <code>prerendered</code> by running <code>git checkout prerendered</code>. To test this example, checkout the previous section.</p>

<p>Note: to optimize the HTML even more, we could use an HTML minifier like <a href="https://www.npmjs.com/package/html-minifier">this one</a> to shrink the HTML where possible. The example could look something like this:</p>

<pre><code class="language-typescript">const minify = require('html-minifier').minify;
function renderToHtml(url: string, folderPath: string): void {
    // Render the module with the correct url just 
    // as the server would do
    renderModuleFactory(AppPrerenderModuleNgFactory, {
        url,
        document: index
    }).then(html =&gt; {
        ...
        // minify the html
        fs.writeFile(folderPath + '/index.html', minify(html),  (err =&gt;  {
          ...
        });
    });
}
</code></pre>

<h2 id="special-thanks">Special thanks</h2>

<p>A very special thanks to the awesome people that have helped me with their reviews:</p>

<ul>
  <li>Laurant Duveau <a href="https://twitter.com/laurentduveau">@laurentduveau</a></li>
  <li>Dominic Elm <a href="https://twitter.com/elmd_">@elmd_</a></li>
  <li>Sam Vloeberghs <a href="https://twitter.com/samvloeberghs">@samvloeberghs</a></li>
  <li>Ana Cidre <a href="https://twitter.com/anacidre_">@AnaCidre_</a></li>
  <li>Ruben Vermeulen <a href="https://twitter.com/CrushTheButton">@CrushTheButton</a></li>
  <li>Klaas Cuvelier <a href="https://twitter.com/klaascuvelier">@klaascuvelier</a></li>
</ul>

<h2 id="sources">Sources</h2>

<p><a href="https://hackernoon.com/deploy-angular-universal-w-firebase-ad70ea2413a1">deploy angular universal with firebase</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Displaying components based on the role of a user</title>
	  <link>//display-a-component-based-on-role/</link>
	  <author></author>
	  <pubDate>2018-01-15T00:00:00+00:00</pubDate>
	  <guid>//display-a-component-based-on-role/</guid>
	  <description><![CDATA[
	     <p>At some moment in time, almost every application will have certain parts that need to be restricted to users with the proper roles. When we need to protect a certain route from unauthorized access, Angular provides us with a guard.</p>

<p>But what if it’s only a single component that cannot be rendered when the user does not have the proper role? Angular does not provide something out of the box for this. Luckily this is something we can easily implement using directives.</p>

<iframe src="https://player.vimeo.com/video/251380600" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>

<h3 id="defining-what-we-want">Defining what we want</h3>
<p>We want to create a directive that accepts a role. This is the role the user must have to see this specific component.
It might look something like this:</p>

<pre><code class="language-html">&lt;app-normal-users-can-view *appHasRole="'user'"&gt;
&lt;/app-normal-users-can-view&gt;
</code></pre>

<h3 id="defining-how-it-should-work">Defining how it should work</h3>

<p>Let’s define the characteristics for our directive:</p>
<ul>
  <li>If the user has the proper role, the component should be shown.</li>
  <li>If the user does not have the proper role, the component shouldn’t be added to the DOM.</li>
</ul>

<p>If you think about it, that’s pretty much what an <code>*ngIf</code> directive does. Based on a certain condition, a component or native element must be added to the DOM or removed from the DOM.</p>

<h3 id="what-does-our-directive-need-to-make-it-work">What does our directive need to make it work?</h3>
<p>Our directive needs several things to make it work properly. First of all, we need a reference to the element that needs to be added to the DOM. On a secondary note, we need a place where we can insert the element to the DOM if needed. And lastly, we need to know the roles the user has.</p>

<h4 id="getting-a-reference-to-the-element-that-needs-to-be-added">Getting a reference to the element that needs to be added</h4>

<p>To get a reference to the element we need to add, we can use a ‘template directive’ (or <a href="https://angular.io/guide/structural-directives" target="blank">structural directive</a>). We can make any directive a ‘template directive’ by prefixing the directive with an asterisk (<code>*</code>) when we use it. This is syntactic sugar for the angular compiler. If we do this, this is what the compiler actually sees:</p>

<pre><code class="language-html">&lt;!-- what we write --&gt;
&lt;app-normal-users-can-view *appHasRole="'user'"&gt;
&lt;/app-normal-users-can-view&gt;

&lt;!-- how the compiler interprets it --&gt;
&lt;ng-template [appHasRole]="'user'"&gt;
      &lt;app-normal-users-can-view&gt;&lt;/app-normal-users-can-view&gt;
&lt;/ng-template&gt;
</code></pre>

<p>We can see that the compiler puts our directive onto an <code>ng-template</code>. This is ideal because it allows our directive to inject the <code>TemplateRef</code> containing the element we need to add (if the user has the role), which is what we want.</p>

<h4 id="finding-the-dom-entry-point">Finding the DOM entry point</h4>
<p>To know where we can inject the <code>TemplateRef</code>, our directive can just inject the <code>ViewContainerRef</code>. This represents the container where we can attach one or more views. For more information on the <code>ViewContainerRef</code> you can read <a href="https://netbasal.com/angular-2-understanding-viewcontainerref-acc183f3b682" target="blank">this</a> post.</p>

<h4 id="knowing-the-roles-a-user-has">Knowing the roles a user has</h4>
<p>To know the roles a certain user has, we could leverage a service (in the example code <code>rolesService</code>) that exposes a stream with all the roles that user has.</p>

<h3 id="the-hasrole-directive-end-result">The hasRole directive end result</h3>
<p>Now that we have identified all the different things we need to properly implement our directive, we can start. See the comments for more information.</p>

<pre><code class="language-typescript">@Directive({
  selector: '[appHasRole]'
})
export class HasRoleDirective implements OnInit, OnDestroy {
  // the role the user must have 
  @Input() appHasRole: string;

  stop$ = new Subject();

  isVisible = false;

  /**
   * @param {ViewContainerRef} viewContainerRef 
   * 	-- the location where we need to render the templateRef
   * @param {TemplateRef&lt;any&gt;} templateRef 
   *   -- the templateRef to be potentially rendered
   * @param {RolesService} rolesService 
   *   -- will give us access to the roles a user has
   */
  constructor(
    private viewContainerRef: ViewContainerRef,
    private templateRef: TemplateRef&lt;any&gt;,
    private rolesService: RolesService
  ) {}

  ngOnInit() {
    //  We subscribe to the roles$ to know the roles the user has
    this.rolesService.roles$.pipe(
    	takeUntil(this.stop$)
    ).subscribe(roles =&gt; {
      // If he doesn't have any roles, we clear the viewContainerRef
      if (!roles) {
        this.viewContainerRef.clear();
      }
      // If the user has the role needed to 
      // render this component we can add it
      if (roles.includes(this.appHasRole)) {
        // If it is already visible (which can happen if
        // his roles changed) we do not need to add it a second time
        if (!this.isVisible) {
          // We update the `isVisible` property and add the 
          // templateRef to the view using the 
          // 'createEmbeddedView' method of the viewContainerRef
          this.isVisible = true;
          this.viewContainerRef.createEmbeddedView(this.templateRef);
        }
      } else {
        // If the user does not have the role, 
        // we update the `isVisible` property and clear
        // the contents of the viewContainerRef
        this.isVisible = false;
        this.viewContainerRef.clear();
      }
    });
  }
  
  // Clear the subscription on destroy
  ngOnDestroy() {
    this.stop$.next();
  }
}

</code></pre>
<p>You can find the full source code <a href="https://github.com/KwintenP/display-or-hide-components-based-on-role" target="_blank">here</a>. You can play with a live example <a href="" target="_blank">here</a>. You can change the roles on top by clicking the checkboxes. If a role is granted, a new element is added to the DOM.</p>

<h3 id="conclusion">Conclusion</h3>
<p>Leveraging a few somewhat more advanced concepts as ‘template directives’, <code>viewContainerRef</code> and <code>TemplateRef</code>, we were able to easily implement our own <code>*ngIf</code> like directive that works based on the roles with a limited amount of code.</p>

<p><strong>Note:</strong> In this example I’m using roles. Applying a role based strategy for authorization poses some problems. There will always be cases where a user should have role ‘X’ but should also be able to see a portion of the functionality that users with role ‘Y’ see. In that case, you would have to create a new role, ‘Z’, that holds properties of ‘X’ and ‘Y’.</p>

<p>In growing applications, this will mean a lot of roles, that might be only used by a single person. With that in mind, it’s always better to give the user certain ‘rights’. If the user can see the ‘User management’ part of the application, he should have the ‘right’ ‘user_mgmt’ for example. Using ‘rights’ avoids the problem described above with the roles.</p>

	  ]]></description>
	</item>

	<item>
	  <title>RxJS best practices in Angular</title>
	  <link>//rxjs-best-practices-in-angular/</link>
	  <author></author>
	  <pubDate>2018-01-04T00:00:00+00:00</pubDate>
	  <guid>//rxjs-best-practices-in-angular/</guid>
	  <description><![CDATA[
	     <p>This article is all about the do’s and don’ts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#pipeable-operators">Pipeable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don’t pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don’t pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code>$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code>$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="pipeable-operators">Pipeable operators</h2>

<p>The first best practice is the use of pipeable operators. The operators being used in this article are pipeable.
Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about pipeable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<pre><code class="language-typescript">// BAD: This is the old way and should be avoided (patch operators)
// as we can see the operators (filter, map) are part of the
// Observable prototype
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
const new$ = Observable.interval$
    .filter(v =&gt; v % 2 === 0)
    .map(v =&gt; v * 2);

// GOOD: This is the new and improved way (lettable operators)
// we just use the pipe operator where we pass operators that
// we can import from 'rxjs/operators'
import {filter, map} from 'rxjs/operators';
const new$ = interval$
    .pipe(
        filter(v =&gt; v % 2 === 0),
        map(v =&gt; v *2)
    )
</code></pre>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: “Great code should be self-explanatory, writing documentation is something that we might want to avoid.”
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it’s hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it’s supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<pre><code class="language-typescript">// ---a--b--c--d---e---...
// ---a--b--c--d---e|
// ---a--b--c--d---e#
// ---a--b-^-c--d---e
</code></pre>
<ul>
  <li><code>-</code> (stands for a time frame)</li>
  <li><code>a-z</code> (are the values that are next’ed in the stream)</li>
  <li><code>|</code> (indicates that the stream has completed)</li>
  <li><code>...</code> (indicates that the stream will keep on living)</li>
  <li><code>#</code> (indicates that an error occurred)</li>
  <li><code>^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it’s time to check a real example and how we might document it:</p>

<pre><code class="language-typescript">const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
const new$ = interval$
    .pipe(
        skip(1),                            // ---1--2--3--4--5--6...
        take(5),                            // ---1--2--3--4--5|
        filter(v =&gt; v % 2 === 0),           // ------2-----4-----6
        map(v =&gt; v + 1)                     // ------3-----5-----7
    )
</code></pre>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it’s fairly easy to comprehend what happens, and how every operator affects the <code>new$</code> stream we can see above. There is no “one way of doing things” when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn’t mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn’t have any side effects. It can’t mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren’t fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit {
   ngOnInit() {
        // The following stream will produce values every second
        // 0--1--2--3--4--5--6--...
        const interval$ = interval(1000);
        // Even when this component gets destroyed,
        // the stream will keep producing values...
        // This means the console will keep on logging
        // This is a classic example of a memory-leak
        const subscription = interval$.subscribe(r =&gt; console.log(r));
    }
}
</code></pre>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    subscriptions = [];
    ngOnInit() {
        const interval$ = interval(1000);
        const subscription = interval$.subscribe(r =&gt; console.log(r));
        // manually keep track of the subscriptions in a subscription array
        this.subscriptions.push(subscription);
    }

    ngOnDestroy() {
        // when the component get's destroyed, unsubscribe all the subscriptions
        this.subscriptions.forEach(sub =&gt; sub.unsubscribe());
    }
}
</code></pre>

<p>However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    destroy$ = new Subject();
    ngOnInit() {
        // interval$: 0--1--2--3--4--5--6--...
        // destroy$:  -------------true|
        // result:    0--1--2--3--4|
        const interval$ = interval(1000);
        interval$
            // let the interval$ stream live 
            // until the destroy$ Subject gets a value
            .pipe(takeUntil(this.destroy$))
            .subscribe(r =&gt; console.log(r));
    }

    ngOnDestroy() {
        // when the component get's destroyed, pass something to the
        // destroy$ Subject
        this.destroy$.next(true);
    }
}
</code></pre>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService)
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // VERY BAD: nesting subscribes is ugly and takes away
        // the control over a stream
        this.route.params
            .pipe(map(v =&gt; v.id))
            .subscribe(id =&gt; 
                this.userService.fetchById(id)
                    .subscribe(user =&gt; this.user = user))
    }
}
</code></pre>

<p>The previous implementation is considered a bad-practice. It’s recommended to use <strong>higher-order streams</strong> like <code>mergeMap</code> or <code>switchMap</code>. Let’s have a look at this example:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) 
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // GOOD: we have created a single subscribe which makes
        // the flow way easier and gives us the control we need
        this.route.params
            .pipe(
                map(v =&gt; v.id),
                switchMap(id =&gt; this.userService.fetchById(id))
            )
            .subscribe(user =&gt; this.user = user)
    }
}
</code></pre>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that’s simply how observables work. But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code>async pipe</code>. It’s used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don’t have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let’s have a look at the cleaned up previous example:</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // expose a user$ stream that will be 
    // subscribed in the template with the async pipe
    user$ = this.route.params.pipe(
        map(v =&gt; v.id),
        switchMap(id =&gt; this.userService.fetchById(id))
    );

    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) {
    }
}
</code></pre>

<p>If you are into <a href="https://reactjs.org/">React</a>, I’ve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don’t pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That’s the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // this http call will get called when the 
    // user-detail component subscribes to users$
    // We don't want that
    users$ = this.http.get(...);
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent implements OnInit {
    @Input() user$: Observable&lt;User&gt;;
    user: User;
    ngOnInit(){
        // WHOOPS! This child component subscribes to the stream
        // of the parent component which will do an automatic XHR call
        // because Angular HTTP returns a cold stream
        this.user$.subscribe(u =&gt; this.user = u);
    }
}
</code></pre>

<p>It would be better to handle the subscription in the parent component itself:</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent implements OnInit {
    users$: Observable&lt;User[]&gt; = this.http.get(...);
    user: User;
    ngOnInit(){
        // the app component (smart) subscribes to the user$ which will
        // do an XHR call here
        this.users$ = this.http.get(...);
    }
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent {
    // This component doesn't even know that we are using RxJS which
    // results in better decoupling
    @Input() user: User;
}
</code></pre>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don’t pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don’t know what’s going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don’t care that your components are using streams. Take this example for instance:</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
class AppComponent {
     users$ = this.http.get(...)
     filteredusers$ = this.fooService
        .filterUsers(this.users$); // Passing stream directly: BAD
    ...
}

// foo.service.ts
class FooService {
    // return a stream based on a stream
    // BAD! because we don't know what will happen here
    filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; {
        return users$.pipe(
            map(users =&gt; users.filter(user =&gt; user.age &gt;= 18))
    }
}
</code></pre>

<p>It would be better to use higher order streams for these situations.
Use <code>switchMap</code> over <code>mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
class AppComponent {
    users$ = this.http.get(...)
    filteredusers$ = this.users$
        .pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));
    ...
}

// foo.service.ts
class FooService {
    // this is way cleaner: this service doesn't even know
    // about streams now
    filterUsers(users: User[]): User[] {
        return users.filter(user =&gt; user.age &gt;= 18);
    }
}
</code></pre>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code>http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code>numberOfUsers$</code> depends on <code>users$</code>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// BAD
class AppComponent {
    users$ = this.http.get(...)
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>In those cases we might want to share the subscriptions. The following example uses the <code>share()</code> operator:</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// GOOD
class AppComponent {
    users$ = this.http.get(...).pipe(share());
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code>shareReplay(1)</code> instead of <code>share()</code>. This will keep the last value in memory for us.</p>

<p>It’s a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code>async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `
})
class AppComponent {
    // This stream will only subscribed to once
    users$ = this.http.get(...);
}
</code></pre>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn’t make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it’s ok to use Subjects in the following scenarios:</p>
<h4 id="when-mocking-streams-in-tests">When mocking streams in tests</h4>

<pre><code class="language-typescript">const fetchAll$ = new Subject(); // use a Subject as a mock
usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
fetchAll$.next(fakeUser);
</code></pre>

<h4 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h4>

<pre><code class="language-typescript">@Component({
    ...
    template: `
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `
})
class AppComponent {
search$ = new Subject(); // ----t-----te-----ter----term...
}
</code></pre>

<h4 id="when-handling-circular-references">When handling circular references</h4>

<p>I’m not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code>getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<pre><code class="language-typescript">    foo$.pipe(
        map(...)
        filter(...)
        tap(...)
    )
</code></pre>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that’s personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it’s recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code>ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code>Form</code> and <code>FormControl</code> both have a <code>valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code>ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the “Advanced RxJS in Angular workshop” from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Safe image requests in angular</title>
	  <link>//safe-image-requests-in-angular/</link>
	  <author></author>
	  <pubDate>2017-10-24T00:00:00+00:00</pubDate>
	  <guid>//safe-image-requests-in-angular/</guid>
	  <description><![CDATA[
	     <p>We all know how to load images in a web-application right? We would just make use of the img DOM-element, define its src attribute and we are good to go. Everything would happen automatically. However, there is a big security-issue with this approach.</p>

<p>Take this hypothetical application for instance: We have an app that is used to manage pictures and this particular app can have multiple users. It makes sense that every user owns their own images, right? For privacy reasons user A could never consume the images of user B. Since images are loaded through the DOM with the img DOM-element, it might be hard to add authorization there. Take this angular snippet for instance:</p>

<pre><code class="language-typescript">@Component({
    template: `
        &lt;img [src]="img.src"/&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
}
</code></pre>

<p>Since the browser just loads this image through a normal HTTP call, how is the server supposed to know if user A or user B is trying to consume this image? The server needs some kind of authorization to be passed to it.</p>

<h2 id="passing-the-authorization-with-session-cookies">Passing the authorization with Session cookies</h2>

<p>We could use session cookies, which kinda works like this: The user authenticates with the backend of our app, receives a session cookie which will be passed with every future request. That way the backend knows who is trying to consume the resource in question.</p>

<p>Some could argue that session cookies are not to way the go, and stateless backends are better and more scalable.
If we use JWT or any other modern authentication system we would rather send <strong>authorization-headers</strong> instead of using the session cookie approach. The value that our server should receive in the authorization-header is called a <strong>Bearer token</strong>.</p>

<h2 id="passing-the-authorization-without-cookies">Passing the authorization without cookies</h2>

<p>Let’s explore 2 different methods to pass Bearer tokens to the backend:</p>

<h3 id="passing-the-token-in-the-url">Passing the token in the url</h3>

<p>In this case we would just pass the token as a <strong>query parameter</strong> in the url. The previous snippet would now look like this:</p>

<pre><code class="language-typescript">@Component({
    template: `
        &lt;img [src]="img.src + '?bearer=' + bearToken"/&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
    bearerToken  = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
}
</code></pre>

<p>The url of the server request would now look like this: <em>https://angular.io/assets/images/logos/angular/logo-nav@2x.png?bearer=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9…</em></p>

<p>Based on the token, the server knows which user tries to load the image and can block unauthorized users of fetching that image.</p>

<p>There are a few tradeoffs:</p>

<ul>
  <li>The Token is there for everyone to see in the URL (less secure, but then again, they could still check it in the offline-storage)</li>
  <li>Every time the token changes, the cache would be cleared, since the url of the resource changes</li>
  <li>The backend would need a way to handle all the image calls that contain a bearer token in their url</li>
  <li>We need to load and parse the token everywhere we load images in our components</li>
  <li>Doesn’t work for css, unless it’s dynamically created</li>
</ul>

<h3 id="handling-the-images-with-ajax-calls">Handling the images with AJAX calls</h3>

<p>In this approach we will create a generic way of handling image-security by using:</p>

<ul>
  <li>A generic component</li>
  <li>AJAX calls with a blob responseType</li>
  <li>HTTP interceptors (introduced by the new HttpClient in angular 4.3)</li>
  <li>Data urls</li>
</ul>

<p>We would like to consume images like this:</p>

<pre><code class="language-typescript">@Component({
    template: `
          &lt;secured-image [src]="img.src"&gt;&lt;/secured-image&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
}
</code></pre>

<p>Let’s create a <strong>secured-image</strong> component as shown above.
This component needs to handle the following:</p>

<ul>
  <li>Load an image through an AJAX call</li>
  <li>Create a data url based on a blob</li>
  <li>When the source changes:
    <ul>
      <li>Cancel the previous AJAX call (if it’s still busy)</li>
      <li>Start loading the new resource through AJAX</li>
    </ul>
  </li>
  <li>When the component gets destroyed, cancel the current AJAX call (if it’s still busy)</li>
</ul>

<p>In the beginning, this might look like this:</p>

<pre><code class="language-typescript">@Component({
  selector: 'secured-image',
  template: `
    &lt;img [src]="dataUrl$|async"/&gt;
  `
})
export class SecuredImageComponent implements OnChanges  {
  // This code block just creates an rxjs stream from the src
  // this makes sure that we can handle source changes
  // or even when the component gets destroyed
  // So basically turn src into src$
  @Input() private src: string;
  private src$ = new BehaviorSubject(this.src);
  ngOnChanges(): void {
    this.src$.next(this.src);
  }

  // this stream will contain the actual url that our img tag will load
  // everytime the src changes, the previous call would be canceled and the
  // new resource would be loaded
  dataUrl$ = this.src$.switchMap(url =&gt; this.loadImage(url))
  
  // we need HttpClient to load the image
  constructor(private httpClient: HttpClient) {
  }

  private loadImage(url: string): Observable&lt;any&gt; {
    return this.httpClient
      // load the image as a blob
      .get(url, {responseType: 'blob'})
      // create an object url of that blob that we can use in the src attribute
      .map(e =&gt; URL.createObjectURL(e))
  }
}

</code></pre>

<p>This pretty much covers everything, but if we check it in the browser we get the following error.
<strong>WARNING: sanitizing unsafe URL value blob:https://localhost:4200/da89c71e-5df2-4842-af06-993cd5263471 (see http://g.co/ng/security#xss)</strong></p>

<p>Loading the image through AJAX does not work yet because we haven’t sanitized the url yet. For that we need the <strong>DomSanitizer</strong> that angular provides us. This is a security mechanism to protect the app from XSS-attacks. We basically have to tell angular which urls to trust.</p>

<pre><code class="language-typescript">export class SecuredImageComponent implements OnChanges  {
  ...
  // inject the domSanitizer here as well
  constructor(private httpClient: HttpClient, private domSanitizer: DomSanitizer) {
  }

  private loadImage(url: string): Observable&lt;any&gt; {
    return this.httpClient
      .get(...)
      // pass the url through the domSanitizer so angular knows he can parse it
      .map(e =&gt; this.domSanitizer.bypassSecurityTrustUrl(URL.createObjectURL(e)))
  }
}

</code></pre>

<p>We now have a fully working way of loading images through AJAX calls. However, we still haven’t passed our Bearer token.
We could add the the authorization header in the get call directly, but let’s find a cleaner solution.
Since we use httpClient, this opens up a few doors for us.
The new HttpClient, which was introduced in angular 4.3 offers a few new features. One of these features are <strong>interceptors</strong>.
Interceptors are a way to hook into http calls that are being made by the new HttpClient.</p>

<p>This would be a perfect solution to pass the bearer token wouldn’t you agree?</p>

<p>Let’s create the interceptor and register it to angular.</p>

<pre><code class="language-typescript">// my-http.interceptor.ts
@Injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  // intercept any http call done by the httpClient
  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    // fetch the bearer token from wherever you have stored it
    // NOTE: fetching it directly from window is not a good idea (demo purpose)
    const jwtToken = window.localStorage.getItem('jwtToken');

    // if there is a token, clone the request and set the correct
    // authorization header, if not =&gt; just use the old request
    const requestToHandle = jwtToken
      ? request.clone({
        headers: request.headers.set('authorization', `Bearer ${jwtToken}`)
      })
      : request;
    return next.handle(requestToHandle);
  }
}

// app.module.ts
@NgModule({
  ...
  // don't forget to import the HttpClientModule
  imports: [ BrowserModule, FormsModule, HttpClientModule ],
  providers: [{
    // register the interceptor to our angular module
    provide: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true
  }]
})
export class AppModule { }
</code></pre>

<p>If you would like to learn more about interceptors, check this <a href="https://juristr.com/blog/2017/08/intercept-http-requests-in-angular/">awesome article</a> by <a href="https://twitter.com/juristr">Juri Strumpflohner</a>.
He also has an amazing egghead course on that subject.</p>

<p>Right now, every call that the secured-image component has initiated will load the image through AJAX with the right authorization header. That way the server can check who has been asking for that specific resource.</p>

<p>However, this approach also introduces a few tradeoffs:</p>

<ul>
  <li>CORS headers for CDN resources. Since we are using a GET AJAX call there will be extra OPTIONS calls.</li>
</ul>

<p>Extra advantages:</p>
<ul>
  <li>It’s easier to handle the loading of the image, show a spinner or animation</li>
  <li>Doesn’t work for css, unless it’s dynamically created</li>
</ul>

<p>You can find the complete source of a working version in this <a href="https://stackblitz.com/edit/secure-image-loads">stackblitz example</a>.</p>

<h2 id="thanks-for-reading">Thanks for reading</h2>
<p>I hope you all liked this article, if you have questions, shoot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>A scalable angular architecture (part 2)</title>
	  <link>//A-scalable-angular-architecture-part2/</link>
	  <author></author>
	  <pubDate>2017-08-13T00:00:00+00:00</pubDate>
	  <guid>//A-scalable-angular-architecture-part2/</guid>
	  <description><![CDATA[
	     <h1 id="the-sandbox-pattern">The sandbox pattern</h1>

<h2 id="introduction">Introduction</h2>
<p>A while ago I released a blogpost called “<a href="http://blog.brecht.io/A-scalable-angular2-architecture/">A scalable angular 2 architecture</a>” which was all about creating large scale enterprise webapplications. The title should actually have been <strong>“A scalable angular architecture”</strong> (It’s just angular) or even, <strong>“A scalable SPA architecture”</strong> since we can use the same architecture for <a href="https://facebook.github.io/react/">React</a> or <a href="https://vuejs.org">Vue.js</a>.</p>

<p>It’s been over a year now, since I’ve been introducing that specific architecture in companies and projects. Nowadays, I know quite a few people that are using this particular architecture in their projects.
Often, I ask developers about how they feel about this SPA-architecture and the feedback is mostly this:
They believe its a <strong>clear and opiniated way</strong> to structure their code, and they have no trouble, finding their way into the codebase.</p>

<p>A big part of the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">article</a> in question, was about explaining the so called “sandboxes”, a personal terminology for a very specific kind of facade.
Since writing that <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">article</a> raised a bunch of questions about these “sandboxes”, it seemed like a good idea to write a followup article.</p>

<p>In this article we will cover what sandboxes are really about and why I introduced them in the first place.</p>

<p><strong>Note: This architecture is only one way of structuring your applications and the statements being made in this article are completely personal and might be opiniated.</strong></p>

<h2 id="what-is-a-sandbox-in-a-nutshell">What is a sandbox in a nutshell</h2>

<p>In real life it’s a place where we can put our children together with a limited set of toys. That way, they can only play with those toys and have fun, and we as parents wouldn’t have to worry about them running around in the garden.</p>

<p>In this architecture a sandbox is a controlled environment, and the only place where components can consume pieces of the application.
It’s the only interface for our smart components to communicate with the rest of the application. It’s a facade that abstracts away logic from our components. It does have very specific logic though.</p>

<h2 id="here-is-why-i-introduced-sandboxes">Here is why I introduced sandboxes</h2>

<p>One of the most challenging parts of creating big clientside javascript applications is encapsulation and dividing responsibilities. Having a decent encapsulated structure where every component, service, class has a clear reason of existence, makes it easy for us as developers to maintain the code and develop new features.</p>

<p>When writing single-page-applications one could face the following challenges:</p>

<h3 id="challenge-1-how-do-we-structure-components">Challenge 1: How do we structure components?</h3>

<p>Since this topic is covered in the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">previous article</a>, we won’t do a deepdive in this subject.
We use the smart/dumb component approach to structure our components. The dumb components mostly have presentational purposes and the smart components interact with the rest of the application.</p>

<h3 id="challenge-2-how-do-we-handle-statemanagement">Challenge 2: How do we handle statemanagement?</h3>

<p>Another topic covered by the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">previous article</a> is how handle our statemanagement. In short: we use @ngrx/store, or another redux implementation that embraces reactive programming.</p>

<h3 id="challenge-3">Challenge 3</h3>

<p>The first two challenges are met: we have a clear and structured presentational layer and because of the fact that we use @ngrx/store (or any statemanagement tool for that matter), we have a clear way of managing state. We can optimise performance with immutable data and still have clear unidirectional dataflow.</p>

<p>However, there are still a few pieces of the puzzle missing, which might raise the following questions:</p>

<h4 id="how-do-we-separate-the-presentation-layers-from-the-rest-of-the-application">How do we separate the presentation-layers from the rest of the application?</h4>

<p>If we inject whatever we want in our smart components, their constructors might get huge in no-time. Do those smart components really need to know everything about the application? Do they need to know where everything lives and what service it should call from which module in the application? Wouldn’t it be easier if they had an interface they could talk to, that just handles things for them?
It would certainly help to decouple angular modules from each other, and keep the responsibility of those smart components clear and compact. <strong>This is something a sandbox might be able to help us with.</strong></p>

<h3 id="do-our-components-need-to-know-about-redux">Do our components need to know about redux?</h3>

<p>Redux is an awesome library/principle that helps us ace statemanagement, but it’s a really heavy dependency if you don’t manage it carefully. What if your <strong>very specific</strong> redux actions would be everywhere in your components and services? In that case your codebase would be completely affected by it and it would be very hard to use another statemanagement tool in the future. It would be impossible to share that code in non-redux applications.
It would be a huge depencency… What if you like to switch to firebase for instance, or MOBX, or even write your own statemanagement tool. You would need to refactor your whole application. The sole principle of redux is to manage state, and I prefer to use it that way. That is also why I don’t really use effects, thunk or saga. (That’s a personal preference)
For me this means: <strong>Use redux only to manage state, not to trigger backend actions etc</strong>
One could even argue that the action-dispatching and state-selecting should be combined in central places in your appliction.
 <strong>Let’s add that logic to the sandboxes as well.</strong></p>

<h4 id="do-our-http-services-need-to-know-about-a-redux-implementation">Do our HTTP services need to know about a redux implementation?</h4>

<p>Well, as the name already reveals. An HTTP service is all about doing HTTP communication and returning asynchronous objects to the components. An HTTP service should have no notion about redux at all nor any other statemanagement tool. Its sole purpose is fetching data and returning it. Let’s take a look at the following example for instance. We fetch an array of wines from the backend and we want to persist that in a redux store. This is an example of an HTTP service that is being abused to achieve that:</p>

<pre><code class="language-typescript">class WineService {
	// bad
	fetchWines(): void {
		this.api.get('url')
			.subscribe(wines =&gt; 
				this.store.dispatch({type: 'SET_WINES', payload: {wines}});
	}
}
</code></pre>

<p>This code doesn’t belong here, it’s not the responsibility of that service. The question is where does it belong?
Does it belong in the component? They would get dirty and reduxy in no-time…
<em>*Again, this would belong to the sandbox!</em>.</p>

<p>An http service should look like this:</p>

<pre><code class="language-typescript">class WineService {
	// good
	fetchWines(): Observable&lt;any&gt; {
		return this.api.get('url')
	}
}
</code></pre>

<h4 id="on-what-place-do-we-dispatch-actions-to-the-store">On what place do we dispatch actions to the store?</h4>

<p>Err…, the sandbox =)</p>

<h4 id="where-do-we-handle-optimistic-updates">Where do we handle optimistic updates</h4>

<p>Again, that would be the sandbox</p>

<h4 id="how-to-not-make-your-whole-application-smell-like-redux">How to NOT make your whole application smell like REDUX</h4>

<p>Components and services should not know about redux, so the store interaction should be in a very specific place as well.</p>

<p>I bet you saw it coming, but YES! That’s what a sandbox is all about! It’s about separation of concerns and having a very specific interface to handle this very specific logic.</p>

<h2 id="what-does-a-sandbox-do">What does a sandbox do?</h2>

<p>A sandbox has a very specific responsibility:</p>

<ul>
  <li>It lets your module communicate with other modules without that module having to know about the rest of the application</li>
  <li>It sends Redux actions</li>
  <li>It exposes streams of data (coming from Redux, Firebase or other technologies)</li>
  <li>It handles optimistic updates</li>
  <li>It keeps the containers stupid enough</li>
</ul>

<h2 id="whats-very-specific-on-a-sandbox">What’s very specific on a sandbox?</h2>

<ul>
  <li>They handle what the container tells them to handle, without the container having to know how…</li>
  <li>They interact between modules</li>
  <li>They handle a lot of redux (or similar technology) logic</li>
  <li>The functions mostly have a void return-type, unless we want to be able to cancel HTTP calls</li>
  <li>They expose observables/streams</li>
  <li>It mostly contains redundant code, but no redundant logic (it’s all about KISS instead of DRY)</li>
  <li>Mostly every module has a sandbox, unless it contains a huge amount of logic (in that case we could implement a sandbox for every container)</li>
  <li>It does not contain business logic, ever…</li>
  <li>It mostly doesn’t contain if-statements, that would be business logic right?!</li>
  <li>It gives us a clear overview of the responsabilities of a module.</li>
</ul>

<h2 id="what-doesnt-a-sandbox-do">What doesn’t a sandbox do?</h2>

<ul>
  <li>It doesn’t contain business logic. It contains sandbox logic (see above).</li>
  <li>It doesn’t contain presentation logic, like routing etc.</li>
  <li>It doesn’t do HTTP calls directly, it delegates to http services.</li>
  <li>It doesn’t let your components do whatever they want =)</li>
</ul>

<h2 id="an-example">An example</h2>

<pre><code class="language-typescript">@Injectable()
export class StockSandbox {
	// these are the store select statements
	// It's pretty dirty to have them all over our components
	// Our components just want to get streams of data, no matter where they come from
	wines$ = this.store.select(state =&gt; state.wines);
	isAuthenticated$ = this.store.select(state =&gt; state.authentication.isAuthenticated);

	constructor(
		private store: Store&lt;ApplicationState&gt;, 
		private stockService: StockService,
		private fooService: FooService) {
	}

	addWine(wine: Wine): void {
		// use the stockservice to add a wine
		// and when it's done handle our statemanagement
		this.stockService.add(wine).subscribe((wine: Wine) =&gt; {
			this.store.dispatch(new AddWine(wine));
		}, () =&gt; this.handleError());
	}

	 removeWine(wine: Wine): void {
		// removing a wine can be done optimistically!
		// this would certainly improve the performance and snappyness of our app
		// this would be sandbox logic
		let action = new RemoveWine(wine._id);
		this.store.dispatch(action);
		this.stockService.remove(wine).subscribe(
			() =&gt; {}, 
			// if the call failed, we have to undo an action. This is sandbox logic as well!
			() =&gt; this.store.dispatch({type: UNDO_ACTION, payload: action}););
	}

	fetchWine(id: string): Observable&lt;Wine&gt; {
		// simple delegation of fetching something: Sandbox logic
		return this.stockService.fetchWine(id).share();
	}

	notifyAnotherModule(): void {
		// our components should NOT know where fooService is, or what it does
		// it should just tell its sandbox to handle a specific action
		this.fooService.doSomething();
	}
}
</code></pre>

<p>Look how clean this smart component has become:</p>
<pre><code class="language-typescript">export class StockPageContainer {
    wines$ = this.sb.wines$; // Does this stream comes from Redux? or Firebase (I don't need to know)
    numberOfWines$ = this.wines$.map(wines =&gt; sumBy(wines, (wine: Wine) =&gt; wine.inStock));

	// a clean constructor makes it easy to test.
	// Util dependencies or presentational dependencies like a router
	// do not belong in the sandbox.
	// They belong right here in the component, in the presentational layer.
    constructor(private sb: StockSandbox, private router: Router) {
    }

    onRemove(wine: Wine): void {
		// Hey Sandbox! Remove the wine please, I don't care how you do it
		// I don't even care that you do optimistic updates, it's not my business
        this.sb.removeWine(wine);
    }

    notifyAnotherModule(): void {
		// I don't know what will happen, but that's okay... It's not my responsability
        this.sb.notifyAnotherModule(); 
    }
}

</code></pre>

<p>I hope this clarifies the purpose of the sandbox and why I have introduced them in my projects.
If you still have questions about this approach, don’t hesitate to contact me =)</p>

<h3 id="special-thanks">Special thanks</h3>
<p>Special thanks to <a href="'https://twitter.com/ManfredSteyer'">Manfred Steyer (@manfredsteyer)</a> and <a href="https://twitter.com/juristr">Juri Strumpflohner (@juristr)</a> for reviewing this article!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Thinking reactively in Angular and RXJS</title>
	  <link>//thinking-reactively-in-angular-and-rxjs/</link>
	  <author></author>
	  <pubDate>2017-07-25T00:00:00+00:00</pubDate>
	  <guid>//thinking-reactively-in-angular-and-rxjs/</guid>
	  <description><![CDATA[
	     <h2 id="foreword">Foreword</h2>

<p>RxJS is an awesome library that can help us with creating <strong>reactive web applications</strong>. Reactive web applications can be overwhelming in the beginning, but eventually, they can be really rewarding.</p>

<p>This article is all about making the paradigm switch from thinking imperatively towards <strong>thinking reactively</strong>.
In this article, we will explain how to write a reactive calendar application in only a few lines of code (<strong>spoiler: It’s gonna be real time too</strong>).</p>

<p>We will use Angular, Angular Material, TypeScript, RxJS, Firebase, and AngularFire as our main technology stack. Keep in mind that this article really focusses on reactive programming. Don’t expect a deep dive into all RxJS operators, but rather expect an explanation of how to draw, think, and reason about reactive web applications. We will learn <strong>how to think in streams</strong>. If you haven’t heard of streams yet, please read <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this awesome article</a> first.</p>

<p><strong>Note:</strong> This article contains personal terminology.</p>

<h2 id="the-reactive-calendar">The Reactive Calendar</h2>
<p>This is the application we are going to write. It’s a small but complete calendar application that allows us to:</p>

<ul>
  <li>Switch between different view modes: day, week, month.</li>
  <li>Navigate to previous and next days, weeks, and months.</li>
  <li>Add, update, and remove appointments.</li>
  <li>Search for specific appointments.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar1.png" alt="Reactive calendar" /></p>

<p>The user can interact with the following UI elements:</p>

<ul>
  <li><strong>Next button:</strong> Allows the user to go to the next day in day mode, week in week mode, etc.</li>
  <li><strong>Previous button:</strong> Allows the user to go to the previous day in day mode, week in week mode, etc.</li>
  <li><strong>Day, week, month buttons:</strong> Allows the user to switch between the different view modes</li>
  <li><strong>Search term input:</strong> Allows the user to filter the appointments on the fly</li>
  <li><strong>Plus-buttons in the grid:</strong> Allows the user to create new appointments</li>
  <li><strong>Trashcan buttons in the grid:</strong> Allows the user to remove appointments</li>
  <li><strong>Description inputs:</strong> Allows the user to update the description of an appointment</li>
</ul>

<p>I decided to use Firebase as a backend and because of that, our application will be realtime and offline first by default!</p>

<p><strong>Note:</strong> One small issue, I’ve been a bit lazy so we can only create lunch appointments. =) But hey! Consider it some homework.</p>

<h2 id="setting-up-the-project">Setting Up the Project</h2>

<p>I’ve created the git branch <strong>initial</strong> to get us started. It contains the default logic/components, setup, and styles. There is no reactive code written yet, just plain Angular code. The goal is to write the reactive part ourselves.</p>

<h3 id="the-component-tree">The Component Tree</h3>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar3.png" alt="The component tree" />
The dumb components (blue) are already implemented. The <code>app-root</code> (orange) is the one and only smart component in the application and the only place where we will write code.</p>

<p>If you don’t know the difference between smart and dumb components, <a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">read this first</a>.</p>

<h3 id="installing-the-project-locally">Installing the Project Locally</h3>
<p>First of all, we have to clone the project locally and check out the <strong>initial</strong> branch. This branch already contains all the uninteresting parts that don’t have anything to do with this article.</p>

<p>In the terminal, we have to go to the folder where we want to install the project and run the following commands:</p>

<pre><code>$ git clone git@github.com:brechtbilliet/reactive-calendar.git
$ cd reactive-calendar/reactive-calendar
$ git checkout initial
$ npm install
</code></pre>

<h3 id="setting-up-firebase">Setting Up Firebase</h3>

<p>We are using <a href="https://firebase.google.com/">Firebase</a> as our backend because it requires minimal setup, it’s realtime by default, and <a href="https://github.com/angular/angularfire2">AngularFire</a> gives us streams for free. We can complete the Firebase configuration in a few steps:</p>

<ul>
  <li>Go to <a href="https://firebase.google.com/">https://firebase.google.com</a>, click on the “GO TO CONSOLE” button, and choose your Google account.</li>
  <li>Click on the “Add project” button and choose a name for your project. Let’s take <strong>“reactive-calendar”</strong> to keep it simple.</li>
  <li>Click on the “CREATE PROJECT” button. Now we should be redirected to <a href="https://console.firebase.google.com/project/reactive-calendar/overview">something like this</a>.</li>
  <li>In the Authentication tab, go to “SIGN-IN METHOD” and enable the “Anonymous” setting.</li>
  <li>Click on database and navigate to the rules tab. Set the read and write property to “true” and click “publish”:
    <pre><code class="language-json">{
  "rules": {
      ".read": "true",
      ".write": "true"
  }
}
</code></pre>
  </li>
  <li>Go back to the overview by clicking on the home icon, and then select “Add Firebase to your web app”.</li>
  <li>Copy the config with the correct properties and replace the firebaseConfig object in src/app/app.module.ts with these properties.
It might look something like this:</li>
</ul>

<pre><code class="language-typescript">const firebaseConfig = {
    apiKey: "AIzaSyBuqjTJd5v6xTf8D2EZmvFUl8lseH8lVuHU",
    authDomain: "reactive-calendar.firebaseapp.com",
    databaseURL: "https://reactive-calendar.firebaseio.com",
    projectId: "reactive-calendar",
    storageBucket: "reactive-calendar.appspot.com",
    messagingSenderId: "3978123451455750"
};
</code></pre>

<p>Let’s continue. Start the project by running the following command and open your browser on <a href="http://localhost:4200">http://localhost:4200</a>.</p>

<pre><code>npm start
</code></pre>

<p>As you can see, this just handles static data, the buttons/inputs won’t work, and the appointments are not loaded yet.
This is where we start from.</p>

<h2 id="thinking-reactively">Thinking Reactively</h2>

<p>Now comes the tricky part. We are trying to forget imperative programming for now, and we are trying to evolve into a reactive mindset.</p>

<h3 id="marble-diagrams">Marble Diagrams</h3>

<p>To be able to think reactively, we need some kind of graphic model so we can picture streams in our head. Marble diagrams are a great way to do that.
As you can see in the image below, a marble represents a value over time.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar12.png" alt="Marble diagrams" /></p>

<p>The website <a href="http://rxmarbles.com/">rxmarbles.com</a> has a great playground for learning how to use and draw marble diagrams.</p>

<h4 id="ascii-documentation">ASCII Documentation</h4>

<p>One could argue that code should not be documented and be self-explanatory. I don’t believe that to be the case when writing complex streams. When we document complex streams, we can see what’s going on inside the stream, which makes it easier for our colleagues.
Streams can be documented by ASCII documentation. Since that is not really part of this article, I’m only going to show a small example below.</p>

<pre><code class="language-typescript">// a$ gets three values over time and then stops
// a$: -------a-----b-----c|

// b$ has an initial value (a), has three values in total
// and will keep on living
// b$: a------b-----c------...
</code></pre>

<h3 id="imperative-programming-what-does-the-app-have-to-do">Imperative Programming: What Does the App Have to Do?</h3>

<p>When we think about the functionality of our application, we quickly notice that there are quite a few corner cases and special scenarios. For every interaction the user makes in the UI, the app needs to handle that specific interaction accordingly. Sometimes it has to combine these interactions and handle that specific combination as well. Take this crazy (but simple) example, for instance.</p>

<blockquote>
When the view mode is changed to week mode, and the previous view mode was month mode, and the month was June, and the year was 2017, and an appointment was added, while the search term was set to "Brecht", then we would have to update...
</blockquote>

<p>Yes, we would have to update a bunch of stuff. This is imperative thinking, and it can become exhausting. There is a big chance that we forget certain corner cases. Let’s not even imagine that we have to combine that with asynchronous actions as well.</p>

<p>In the image below, we see all the different interactions the user has in the calendar application.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar2.png" alt="Application events" /></p>

<p>As we can see, for every specific interaction, the UI will have to update specific things.</p>

<h3 id="reactive-programming-what-data-will-change-and-what-data-do-the-components-need">Reactive programming: What Data Will Change, and What Data Do the Components Need?</h3>

<h4 id="source-streams">Source Streams</h4>

<p>Now, let’s completely stop with what we are thinking. Let’s free our minds and stop thinking about corner cases and special scenarios. We have to learn to think in streams. A stream is a collection of events that will change over time. Think about what can change in your application and call these streams of data. Let’s call them <strong>source streams</strong>.</p>

<p><strong>Note:</strong> For readability purposes, we will suffix all the streams with a <code>$</code> symbol.</p>

<p>We can come up with 4 source streams:</p>

<ul>
  <li><strong>navigation$:</strong> Can contain the values: -1, 0 or 1</li>
  <li><strong>viewMode$:</strong> Can contain the values: DAY, WEEK, or MONTH</li>
  <li><strong>searchTerm$:</strong> The value of the search field</li>
  <li><strong>appointments$:</strong> This is an array of appointments that comes from Firebase</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar4.png" alt="data streams" /></p>

<p>That was pretty easy. We just had to think about the events that can occur in our application. A user can navigate, change view mode, search for appointments, and the appointments in Firebase can change. This is the beginning of thinking reactively. Don’t think about who triggers what. Think about the changes as streams.</p>

<p>It’s always a good idea to draw marble diagrams to make it easier to reason.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar5.png" alt="data stream diagram" /></p>

<p><code>The appointments$</code> is a stream that will be provided to us by AngularFire, but the <code>viewMode$</code>, <code>searchTerm$</code>, and <code>navigation$</code> are simple behavior subjects. We use subjects because we need to control the values of the streams ourselves, and we use the <code>BehaviorSubject</code> in particular because all our source streams need an initial value.</p>

<pre><code class="language-typescript">export class AppComponent {
    ...
    // this is how we can retrieve the list of appointments from angularfire
    appointments$ = this.db.list('/appointments');
     // 0--------(+1)----(+1)----(-1)-------------...
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    navigation$ = new BehaviorSubject(0);
    searchTerm$ = new BehaviorSubject('');

	// because we set up the angularfire configuration correctly, we can just
	// inject the angularfiredatabase right here and use it
    constructor(private db: AngularFireDatabase) {
    }
    ...
}

</code></pre>

<p>These subjects get values from the simple interactions from the template.</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        ...
    `
})
export class AppComponent {
    ...
    
    onSetViewMode(viewMode: string): void {
        // when the viewmode changes, update its subject
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        // when the user clicks the previous button
        // update the navigation subject
        this.navigation$.next(-1);
    }

    onNext(): void {
        // when the user clicks the next button
        // update the navigation subject
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        // when the user searches
        // update the searchterm subject
        this.searchTerm$.next(e);
    }
}

</code></pre>

<h4 id="presentational-streams">Presentational Streams</h4>

<p>Now we have to think about the data that our components need, because those components will need to be updated based on those source streams.
Let’s take this code sample, for instance:</p>

<pre><code class="language-html">&lt;div [ngSwitch]="XX" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="XX"
            [date]="XX"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="XX"
            [year]="XX"
            [week]="XX"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="XX"
            [year]="XX"
            [appointments]="xxx"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>I marked the input properties with XX to show what our components need in terms of data. These places will need streams as well. Let’s call them <strong>presentational streams</strong>.</p>

<p>Let’s try to fill in these gaps, shall we?</p>

<p><strong>Note:</strong> We use the <a href="https://angular.io/api/common/AsyncPipe">async pipe</a> from Angular to subscribe/unsubscribe the streams automatically.</p>

<pre><code class="language-html">&lt;div [ngSwitch]="viewMode$|async" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="filteredAppointments$|async"
            [date]="currentDate$|async"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="filteredAppointments$|async"
            [year]="currentYear$|async"
            [week]="currentWeek$|async"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="currentMonth$|async"
            [year]="currentYear$|async"
            [appointments]="filteredAppointments$|async"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>We have gathered the 6 following presentational streams:</p>

<ul>
  <li><strong>viewMode$ (string):</strong> needed to determine which view has to be shown</li>
  <li><strong>filteredAppointments$ (Array &lt; Appointment &gt;):</strong> needed by day view, week view, and month view to render the correct appointments</li>
  <li><strong>currentDate$ (date):</strong> the current date for the day view</li>
  <li><strong>currentWeek$ (number):</strong> the current week for the week view</li>
  <li><strong>currentYear$ (number):</strong> needed by week view and month view</li>
  <li><strong>currentMonth$ (number):</strong> needed by the month view</li>
</ul>

<p>Okay, great, we know the source streams, which are the sources of change in our application.
We know the presentational streams, which are simply the streams that our components need. Now it’s time for the cool part: <strong>We need to create those presentational streams based on the source streams</strong>.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar6.png" alt="sources to presentational streams" /></p>

<p>The first presentational stream we need is <code>viewMode$</code>. This is already an easy one, since <code>viewMode$</code> is also a source stream.</p>

<h4 id="currentdate">currentDate$</h4>
<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar7.png" alt="currentDate$" /></p>

<p><strong>Note:</strong> We use moment.js for date calculation. The suffix M after the currentDate property shows that the type is <code>Moment</code>. So in short, it’s not just a date, but a moment wrapper.</p>

<pre><code class="language-typescript">// we will need this stream a few times, so let's extract the stream 
// in a currentDateM first

// viewMode$:     M------------------W---------------D--------...
// navigation$:   0---(+1)-(-1)----------(+1)-(-1)------------...
// currentDateM$: d---d----d---------d---d----d------d--------...
private currentDateM = this.viewMode$.flatMap((viewMode: string) =&gt; {
    // every time the viewMode changes, the navigation should be reset as well
    // the dateM variable will contain the navigation and because of the 
    // flatMap it will reset every time the view mode changes
    // if the navigation$ changes afterwards it will manipulate the dateM object
    // by adding months, weeks, or days depending on the viewMode
    const dateM = moment();
    return this.navigation$
        .map((action: number) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return dateM.startOf('month').add(action, "months");
                case VIEW_MODE.WEEK:
                    return dateM.startOf('week').add(action, "weeks");
                case VIEW_MODE.DAY:
                    return dateM.startOf('day').add(action, "days");
            }
            return dateM;
        })
})
currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());

</code></pre>

<h4 id="currentweek">currentWeek$</h4>

<p>Based on the <code>currentDateM$</code> we can calculate the current week. The <code>currentDateM$</code> is just a moment object of the current date based on the navigation and viewMode.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar8.png" alt="currentWeek$" /></p>

<pre><code class="language-typescript">currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
</code></pre>

<h4 id="currentmonth">currentMonth$</h4>

<p>Just like we calculated the <code>currentWeek$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar9.png" alt="currentMonth$" /></p>

<pre><code class="language-typescript">currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
</code></pre>
<h4 id="currentyear">currentYear$</h4>

<p>Just like we calculated the <code>currentWeek$</code> and the <code>currentMonth$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar10.png" alt="currentYear$" /></p>

<pre><code class="language-typescript">currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
</code></pre>

<h4 id="filteredappointments">filteredAppointments$</h4>

<p>This is the most important stream. It is used to show the appointments in all the different views, and it is dependent on a bunch of streams:</p>

<ul>
  <li>viewMode$</li>
  <li>currentDateM$</li>
  <li>appointments$</li>
  <li>searchTerm$</li>
</ul>

<p>This looks a bit more complex, but let’s give it a go.</p>

<p><strong>Note:</strong> the <code>[]</code> in the image below stands for an empty array, the <code>[.]</code> for an array with one value, and so on.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar11.png" alt="filteredAppointment$" /></p>

<p>Let’s take the time to process this image. The operator we will use to combine all these streams is called <strong>combineLatest</strong>. It will create a stream that will wait until all streams have a value and will start emitting values for every change of every stream.</p>

<p>So basically, it gives us a function where we have all the information we need. The appointments in Firebase, the view mode, the search term, and the current date. Based on those values, we can calculate the appointments for every view:</p>

<pre><code class="language-typescript">filteredAppointments$ = Observable.combineLatest(
    [this.viewMode$, this.currentDateM$, 
    this.appointments$, this.searchTerm$],
    (viewMode: string, currentDateM: Moment, 
        appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
        switch (viewMode) {
            // calculate the appointments for the month-view based on
            // the current date, the appointments in firebase 
            // and the searchterm
            case VIEW_MODE.MONTH:
                return appointments
                    .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
             // calculate the appointments for the week-view based on
             // the current date, the appointments in firebase
             // and the searchterm
            case VIEW_MODE.WEEK:
                return appointments
                    .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
            // calculate the appointments for the day-view based on
            // the current date, the appointments in firebase
            // and the searchterm
            case VIEW_MODE.DAY:
                return appointments
                    .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));

        }
    });

private filterByTerm(appointment: Appointment, term: string): boolean {
    return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
}
</code></pre>

<p>This is all we have to do in order to create a kick-ass realtime reactive calendar application. We have created it in no time and with only a few lines of code. If we think about it, we will soon realize that all corner cases have been covered.</p>

<h2 id="performance-improvements">Performance Improvements</h2>

<p>The complete component looks like the code snippet below now. The calendar should be completely functional in your browser.</p>

<pre><code class="language-typescript">import { Component } from '@angular/core';
import { VIEW_MODE } from '../../constants';
import * as moment from 'moment';
import { Appointment } from '../../types/appointment.type';
import { AngularFireDatabase } from 'angularfire2/database';
import { Observable } from 'rxjs/Observable';
import Moment = moment.Moment;
import { BehaviorSubject } from 'rxjs/BehaviorSubject';


@Component({
    selector: 'app-root',
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        &lt;div [ngSwitch]="viewMode$|async"&gt;
            &lt;day-view
                    *ngSwitchCase="VIEW_MODE.DAY"
                    [appointments]="filteredAppointments$|async"
                    [date]="currentDate$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/day-view&gt;
            &lt;week-view
                    *ngSwitchCase="VIEW_MODE.WEEK"
                    [appointments]="filteredAppointments$|async"
                    [year]="currentYear$|async"
                    [week]="currentWeek$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/week-view&gt;
            &lt;month-view
                    *ngSwitchCase="VIEW_MODE.MONTH"
                    [month]="currentMonth$|async"
                    [year]="currentYear$|async"
                    [appointments]="filteredAppointments$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/month-view&gt;
        &lt;/div&gt;
    `,
    styleUrls: ['./app.component.less']
})
export class AppComponent {
    VIEW_MODE = VIEW_MODE;
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    // 0--------(+1)----(+1)----(-1)-------------...
    navigation$ = new BehaviorSubject&lt;number&gt;(0);
    searchTerm$ = new BehaviorSubject('');

    // -----MONTH---------------------YEAR------...
    // -----MONTH-------------------------------...
    // -----(d)---------------------------------...
    // --------(+1)----(+1)----(-1)-------------...
    // -----d---d-------d-------d-----d----------...

    private currentDateM$ = this.viewMode$.flatMap((viewMode: string) =&gt; {
        let dateM = moment();
        return this.navigation$
            .map((action: number) =&gt; {
                switch (viewMode) {
                    case VIEW_MODE.MONTH:
                        return dateM.startOf('month').add(action, 'months');
                    case VIEW_MODE.WEEK:
                        return dateM.startOf('week').add(action, 'weeks');
                    case VIEW_MODE.DAY:
                        return dateM.startOf('day').add(action, 'days');
                }
                return dateM;
            })
    });

    currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());
    currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
    currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
    currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
    appointments$ = this.db.list('/appointments');
    filteredAppointments$ = Observable.combineLatest([this.viewMode$, this.currentDateM$, this.appointments$, this.searchTerm$],
        (viewMode: string, currentDateM: Moment, appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.WEEK:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.DAY:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));

            }
        });

    constructor(private db: AngularFireDatabase) {
    }

    private filterByTerm(appointment: Appointment, term: string): boolean {
        return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
    }

    onSetViewMode(viewMode: string): void {
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        this.navigation$.next(-1);
    }

    onNext(): void {
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        this.searchTerm$.next(e);
    }

    onRemoveAppointment(id: string): void {
        this.appointments$.remove(id);
    }

    onAddAppointment(date: Date): void {
        this.appointments$.push(new Appointment(date.toDateString(), ''));
    }

    onUpdateAppointment(appointment: Appointment): void {
        this.db.object('appointments/' + appointment.$key).set({
            description: appointment.description,
            date: appointment.date
        });
    }
}

</code></pre>

<p>There is only one problem. We use the same observables multiple times in our template. Since observables are cold by default, they will get executed every time there is a subscription. In Angular, this means a subscription for every async pipe. For performance reasons, we only want to recalculate these streams when something actually changes. For that purpose, we can try to use the <code>share()</code> operator from RxJS. The <code>share()</code> operator is an alias for <code>publish().refCount()</code> and will share the subscription.</p>

<p>However, that creates some problems with Angular and its async pipe.
The situation of the problem goes like this:</p>

<ul>
  <li>Since we are using BehaviorSubjects, the streams will get an initial value (which is what we want, of course).</li>
  <li>The share() operator will emit that value on the first subscription</li>
  <li>When the app is initialized, the async pipes will start subscribing to the stream.</li>
  <li>Because the first async pipe triggered the first emit the rest of the async pipes will miss that value.</li>
</ul>

<p><strong>Solution: shareReplay() will emit those values but keep track of them. That way, the async pipes will never miss a value.</strong></p>

<h2 id="conclusion">Conclusion</h2>

<p>We have created a completely reactive calendar that is performant and fixes a bunch of corner cases in only a few lines of code. Just by thinking about source streams and presentational streams, it wasn’t even that hard. I hope that I can encourage more people to take on this reactive approach and start writing kick-ass applications.</p>

<h2 id="special-thanks">Special Thanks</h2>

<p>I would like to give special thanks to the awesome people that reviewed this post and gave me pointers:</p>

<ul>
  <li>Dominic Elm (<a href="https://twitter.com/elmd_">@elmd_</a>)</li>
  <li>Manfred Steyer (<a href="https://twitter.com/manfredsteyer">@manfredsteyer</a>)</li>
  <li>David Müllerchen (<a href="https://twitter.com/webdave_de">@webdave_de</a>)</li>
  <li>Maxim Robert (<a href="https://twitter.com/sizerone">@sizerOne</a>)</li>
</ul>

<p>Thanks, guys! It means a lot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Infinite scroll in Angular an RxJS</title>
	  <link>//infinite-scroll-with-rxjs-and-angular2/</link>
	  <author></author>
	  <pubDate>2016-12-21T00:00:00+00:00</pubDate>
	  <guid>//infinite-scroll-with-rxjs-and-angular2/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>This article explains how the “reactive-programming” approach helps us to create an awesome <strong>infinite-scroll-list</strong> in only a few lines of code. For this article, we are going to use <a href="http://reactivex.io/rxjs/">RxJS</a> and <a href="http://angular.io">Angular</a>. If <a href="http://reactivex.io/rxjs/">RxJS</a> is completely new, it might be a good idea to read the documentation first. Whether we use <a href="http://angular.io">Angular</a> or something else like <a href="https://facebook.github.io/react/">React</a>, it shouldn’t really interfere with the clarity of this article.</p>

<h2 id="reactive-programming">Reactive programming</h2>

<p>Reactive programming is a rather old but very powerful approach of solving problems. However, we can run into problems when trying to think in a completely reactive manner. Thinking reactively is a huge mind switch that we must make to completely accept this “new” way of coding things. The whole “Our application reacts to a state-management-layer like <a href="http://redux.js.org/">redux</a>” principle is grasped quite quickly (it’s reactive programming too), but when it comes to <a href="http://freecontent.manning.com/reactive-fundamentals-thinking-in-streams/">thinking in streams</a> it can become quite difficult in the beginning.</p>

<h3 id="why-reactive-programming">Why reactive programming?</h3>

<p>Reactive programming has some advantages over imperative programming.</p>

<ul>
  <li>No more “if this, then that” scenario’s</li>
  <li>We can forget about a ton of edge-cases&lt;</li>
  <li>It’s easy to separate presentation logic from other logic (The presentation layer will just react to streams)</li>
  <li>It’s a standard: widely supported by tons of languages</li>
  <li>When we grasp the concepts, we write complex logic in a few lines of code in a very simple manner</li>
</ul>

<p>A few days back a colleague of mine came to me with this problem: He wanted to create an <strong>infinite-scroll in Angular</strong> but he had bumped into the  boundaries of imperative programming. It turned out that an infinite-scroll-solution was actually a great use-case to explain how reactive programming can help you write better code.</p>

<h2 id="the-infinite-scroll">The infinite scroll</h2>

<h3 id="what-should-it-do">What should it do?</h3>

<p>An infinite-scroll-list, is a list where the data is being loaded asynchronosly when the user scrolls further down the application. It’s a great way to avoid a pager (where the user had to click on every time) and it can really keep the application performant. It’s an efficient way to keep bandwidth low and increase the user-experience.</p>

<p>For this scenario, let’s say that every page contains 10 results and that all the pages with results are being shown as one long scrollable list =&gt; the infinite-scroll-list.</p>

<p>Let’s list the features of what our infinite-scroll-list must do:</p>

<ul>
  <li>It should load the first page by default</li>
  <li>When the results of the first page don’t fill the page completely, it should fill page 2, and so on, until the page is full</li>
  <li>When the user scrolls down, it should load page 3, and so on…</li>
  <li>When the user resizes it’s window, and more space is being freed for results, it should load the next page</li>
  <li>It should make sure that it doesn’t load the same pages more than once (caching)</li>
</ul>

<h2 id="lets-draw-it-first">Let’s draw it first</h2>

<p>Like most coding decisions, drawing them on a whiteboard first might be a good idea. That might be a personal approach, but it helps us not to write code that will be removed/refactored later.</p>

<p>Based on the feature-list, there are three actions that will trigger the application to load data: Scrolling, resizing, and a manual action that will be triggered to manually fetch pages. When thinking reactively we can see 3 sources of events happening, let’s call them streams:</p>

<ul>
  <li>A stream of scroll events: <strong>scroll$</strong></li>
  <li>A stream of resize events: <strong>resize$</strong></li>
  <li>A manual stream where we can manually decide what page to load: <strong>pageByManual$</strong></li>
</ul>

<p><strong>Note: We will suffix the streams with $ to indicate that they are streams, this is a convention (personal preference)</strong></p>

<p>Let’s draw these streams on a whiteboard:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard1.png" alt="Whiteboard 1" /></p>

<p>These streams would contain certain values over time:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard2.png" alt="Whiteboard 2" /></p>

<p>The scroll$ stream has Y values, which we can use to calculate the page number.</p>

<p>The resize$ stream has event values. We don’t need the values but we do need to know when the user resizes its window.</p>

<p>The pageByManual$ will contain page numbers, which we can set directly since this is a subject (more on that later).</p>

<p>What if we could map all these streams, to streams that would contain page numbers? That would be awesome, because based on the page number, we could load a specific page. How we map the current streams to page number-streams is not something that we need to think about right now (we are just drawing remember?).
The next drawing might look something like this:</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard3.png" alt="Whiteboard 3" /></p>

<p>We can see that we have created the following streams based on our initial streams:</p>

<ul>
  <li><strong>pageByScroll$</strong>: which contains page numbers based on the scroll-events</li>
  <li><strong>pageByResize$</strong>: which contains page numbers based on the resize-events</li>
  <li><strong>pageByManual$</strong>: which contains page numbers based on manual events (for instance, if there is still whitespace on the screen, we have to load the next page)</li>
</ul>

<p>What if we could merge these 3 page-number streams in an efficient manner, than we would get a new stream called <strong>pageToLoad$</strong>, that would contain page numbers created by scrolling-events, resize-events, and manual events.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard4.png" alt="Whiteboard 4" /></p>

<p>If we subscribe to the pageToLoad$ stream and than fetch data from the service, part of our infinite scroll would work. However, we were thinking reactively right? That also means, avoid subscriptions as much as possible… 
We actually need a new stream based on the pageToLoad$ stream that contains the results of our infinite scroll list…</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard5.png" alt="Whiteboard 5" /></p>

<p>Now let’s throw this in one big schema.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard6.png" alt="Whiteboard 6" /></p>

<p>As we can see above we have 3 input streams: one for scrolling, one for resizing and a manual one.
Afterwards we have 3 page streams that are based on the input streams. When merging these streams we can create a pageToLoad$ stream. Based on that pageToLoad$ stream, we will fetch the data.</p>

<h2 id="lets-code">Let’s code</h2>

<p>We have drawn more than enough, we have a clear vision of what our inifinte-scroll-list should do, so let’s start shall we?</p>

<p>To calculate which page needs to be loaded we need 2 properties:</p>

<pre><code class="language-typescript">private itemHeight = 40;
private numberOfItems = 10;// number of items in a page
</code></pre>

<h3 id="pagebyscroll">pageByScroll$</h3>

<p>The pageByScroll$ stream might look something like this:</p>

<pre><code class="language-typescript"> 
// first of all, we want to create a stream that contains 
// all the scroll events that are happening in the window object
private pageByScroll$ = fromEvent(window, "scroll")
  .pipe(
	// we are only interested in the scrollY value of these events
	// let's create a stream with only these values
	map(() =&gt; window.scrollY),
	// create a stream with the filtered values
	// we only need the values from when we are scrolling outside
	// our viewport
	filter(current =&gt; 
	  current &gt;=  document.body.clientHeight - window.innerHeight),
	// Only when the user stops scrolling for 200 ms, we can continue
	// so let's debounce this stream for 200 ms
	debounceTime(200),
	// filter out double values
	distinct(), 
	// calculate the page number
	map(y =&gt; Math.ceil(
		(y + window.innerHeight)/ (this.itemHeight * this.numberOfItems))
	)
  );
	
	// --------1---2----3------2...
</code></pre>

<p><strong>note: In real applications you might want to use injected services for window and document</strong></p>

<h3 id="pagebyresize">pageByResize$</h3>

<p>The pageByResize$ looks like this:</p>

<pre><code class="language-typescript">private pageByResize$ = 
  // Now, we want to create a new stream that contains 
  // all the resize events that are happening in the window object
  fromEvent(window, "resize")
	.pipe()
		// when the user stops resizing for 200 ms, then we can continue
		debounceTime(200),
		// calculate the page number based on the window
		map(_ =&gt; Math.ceil(
			(window.innerHeight + document.body.scrollTop) / 
			(this.itemHeight * this.numberOfItems)
		))
	);
	// --------1---2----3------2...
</code></pre>

<h3 id="pagebymanual">pageByManual$</h3>

<p>The pageByManual$ is the stream we use to have an initial value (initial page to load), but it’s also something that we need to control manually. A <a href="http://reactivex.io/documentation/subject.html">Behavior subject</a> looks perfect for the job, because we need a stream that has an initial value where we can also manually add values. A behavior subject is just a stream that has an initial value and can be manipulated over time.</p>

<pre><code class="language-typescript">private pageByManual$ = new BehaviorSubject(1);

// 1---2----3------...
</code></pre>

<h3 id="pagetoload">pageToLoad$</h3>

<p>Awesome, we have the 3 streams with page inputs, now let’s create a pageToLoad$ stream.</p>

<pre><code class="language-typescript">private pageToLoad$ = 
  // merge all the page streams and create a new stream of those
  merge(this.pageByManual$, this.pageByScroll$, this.pageByResize$)
	.pipe(
		// create a new stream where the double values are filtered out
		distinct(),
		// check if the page is already in the cache 
		// (just an array property in our component)
		filter(page =&gt; this.cache[page-1] === undefined)
	);
</code></pre>

<h3 id="itemresults">itemResults$</h3>

<p>The hard part is over. We now have a stream with the page we have to load in there, which is super useful. We don’t need to care anymore about corner cases or other complex logic. Every time a new value in that stream is added, we just need to load the data. <strong>That’s it!!</strong></p>

<p>We will use <a href="http://reactivex.io/documentation/operators/flatmap.html">flatmap</a> for this because the fetch-data-call will return a stream as well. FlatMap (or MergeMap) will merge these 2 streams as one.</p>

<pre><code class="language-typescript">itemResults$ = this.pageToLoad$
  .pipe(
    // based on that stream, load our asynchronosly data
    // flatmap is an alias for mergemap
    flatMap((page: number) =&gt; {
      // load me some starwars characters
      return this.httpClient.get(`https://swapi.co/api/people?page=${page}`)
        .pipe(
          // create a stream that contains the results
          map(resp =&gt; resp.results),
          tap(resp =&gt; {
            // add the page to the cache
            this.cache[page -1] = resp;
            // if the page contains enough white space
            // load some more data :)
            if((this.itemHeight * this.numberOfItems * page) 
			  &lt; window.innerHeight) {
              this.pageByManual$.next(page + 1);
            }
          })
        )
      }),
      // eventually, just return a stream that contains the cache
      map(_ =&gt; flatMap(this.cache))
  ); 
</code></pre>

<h3 id="the-result">The result</h3>

<p>the complete result might look like this:  <strong>Note the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#!#async-pipe">async pipe</a> that puts the whole subscription process into play</strong></p>

<pre><code class="language-typescript">import {Component} from '@angular/core';
import {Observable, BehaviorSubject} from 'rxjs';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import {distinct, filter, map, debounceTime, tap, flatMap} from 'rxjs/operators';
import {HttpClient} from '@angular/common/http';
import * as _ from 'lodash';
@Component({
  selector: 'infinite-scroll-list',
  template: `
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr *ngFor="let item of itemResults$|async" 
	  	[style.height]="itemHeight + 'px'"&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
   &lt;/table&gt;
  `
})
export class InfiniteScrollListComponent {
  private cache = []; 
  private pageByManual$ = new BehaviorSubject(1);
  private itemHeight = 40;
  private numberOfItems = 10; 
  private pageByScroll$ = fromEvent(window, "scroll")
    .pipe(
        map(() =&gt; window.scrollY),
        filter(current =&gt; 
			current &gt;=  document.body.clientHeight - window.innerHeight),
        debounceTime(200),
        distinct(),
        map(y =&gt; Math.ceil(
			(y + window.innerHeight)/ (this.itemHeight * this.numberOfItems)
			)
		)
    );
       
  private pageByResize$ = fromEvent(window, "resize")
    .pipe(
      debounceTime(200),
	    map(_ =&gt; Math.ceil(
        (window.innerHeight + document.body.scrollTop) / 
        (this.itemHeight * this.numberOfItems)
      ))
    )
    
  private pageToLoad$ = merge(
	  this.pageByManual$, 
	  this.pageByScroll$, 
	  this.pageByResize$)
    .pipe(
      distinct(),
      filter(page =&gt; this.cache[page-1] === undefined)
    );

  loading = false;
    
  itemResults$ = this.pageToLoad$
    .pipe(
      tap(_ =&gt; this.loading = true),
      flatMap((page: number) =&gt; {
        return this.httpClient.get(`https://swapi.co/api/people?page=${page}`)
          .pipe(
            map((resp: any) =&gt; resp.results),
            tap(resp =&gt; {
              this.cache[page -1] = resp;
              if((this.itemHeight * this.numberOfItems * page) 
			  	&lt; window.innerHeight) {
                this.pageByManual$.next(page + 1);
              }
            })
          )
      }),
      map(() =&gt; _.flatMap(this.cache))
    ); 
  
  constructor(private httpClient: HttpClient){ 
  } 
}
</code></pre>

<p>Here is a <a href="https://stackblitz.com/edit/angular-qszxoh?file=app%2Finfinite-scroll-list.component.ts">working stackblitz</a></p>

<iframe src="https://stackblitz.com/edit/angular-qszxoh?embed=1&amp;file=app/infinite-scroll-list.component.ts" frameborder="0" width="100%" height="480px">
</iframe>

<p>Again, (like I try to prove in previous articles) We don’t need to use third party solutions for everything. The infinite-scroll-list doesn’t contain that much code, and it’s very flexible.
Let’s say that we would like to free up DOM-elements and use only 100 items at a time, we could just create a new stream for that :)</p>

<p>Thanks for reading, I hope you enjoyed it.</p>

	  ]]></description>
	</item>


</channel>
</rss>
