<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link></link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>RxJS best practices in Angular</title>
	  <link>//rxjs-best-practices-in-angular/</link>
	  <author></author>
	  <pubDate>2018-01-04T00:00:00+00:00</pubDate>
	  <guid>//rxjs-best-practices-in-angular/</guid>
	  <description><![CDATA[
	     <p>This article is all about the do’s and don’ts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#lettable-operators">Lettable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don’t pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don’t pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code>$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code>$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="lettable-operators">Lettable operators</h2>

<p>The first best practice is the use of lettable operators. The operators being used in this article are lettable.
Since version 5.5 RxJS has introduced these so called lettable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about lettable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<pre><code class="language-typescript">// BAD: This is the old way and should be avoided (patch operators)
// as we can see the operators (filter, map) are part of the
// Observable prototype
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
const new$ = Observable.interval$
    .filter(v =&gt; v % 2 === 0)
    .map(v =&gt; v * 2);

// GOOD: This is the new and improved way (lettable operators)
// we just use the pipe operator where we pass operators that
// we can import from 'rxjs/operators'
import {filter, map} from 'rxjs/operators';
const new$ = interval$
    .pipe(
        filter(v =&gt; v % 2 === 0),
        map(v =&gt; v *2)
    )
</code></pre>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: “Great code should be self-explanatory, writing documentation is something that we might want to avoid.”
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it’s hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it’s supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<pre><code class="language-typescript">// ---a--b--c--d---e---...
// ---a--b--c--d---e|
// ---a--b--c--d---e#
// ---a--b-^-c--d---e
</code></pre>
<ul>
  <li><code>-</code> (stands for a time frame)</li>
  <li><code>a-z</code> (are the values that are next’ed in the stream)</li>
  <li><code>|</code> (indicates that the stream has completed)</li>
  <li><code>...</code> (indicates that the stream will keep on living)</li>
  <li><code>#</code> (indicates that an error occurred)</li>
  <li><code>^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it’s time to check a real example and how we might document it:</p>

<pre><code class="language-typescript">const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
const new$ = interval$
    .pipe(
        skip(1),                            // ---1--2--3--4--5--6...
        take(5),                            // ---1--2--3--4--5|
        filter(v =&gt; v % 2 === 0),           // ------2-----4-----6
        map(v =&gt; v + 1)                     // ------3-----5-----7
    )
</code></pre>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it’s fairly easy to comprehend what happens, and how every operator affects the <code>new$</code> stream we can see above. There is no “one way of doing things” when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn’t mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn’t have any side effects. It can’t mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren’t fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit {
   ngOnInit() {
        // The following stream will produce values every second
        // 0--1--2--3--4--5--6--...
        const interval$ = interval(1000);
        // Even when this component gets destroyed,
        // the stream will keep producing values...
        // This means the console will keep on logging
        // This is a classic example of a memory-leak
        const subscription = interval$.subscribe(r =&gt; console.log(r));
    }
}
</code></pre>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    subscriptions = [];
    ngOnInit() {
        const interval$ = interval(1000);
        const subscription = interval$.subscribe(r =&gt; console.log(r));
        // manually keep track of the subscriptions in a subscription array
        this.subscriptions.push(subscription);
    }

    ngOnDestroy() {
        // when the component get's destroyed, unsubscribe all the subscriptions
        this.subscriptions.forEach(sub =&gt; sub.unsubscribe());
    }
}
</code></pre>
<p>// TODO: is niet helemaal duidelijk dat als je next op je subject dat die takeUntil een complete zal sturen naar je originele stream
However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    destroy$ = new Subject();
    ngOnInit() {
        // interval$: 0--1--2--3--4--5--6--...
        // destroy$:  -------------true|
        // result:    0--1--2--3--4|
        const interval$ = interval(1000);
        interval$
            // let the interval$ stream live 
            // until the destroy$ Subject gets a value
            .pipe(takeUntil(this.destroy$))
            .subscribe(r =&gt; console.log(r));
    }

    ngOnDestroy() {
        // when the component get's destroyed, pass something to the
        // destroy$ Subject
        this.destroy$.next(true);
    }
}
</code></pre>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService)
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // VERY BAD: nesting subscribes is ugly and takes away
        // the control over a stream
        this.route.params
            .pipe(map(v =&gt; v.id))
            .subscribe(id =&gt; 
                this.userService.fetchById(id)
                    .subscribe(user =&gt; this.user = user))
    }
}
</code></pre>

<p>The previous implementation is considered a bad-practice. It’s recommended to use <strong>higher-order streams</strong> like <code>mergeMap</code> or <code>switchMap</code>. Let’s have a look at this example:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) 
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // GOOD: we have created a single subscribe which makes
        // the flow way easier and gives us the control we need
        this.route.params
            .pipe(
                map(v =&gt; v.id),
                switchMap(id =&gt; this.userService.fetchById(id))
            )
            .subscribe(user =&gt; this.user = user)
    }
}
</code></pre>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that’s simply how observables work. But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code>async pipe</code>. It’s used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don’t have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let’s have a look at the cleaned up previous example:</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // expose a user$ stream that will be 
    // subscribed in the template with the async pipe
    user$ = this.route.params.pipe(
        map(v =&gt; v.id),
        switchMap(id =&gt; this.userService.fetchById(id))
    );

    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) {
    }
}
</code></pre>

<p>If you are into <a href="https://reactjs.org/">React</a>, I’ve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don’t pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That’s the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // this http call will get called when the 
    // user-detail component subscribes to users$
    // We don't want that
    users$ = this.http.get(...);
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent implements OnInit {
    @Input() user$: Observable&lt;User&gt;;
    user: User;
    ngOnInit(){
        // WHOOPS! This child component subscribes to the stream
        // of the parent component which will do an automatic XHR call
        // because Angular HTTP returns a cold stream
        this.user$.subscribe(u =&gt; this.user = u);
    }
}
</code></pre>

<p>It would be better to handle the subscription in the parent component itself:</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent implements OnInit {
    users$: Observable&lt;User[]&gt; = this.http.get(...);
    user: User;
    ngOnInit(){
        // the app component (smart) subscribes to the user$ which will
        // do an XHR call here
        this.users$ = this.http.get(...);
    }
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent {
    // This component doesn't even know that we are using RxJS which
    // results in better decoupling
    @Input() user: User;
}
</code></pre>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don’t pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don’t know what’s going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don’t care that your components are using streams. Take this example for instance:</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
class AppComponent {
     users$ = this.http.get(...)
     filteredusers$ = this.fooService
        .filterUsers(this.users$); // Passing stream directly: BAD
    ...
}

// foo.service.ts
class FooService {
    // return a stream based on a stream
    // BAD! because we don't know what will happen here
    filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; {
        return users$.pipe(
            map(users =&gt; users.filter(user =&gt; user.age &gt;= 18))
    }
}
</code></pre>

<p>It would be better to use higher order streams for these situations.
Use <code>switchMap</code> over <code>mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
class AppComponent {
    users$ = this.http.get(...)
    filteredusers$ = this.users$
        .pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));
    ...
}

// foo.service.ts
class FooService {
    // this is way cleaner: this service doesn't even know
    // about streams now
    filterUsers(users: User): User[] {
        return users.pipe(filter(user =&gt; user.age &gt;= 18);
    }
}
</code></pre>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code>http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code>numberOfUsers$</code> depends on <code>users$</code>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// BAD
class AppComponent {
    users$ = this.http.get(...)
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>In those cases we might want to share the subscriptions. The following example uses the <code>share()</code> operator:</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// GOOD
class AppComponent {
    users$ = this.http.get(...).pipe(share());
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code>shareReplay(1)</code> instead of <code>share()</code>. This will keep the last value in memory for us.</p>

<p>It’s a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code>async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `
})
class AppComponent {
    // This stream will only subscribed to once
    users$ = this.http.get(...);
}
</code></pre>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn’t make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it’s ok to use Subjects in the following scenarios:</p>
<h3 id="when-mocking-streams-in-tests">When mocking streams in tests</h3>

<pre><code class="language-typescript">const fetchAll$ = new Subject(); // use a Subject as a mock
usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
fetchAll$.next(fakeUser);
</code></pre>

<h3 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h3>

<pre><code class="language-typescript">@Component({
    ...
    template: `
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `
})
class AppComponent {
search$ = new Subject(); // ----t-----te-----ter----term...
}
</code></pre>

<h3 id="when-handling-circular-references">When handling circular references</h3>

<p>I’m not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code>getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<pre><code class="language-typescript">    foo$.pipe(
        map(...)
        filter(...)
        tap(...)
    )
</code></pre>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that’s personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it’s recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code>ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code>Form</code> and <code>FormControl</code> both have a <code>valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code>ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the “Advanced RxJS in Angular workshop” from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Code formatting and RxJS</title>
	  <link>//code-formatting-with-rxjs/</link>
	  <author></author>
	  <pubDate>2017-09-08T00:00:00+00:00</pubDate>
	  <guid>//code-formatting-with-rxjs/</guid>
	  <description><![CDATA[
	     <p>One of the main benefits of RxJS to me is that it provides code that is ‘readable’. It provides us with a declarative programming approach where implementation details are hidden away. We are just describing what needs to be done, not how it should be done. This makes code you look at easy to understand.</p>

<p>One problem that I face regularly when looking at other peoples code is that the code formatting or the way the (RxJS) code is written, takes away part of the benefit of writing your code this way. This post is a small summary on how I like to format my code to keep the readability benefits to a maximum.</p>

<h3 id="one-operator-per-line">One operator per line</h3>

<p>One thing I see all the time is something like this:</p>

<pre><code class="language-typescript">Rx.Observable.interval(1000).map(x =&gt; x*2).filter(x =&gt; x%2 === 0)
	.mergeMap(x =&gt; someBackendCall(x)).map(res =&gt; res.json()).subscribe();
</code></pre>

<p>Here we can see a simple stream. Looking at what is does is a little more difficult however because of the outlining of the operators. If you format the code like this, it makes it so much easier:</p>

<pre><code class="language-typescript">Rx.Observable.interval(1000)
	.map(x =&gt; x*2)
	.filter(x =&gt; x%2 === 0)
	.mergeMap(x =&gt; someBackendCall(x))
	.map(res =&gt; res.json())
	.subscribe();
</code></pre>

<p>By putting every operator on a new line, it is so much easier to see what’s happening.</p>

<h3 id="using-nested-functions-for-functions-longer-than-one-line">Using nested functions for functions longer than one line</h3>

<p>A lot of the RxJS operators will accept functions as parameters. These functions can influence the code formatting and impair the readability. Let’s take a look at an example:</p>

<pre><code class="language-typescript">// A data$ stream
private data$: Observable&lt;Array&lt;Data&gt;&gt;;

// A function that uses this data$ 
doSomething() {
    this.data$
    	.take(1)
        .map((data) =&gt; {
            if (data &amp;&amp; data.length &gt; 0) {
                	return data.forEach(datum =&gt; {
                    datum.active = false;
                	});
            } else {
            		return [];
            }
        })
        .mergeMap((data) =&gt; {
            data.forEach(datum =&gt; {
                this.whateverService.update(data);
            });
        })
        .subscribe();
}
</code></pre>

<p>We have a function <code>doSomething()</code> that, when called, will use the <code>data$</code> stream as a source and will perform a mapping of the data array events inside of this stream and then will perform a backend call for every element inside this array. 
If you were able to detect this immediately, my hat off to you. To me however, this looks pretty bad. Let’s take a look at how we could make this better:</p>

<pre><code class="language-typescript">// A data$ stream
private data$: Observable&lt;Array&lt;Data&gt;&gt;;

// A function that uses this data$ 
doSomething() {
    const mapAllTheElementsActiveFlagToFalse = (data) =&gt; {
        if (data &amp;&amp; data.length &gt; 0) {
            return data.forEach(datum =&gt; {
                datum.active = false;
            });
        } else {
            return [];
        }
    };

    const callTheWhateverServiceForEveryElement = (data) =&gt; {
        data.forEach(datum =&gt; {
            this.whateverService.update(data);
        });
    }; 

    this.data$
    	.take(1)
        .map(mapAllTheElementsActiveFlagToFalse)
        .mergeMap(callTheWhateverServiceForEveryElement)
        .subscribe();
}
</code></pre>

<p>I updated the code so that all the functions passed to the operators are first created as nested functions. This might feel a little weird at first, creating nested functions, but if we look at the last few lines of code, these have become so much cleaner. If you know what the operators of RxJS do, you can actually read what is happening (I must admit, naming these functions might not be my strongest feat :)). You only have to look at the last lines of this function. The implementation details of the nested functions is irrelevant (remember, declarative is easier to read).
I find this approach really helpful and tend to use it a lot, especially for functions that are longer than a single line.</p>

<h3 id="avoid-using-nested-observables">Avoid using nested observables</h3>

<p>RxJS provides us with a lot of operators which you can do a whole range of stuff with. One of them is combining different streams. One thing I sometimes see is this:</p>

<pre><code class="language-typescript">private data$: Observable&lt;Array&lt;Data&gt;&gt;;
private data2$: Observable&lt;Data2&gt;;

result$: Observable&lt;any&gt;;

doSomething() {
	 // we combine the data$ and data2$ with combineLatest
    this.result$ = Observable.combineLatest(
        this.data$
            .map(data =&gt; data.length),
        this.data2$
            .mergeMap(val =&gt; this.whateverService.call(val)),
        (val1, val2) =&gt; {
            // handle the values here   
        }
    );
}
</code></pre>

<p>We create an observable by using the <code>combineLatest</code> operator. But before we do so, the <code>data$</code> and <code>data2$</code> streams are transformed. You could say we are working with nested streams. And even though, the operators are aligned perfectly and there are no functions that are longer than one line, it still feels weird. Let’s see how we might be able to make it better:</p>

<pre><code class="language-typescript">private data$: Observable&lt;Array&lt;Data&gt;&gt;;
private data2$: Observable&lt;Data2&gt;;

result$: Observable&lt;any&gt;;

doSomething() {
    const dataLength$ = this.data$
        .map(data =&gt; data.length); 
    const whateverData$ = this.data2$
        .mergeMap(val =&gt; this.whateverService.call(val));

	 // we combine the data$ and data2$ with combineLatest
    this.result$ = Observable.combineLatest(
        dataLength$,
        whateverData$,
        (val1, val2) =&gt; {
            // handle the values here   
        }
    );
}
</code></pre>

<p>This time, I extracted the nested observables and matched them to local variables first. I then use these newly created local variables to create a new stream using the <code>combineLatest</code> operator. 
By extracting nested observables to a separate variable and naming this new observable properly, the code is easier to understand.</p>

<p><strong>Conclusion</strong></p>

<p>Try to keep the following in mind when writing RxJS code:</p>

<ol>
  <li>Put every operator on a new line.</li>
  <li>Extract functions longer than a line to a nested function.</li>
  <li>Try to avoid working with nested observables.</li>
</ol>


	  ]]></description>
	</item>

	<item>
	  <title>Multicasting operators in RxJS</title>
	  <link>//multicasting-operators-in-rxjs/</link>
	  <author></author>
	  <pubDate>2017-08-20T00:00:00+00:00</pubDate>
	  <guid>//multicasting-operators-in-rxjs/</guid>
	  <description><![CDATA[
	     <p>With the arrival of RxJS 5.4 a while back, the RxJS team has given us yet another way to support multicasting in our applications. They introduced the <code>shareReplay</code> operator. With this new one around the corner, you might start wondering when to use which multicasting operator. Well, it’s your lucky day cause that’s what this post is all about.</p>

<p><strong>TL:DR;</strong> You can find an overview of all the multicasting operators and their properties <a href="#operator-overview">here</a>.</p>

<h2 id="what-is-multicasting">What is multicasting</h2>

<p>First of all, I would like to go a little deeper into the subject of multicasting. What does this really mean? As you hopefully know, observables can be divided into two categories, hot and cold.
If you subscribe to an observable, you are going to start executing that observable. What this means is the observable will start producing values. When you are working with a cold observable, every new subscription will ‘restart’ the observables producer.</p>

<p><strong>Note</strong>: If you do not know what hot and cold observables mean, you can read this excellent article on the Thoughtram blog <a href="https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html" target="_blank">here</a>.</p>

<p><strong>Note2:</strong> The fact that an observable is either cold or hot is somewhat debatable as we’ll see later on. An observable can also hold properties from both of these states. In the Thoughtram article described above, they point to these observables as being ‘warm’.</p>

<p>Let’s take a look at an example:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/jefupu/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>Here we can see an interval observable that will emit 5 values with half a second between them. We subscribe to this observable immediately and again after 1,5 seconds. As you can see, when the second subscription happens, it doesn’t get the same values as the first subscription. Instead, it starts with the value ‘0’. 
We can conclude from this that for every subscription, the observable is ‘restarted’ and the observable will restart the production of values.</p>

<p>If we try to put this into a visual representation, it might look a little like this:</p>

<p><img src="https://www.dropbox.com/s/y9bh74hsiqwy205/Screenshot%202017-09-03%2014.55.00.png?raw=1" width="400" /></p>

<p>We can see that the interval observable is ‘recreated’ when the second subscription occurs.</p>

<p>This might feel a little weird in the beginning, but it gives us the benefit to re-use observables, which is a quite powerful concept once you get the hang of it. It however also introduces some weird side effects. Let’s take a look at an example:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/terapof/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>We create an observable, <code>getLuke$</code>, which will perform a call to fetch the character of Luke Skywalker from the swapi.co API. We use this as a source to create two new observables. One holds the name of the character, the other one holds the gender of the character. We immediately subscribe to both of the observables. If you open your devtools onto the network tab, you will see that there are actually two network request being performed.</p>

<p>This might seem weird at first, but in fact, it’s quite logical. The <code>getLuke$</code> observable we created is a cold one. The two new observables we create both use this one as a source. So in fact, subscribing to our <code>gender$</code> and <code>name$</code> observable, is the equivalent of subscribing to the <code>getLuke$</code> observable twice. And, as we have seen above, every subscription to a cold observable, will trigger two executions of the observable, two times the production of values, thus in this case two network requests.</p>

<p>While this behaviour can be useful, sometimes you might want two backend calls, it can also be quite annoying. The problem that we are facing here is that the execution of the observable is restarted on every subscription. While sometimes, we want to share the underlying subscription. Sharing the underlying subscription is what multicasting is all about.</p>

<p><strong>Note:</strong> If you are multicasting an observable, you have transformed it from a cold to a hot observable.</p>

<h3 id="multicasting-example">Multicasting example</h3>

<p>Let’s change our example to share the underlying subscription. For this we will use the <code>share</code> operator for now. We will investigate all the other ones and their properties later on.</p>

<p><a class="jsbin-embed" href="http://jsbin.com/higujow/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>If you run this example while opening your devtool’s network tab, you can see that there is only one request. That’s because the underlying subscription is shared. 
Let’s again try to visualize this in a diagram.</p>

<p><img src="https://www.dropbox.com/s/kcohbr9wa5ax631/Screenshot%202017-09-06%2021.08.08.png?raw=1" width="400" /></p>

<p>Here, we can see that the share operator will only subscribe once to the source observable, being the observable that does a backend call, and will multicast the data to all the subscriptions. It acts as a proxy.</p>

<h2 id="the-properties-of-multicasting">The properties of multicasting</h2>

<p>A multicasting operator shares the underlying subscription towards its subscribers. The way they do it can vary quite a lot. Next we are going to go over all of the properties a multicasting operator can have.</p>

<h3 id="connectable">Connectable</h3>

<p>One of the ways to share the underlying subscription to multiple subscribers, is by using the <code>publish</code> operator. When you call <code>publish()</code> on an observable, you get back a <code>ConnectableObservable</code>. This is an observable that will subscribe to the source observable once you have called it’s <code>connect()</code> method. Let’s try and put this in a ASCII marble diagram to visualise it better.</p>

<pre><code class="language-typescript">source observable:         ---a----b----c|
                             -publish()-
connect point:             C
subscriber 1:          ^------a----b-!     
subscriber 2:                   ^--b----c|
</code></pre>

<p><strong>Note:</strong> If you don’t know the ASCII marble syntax, take a look at the <a href="https://github.com/ReactiveX/rxjs/blob/5.4.2/doc/writing-marble-tests.md#marble-syntax" target="_blank">official documentation</a></p>

<p>We have a source observable which will emit 3 values, a, b and c. We use the <code>publish</code> operator on this cold observable. This will return a <code>ConnectableObservable</code>. We have a subscriber that subscribes immediately to this stream, and a subscriber that subscribes after some time.</p>

<p>We can see that the first subscription point of subscriber 1, doesn’t trigger the source observable to be started. It’s only at the time the <code>ConnectableObservables</code>’s <code>connect</code> method gets called (indicated by the ‘C’), that the source observable is started.
When the second subscription happens, the ‘a’ value has already been passed by the <code>ConnectableObservable</code> to all available subscribers at that time, which was only the first subscriber. The second subscriber missed this value. 
When the ‘b’ value is produced by the source observable, it is passed to both the first and second subscriber. 
Next the second subscriber unsubscribes (denoted by the ‘!’). So when the source observable emits the last value, c, and completes, only the second subscriber gets these values.</p>

<p>Let’s take a look at coding example:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/wicarev/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>Here we can see an interval observable that will emit 4 values. We use the <code>publish</code> operator to create a <code>publishedInterval</code> observable. We subscribe to it immediately and we subscribe to it after 2500ms. As you can see, the first subscription will not trigger the interval to be started. It’s only when we call it’s <code>connect</code> method after 600ms that it will start emitting values.</p>

<p><strong>Conclusion:</strong> A multicasting operator is connectable when you have to call the <code>connect</code> method before it subscribes to the source observable and starts proxying.</p>

<h3 id="reference-counting">Reference counting</h3>

<p>The next property we are going to discuss is reference counting. As we’ve seen above, when we get a <code>ConnectableObservable</code> we need to call <code>connect()</code> on it before the source observable is subscribed to. Sometimes, you might want the source observable to be subscribed to as soon as there is at least one subscriber. And that’s exactly what you can achieve with reference counting through the <code>refCount</code> operator. Let’s see what this looks like in a marble diagram.</p>

<pre><code class="language-typescript">source observable:     --0--1--2--!    --0--1!
                             -publish().refCount()-
subscriber 1:          ^-0--1!
subscriber 2:             ^-1--2--!
subscriber 3:                          ^-0--1!
</code></pre>

<p>We have a source observable that will emit values with some time in between. As soon as the first subscription happens, the source observable is started. When the second subscription happens, the source observable is still emitting values and it will get the same values as the first subscription. When the first subscription stops, the source observable is not unsubscribed to, but when the second one stops, it is. 
The <code>refCount</code> operator will count the number of subscriptions. As soon as this number is 1, it will subscribe to the source observable and as long as this number stays 1 or higher, the source observable is subscribed to. If this number drops to 0, it unsubscribes from the source observable. 
When the number rises back from 0 to 1, as it is with our third subscriber, the source observable is resubscribed to.</p>

<p>Let’s take a look at some code:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/vujozac/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>We have an interval observable that <code>publish().refCount()</code> is applied to. This newly created observable is subscribed to. When this happens, the source observable, our interval observable, is immediately subscribed to. 
After 700ms, we subscribe a second time. At this moment, both subscriptions get the same values.
When the first subscriber unsubscribes, after 1100ms. It doesn’t influence the source observable. This is because the reference counting is still on 1. When the second subscriber stops listening, after 1700ms, the source observable is unsubscribed to because the reference counting dropped to 0. 
When we resubscribe a third time, the source is subscribed to again.</p>

<p><strong>Note:</strong> Using <code>publish().refCount()</code> is a quite common operation. For that reason, the <code>share()</code> alias was introduced which is the exact same thing.</p>

<p><strong>Conclusion:</strong> An observable is reference counting when it subscribes as soon as there is a single subscriber and stops when there are no more subscribers.</p>

<h3 id="replayable">Replayable</h3>

<p>If you subscribe to a hot observable, you might have missed some values. In some cases, this might not be what you want. You might want to get at least the latest emitted value before you subscribed or the latest x values that were emitted before you subscribed. Luckily, there is a way to do that.</p>

<p>Let’s first create an ASCII marble diagram to visualise what we want:</p>

<pre><code class="language-typescript">source observable:     ---a----b-------c----d----e|
                             -shareReplay(2)-
subscriber 1:          ^--a----b!     
subscriber 2:                    ^(ab)-c----d----e|
</code></pre>

<p>In this scenario, we are using the <code>shareReplay</code> operator. We are subscribing to the created observable twice. When the second subscription happens, the source stream has already emitted two values. When the second subscription happens, it normally would have missed these two values. But because we use the <code>shareReplay</code> operator we get these two values. We passed ‘2’ to the operator which means that it will replay the last two values before the subscription.</p>

<p>Let’s take a look at an example:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/qumego/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>We have an interval observable, to which the <code>shareReplay</code> operator is applied with parameter ‘2’. We subscribe to it immediately and once after some values have already been passed. We can see that, as soon as the second subscription happens, it also receives the last two values that were emitted before the subscription.</p>

<p><strong>Conclusion:</strong> A multicasting operator is replayable when it emits the ‘x’ latest values to a new subscriber.</p>

<h3 id="repeatable">Repeatable</h3>

<p>In the previous examples, we were dealing with a source observable that completed. This could mean that if we subscribe to an observable that is multicasted or hot, for which the source has completed it will never get any values. For this reason, there are also hot observables that are repeatable. Let’s look at a ASCII marble diagram that represents this:</p>

<pre><code class="language-typescript">source observable:     ---a----b|    ---a----b|    
                             -share()-
subscriber 1:          ^--a----b|     
subscriber 2:                   	   ^---a----b|
</code></pre>

<p>We have a source observable that we are applying the <code>share</code> operator to. When we have a first subscriber, the source observable is started and the first subscriber get’s all the values. But by the time the second one subscribes, the source observable has already completed. In that case, at least for the <code>share</code>, the source observable is resubscribed to and the second observable will get the same values (remember the source observable in this case is a cold one so for every new subscription, the observable is restarted).</p>

<p>Let’s take a look at an example:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/doyojenatu/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>Here we have an interval observable where we apply the <code>share</code> operator to. It will emit 3 values in 1.5 seconds and then complete. We subscribe to it once immediately and again after 3 seconds. If we look at the output, we can see that both the subscriptions get the same values. From this we can conclude that the source observable was repeated.</p>

<p><strong>Conclusion:</strong> A multicasting operator is repeatable when it resubscribes to the source observable when there is a new subscription and the source observable had already completed. It re-executes the source observable.</p>

<h3 id="retryable">Retryable</h3>

<p>As stated before, a multicasting operator will share the underlying subscription towards it’s subscribers and acts as a proxy. But what happens when this source observable throws an error? There are multicasting operators that will retry subscribing to the source observable when it threw an error. Let’s put this into a marble diagram:</p>

<pre><code class="language-typescript">source observable:     ---#            ---#
                             -shareReplay()-
subscriber 1:          ^--#
subscriber 2:                   	   ^--#
</code></pre>

<p>Here we have a source observable onto which the <code>shareReplay</code> operator is applied. When the first subscriber starts listening to it, the source observable will be subscribed to. Here, it will throw an error after some time which is send to the first subscriber.
A little while later the observable is resubscribed to by a second subscriber. This will start a new invocation of the source observable. This one will have the same effect as the first subscription. In a real life scenario, the first invocation might fail, but this doesn’t necessarily mean that the second will. In those scenario’s, retrying can be very useful.</p>

<p>Let’s look at an example:</p>

<p><a class="jsbin-embed" href="http://jsbin.com/diroqe/embed?js,console">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?4.0.4"></script></p>

<p>We have an observable <code>throw$</code> that will, once subscribed to, will throw an error. We use the <code>do</code> operator to see if it was invoked. We apply the <code>shareReplay</code> operator to this <code>throw$</code> observable. 
We subscribe immediately and after three seconds. We can see that, even though the first subscriber gets an error, as soon as the second one subscribes, the source observable is resubscribed to by the <code>shareReplay</code> operator. This makes it retryable.</p>

<p><strong>Conclusion:</strong> A multicasting operator is retryable when it resubscribes to the source observable when there is a new subscription and the source observable has errored before.</p>

<h2 id="operator-overview">Operator overview</h2>

<p>Time to give an overview of all the multicasting operators and their respective properties:
<!-- 
|                     | Multicasting 	                | Connectable                     | Reference counting*             | Replayable                      | Repeatable                      | Retryable                       |
| ------------------- | :-----------------------------: | :------------------------------:| :-----------------------------: | :-----------------------------: |:------------------------------: |:------------------------------: |
| share()             | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox" checked> | <input type="checkbox" checked> |
| shareReplay()       | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox" checked> | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox" checked> |
| publish()           | <input type="checkbox" checked> | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox">         | <input type="checkbox">         | <input type="checkbox">         |
| publishReplay()     | <input type="checkbox" checked> | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox">         |
| publishBehaviour()  | <input type="checkbox" checked> | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox">         | <input type="checkbox">         | <input type="checkbox">         |
| publishLast()       | <input type="checkbox" checked> | <input type="checkbox" checked> | <input type="checkbox">         | <input type="checkbox">         | <input type="checkbox">         | <input type="checkbox">         |
 -->
<img src="https://www.dropbox.com/s/6kufxt28eca9e94/Screenshot%202018-01-08%2019.26.33.png?raw=1" alt="tableOverview" /></p>

<nowiki>*Every multicasting operator which is connectable can also have the `refCount` operator applied to. In this table however, every operator that has 'Reference counting' checked, has reference counting implicitgit ly applied in the implementation of the operator.</nowiki>


	  ]]></description>
	</item>

	<item>
	  <title>Introducing Rx devtools</title>
	  <link>//introducing-rx-devtools/</link>
	  <author></author>
	  <pubDate>2017-08-04T00:00:00+00:00</pubDate>
	  <guid>//introducing-rx-devtools/</guid>
	  <description><![CDATA[
	     <p>Ever since I first started using RxJS up until this very day, it has become my absolute favorite way of coding. I cannot believe to work in a world without observables anymore nor can I understand on how I was able to write code before. I have started sharing the knowlegde I had through blogposts, workshops and coaching.</p>

<p>One thing that always comes up while working with observables is the very high learning curve. It’s really hard to grasp the concept when you’re just starting. One of the reasons for this is that it’s really hard to visualize and debug the observables in your application. 
With this in the back of my mind, I started wondering how that could be fixed. If there only was a way to clearly see the data flowing in the streams of your application in realtime. That’s how the idea for Rx Devtools was born.</p>

<h2 id="introducing-rx-devtools">Introducing Rx Devtools</h2>

<p>After first playing with the idea, I decided to create a small POC. This POC has grown into a chrome extension that, as of today, can be used to visualise streams realtime! Take a look at the demo below (it’s a youtube video, pls click :)):</p>

<p><a href="https://youtu.be/stWGClDE_Gk"><img src="https://img.youtube.com/vi/stWGClDE_Gk/0.jpg" alt="Rx devtools teaser" /></a></p>

<p>On the left you can see the code we are debugging at the moment. Notice the <code>debug</code> operators on every observable. Here you can pass a name to track the streams. 
On the right side you can see the plugin in action. Left, we have a list with one entry per observable we are debugging. When clicked on one of them, you can see the actual marble diagrams with all of the operators. You can click on a marble to inspect the value it had at that moment in time. This way, you can not only see the value of every event being passed to the observable chain, but also see the moment in time they were produced and push down this chain.</p>

<p>If you for example have a combineLatest which doesn’t seem to fire, there will probably be one source observable that is not producing a value. With the plugin, this is visualised in seconds!</p>

<p>For more information on the plugin, how to install, how it works and how to use it, I would like to point you to the <a href="https://github.com/kwintenp/rx-devtools" target="_blank">Github</a> page.</p>

<h3 id="whats-next">What’s next</h3>
<p>The plugin as it exists today can definitely be used. It is however far from finished and still in an alpha phase. Over the next few weeks, I’ll try to add as many features asap. If you have any ideas for features you want to see added, feel free to create feature requests through Github issues. 
If you find any bugs, which I’m certain you will, please report them in the form of Github issues. I will try to tackle them asap.</p>

<p>Happy debugging!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Thinking reactively in Angular and RXJS</title>
	  <link>//thinking-reactively-in-angular-and-rxjs/</link>
	  <author></author>
	  <pubDate>2017-07-25T00:00:00+00:00</pubDate>
	  <guid>//thinking-reactively-in-angular-and-rxjs/</guid>
	  <description><![CDATA[
	     <h2 id="foreword">Foreword</h2>

<p>RxJS is an awesome library that can help us with creating <strong>reactive web applications</strong>. Reactive web applications can be overwhelming in the beginning, but eventually, they can be really rewarding.</p>

<p>This article is all about making the paradigm switch from thinking imperatively towards <strong>thinking reactively</strong>.
In this article, we will explain how to write a reactive calendar application in only a few lines of code (<strong>spoiler: It’s gonna be real time too</strong>).</p>

<p>We will use Angular, Angular Material, TypeScript, RxJS, Firebase, and AngularFire as our main technology stack. Keep in mind that this article really focusses on reactive programming. Don’t expect a deep dive into all RxJS operators, but rather expect an explanation of how to draw, think, and reason about reactive web applications. We will learn <strong>how to think in streams</strong>. If you haven’t heard of streams yet, please read <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this awesome article</a> first.</p>

<p><strong>Note:</strong> This article contains personal terminology.</p>

<h2 id="the-reactive-calendar">The Reactive Calendar</h2>
<p>This is the application we are going to write. It’s a small but complete calendar application that allows us to:</p>

<ul>
  <li>Switch between different view modes: day, week, month.</li>
  <li>Navigate to previous and next days, weeks, and months.</li>
  <li>Add, update, and remove appointments.</li>
  <li>Search for specific appointments.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar1.png" alt="Reactive calendar" /></p>

<p>The user can interact with the following UI elements:</p>

<ul>
  <li><strong>Next button:</strong> Allows the user to go to the next day in day mode, week in week mode, etc.</li>
  <li><strong>Previous button:</strong> Allows the user to go to the previous day in day mode, week in week mode, etc.</li>
  <li><strong>Day, week, month buttons:</strong> Allows the user to switch between the different view modes</li>
  <li><strong>Search term input:</strong> Allows the user to filter the appointments on the fly</li>
  <li><strong>Plus-buttons in the grid:</strong> Allows the user to create new appointments</li>
  <li><strong>Trashcan buttons in the grid:</strong> Allows the user to remove appointments</li>
  <li><strong>Description inputs:</strong> Allows the user to update the description of an appointment</li>
</ul>

<p>I decided to use Firebase as a backend and because of that, our application will be realtime and offline first by default!</p>

<p><strong>Note:</strong> One small issue, I’ve been a bit lazy so we can only create lunch appointments. =) But hey! Consider it some homework.</p>

<h2 id="setting-up-the-project">Setting Up the Project</h2>

<p>I’ve created the git branch <strong>initial</strong> to get us started. It contains the default logic/components, setup, and styles. There is no reactive code written yet, just plain Angular code. The goal is to write the reactive part ourselves.</p>

<h3 id="the-component-tree">The Component Tree</h3>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar3.png" alt="The component tree" />
The dumb components (blue) are already implemented. The <code>app-root</code> (orange) is the one and only smart component in the application and the only place where we will write code.</p>

<p>If you don’t know the difference between smart and dumb components, <a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">read this first</a>.</p>

<h3 id="installing-the-project-locally">Installing the Project Locally</h3>
<p>First of all, we have to clone the project locally and check out the <strong>initial</strong> branch. This branch already contains all the uninteresting parts that don’t have anything to do with this article.</p>

<p>In the terminal, we have to go to the folder where we want to install the project and run the following commands:</p>

<pre><code>$ git clone git@github.com:brechtbilliet/reactive-calendar.git
$ cd reactive-calendar/reactive-calendar
$ git checkout initial
$ npm install
</code></pre>

<h3 id="setting-up-firebase">Setting Up Firebase</h3>

<p>We are using <a href="https://firebase.google.com/">Firebase</a> as our backend because it requires minimal setup, it’s realtime by default, and <a href="https://github.com/angular/angularfire2">AngularFire</a> gives us streams for free. We can complete the Firebase configuration in a few steps:</p>

<ul>
  <li>Go to <a href="https://firebase.google.com/">https://firebase.google.com</a>, click on the “GO TO CONSOLE” button, and choose your Google account.</li>
  <li>Click on the “Add project” button and choose a name for your project. Let’s take <strong>“reactive-calendar”</strong> to keep it simple.</li>
  <li>Click on the “CREATE PROJECT” button. Now we should be redirected to <a href="https://console.firebase.google.com/project/reactive-calendar/overview">something like this</a>.</li>
  <li>In the Authentication tab, go to “SIGN-IN METHOD” and enable the “Anonymous” setting.</li>
  <li>Click on database and navigate to the rules tab. Set the read and write property to “true” and click “publish”:
    <pre><code class="language-json">{
  "rules": {
      ".read": "true",
      ".write": "true"
  }
}
</code></pre>
  </li>
  <li>Go back to the overview by clicking on the home icon, and then select “Add Firebase to your web app”.</li>
  <li>Copy the config with the correct properties and replace the firebaseConfig object in src/app/app.module.ts with these properties.
It might look something like this:</li>
</ul>

<pre><code class="language-typescript">const firebaseConfig = {
    apiKey: "AIzaSyBuqjTJd5v6xTf8D2EZmvFUl8lseH8lVuHU",
    authDomain: "reactive-calendar.firebaseapp.com",
    databaseURL: "https://reactive-calendar.firebaseio.com",
    projectId: "reactive-calendar",
    storageBucket: "reactive-calendar.appspot.com",
    messagingSenderId: "3978123451455750"
};
</code></pre>

<p>Let’s continue. Start the project by running the following command and open your browser on <a href="http://localhost:4200">http://localhost:4200</a>.</p>

<pre><code>npm start
</code></pre>

<p>As you can see, this just handles static data, the buttons/inputs won’t work, and the appointments are not loaded yet.
This is where we start from.</p>

<h2 id="thinking-reactively">Thinking Reactively</h2>

<p>Now comes the tricky part. We are trying to forget imperative programming for now, and we are trying to evolve into a reactive mindset.</p>

<h3 id="marble-diagrams">Marble Diagrams</h3>

<p>To be able to think reactively, we need some kind of graphic model so we can picture streams in our head. Marble diagrams are a great way to do that.
As you can see in the image below, a marble represents a value over time.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar12.png" alt="Marble diagrams" /></p>

<p>The website <a href="http://rxmarbles.com/">rxmarbles.com</a> has a great playground for learning how to use and draw marble diagrams.</p>

<h4 id="ascii-documentation">ASCII Documentation</h4>

<p>One could argue that code should not be documented and be self-explanatory. I don’t believe that to be the case when writing complex streams. When we document complex streams, we can see what’s going on inside the stream, which makes it easier for our colleagues.
Streams can be documented by ASCII documentation. Since that is not really part of this article, I’m only going to show a small example below.</p>

<pre><code class="language-typescript">// a$ gets three values over time and then stops
// a$: -------a-----b-----c|

// b$ has an initial value (a), has three values in total
// and will keep on living
// b$: a------b-----c------...
</code></pre>

<h3 id="imperative-programming-what-does-the-app-have-to-do">Imperative Programming: What Does the App Have to Do?</h3>

<p>When we think about the functionality of our application, we quickly notice that there are quite a few corner cases and special scenarios. For every interaction the user makes in the UI, the app needs to handle that specific interaction accordingly. Sometimes it has to combine these interactions and handle that specific combination as well. Take this crazy (but simple) example, for instance.</p>

<blockquote>
When the view mode is changed to week mode, and the previous view mode was month mode, and the month was June, and the year was 2017, and an appointment was added, while the search term was set to "Brecht", then we would have to update...
</blockquote>

<p>Yes, we would have to update a bunch of stuff. This is imperative thinking, and it can become exhausting. There is a big chance that we forget certain corner cases. Let’s not even imagine that we have to combine that with asynchronous actions as well.</p>

<p>In the image below, we see all the different interactions the user has in the calendar application.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar2.png" alt="Application events" /></p>

<p>As we can see, for every specific interaction, the UI will have to update specific things.</p>

<h3 id="reactive-programming-what-data-will-change-and-what-data-do-the-components-need">Reactive programming: What Data Will Change, and What Data Do the Components Need?</h3>

<h4 id="source-streams">Source Streams</h4>

<p>Now, let’s completely stop with what we are thinking. Let’s free our minds and stop thinking about corner cases and special scenarios. We have to learn to think in streams. A stream is a collection of events that will change over time. Think about what can change in your application and call these streams of data. Let’s call them <strong>source streams</strong>.</p>

<p><strong>Note:</strong> For readability purposes, we will suffix all the streams with a <code>$</code> symbol.</p>

<p>We can come up with 4 source streams:</p>

<ul>
  <li><strong>navigation$:</strong> Can contain the values: -1, 0 or 1</li>
  <li><strong>viewMode$:</strong> Can contain the values: DAY, WEEK, or MONTH</li>
  <li><strong>searchTerm$:</strong> The value of the search field</li>
  <li><strong>appointments$:</strong> This is an array of appointments that comes from Firebase</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar4.png" alt="data streams" /></p>

<p>That was pretty easy. We just had to think about the events that can occur in our application. A user can navigate, change view mode, search for appointments, and the appointments in Firebase can change. This is the beginning of thinking reactively. Don’t think about who triggers what. Think about the changes as streams.</p>

<p>It’s always a good idea to draw marble diagrams to make it easier to reason.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar5.png" alt="data stream diagram" /></p>

<p><code>The appointments$</code> is a stream that will be provided to us by AngularFire, but the <code>viewMode$</code>, <code>searchTerm$</code>, and <code>navigation$</code> are simple behavior subjects. We use subjects because we need to control the values of the streams ourselves, and we use the <code>BehaviorSubject</code> in particular because all our source streams need an initial value.</p>

<pre><code class="language-typescript">export class AppComponent {
    ...
    // this is how we can retrieve the list of appointments from angularfire
    appointments$ = this.db.list('/appointments');
     // 0--------(+1)----(+1)----(-1)-------------...
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    navigation$ = new BehaviorSubject(0);
    searchTerm$ = new BehaviorSubject('');

	// because we set up the angularfire configuration correctly, we can just
	// inject the angularfiredatabase right here and use it
    constructor(private db: AngularFireDatabase) {
    }
    ...
}

</code></pre>

<p>These subjects get values from the simple interactions from the template.</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        ...
    `
})
export class AppComponent {
    ...
    
    onSetViewMode(viewMode: string): void {
        // when the viewmode changes, update its subject
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        // when the user clicks the previous button
        // update the navigation subject
        this.navigation$.next(-1);
    }

    onNext(): void {
        // when the user clicks the next button
        // update the navigation subject
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        // when the user searches
        // update the searchterm subject
        this.searchTerm$.next(e);
    }
}

</code></pre>

<h4 id="presentational-streams">Presentational Streams</h4>

<p>Now we have to think about the data that our components need, because those components will need to be updated based on those source streams.
Let’s take this code sample, for instance:</p>

<pre><code class="language-html">&lt;div [ngSwitch]="XX" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="XX"
            [date]="XX"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="XX"
            [year]="XX"
            [week]="XX"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="XX"
            [year]="XX"
            [appointments]="xxx"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>I marked the input properties with XX to show what our components need in terms of data. These places will need streams as well. Let’s call them <strong>presentational streams</strong>.</p>

<p>Let’s try to fill in these gaps, shall we?</p>

<p><strong>Note:</strong> We use the <a href="https://angular.io/api/common/AsyncPipe">async pipe</a> from Angular to subscribe/unsubscribe the streams automatically.</p>

<pre><code class="language-html">&lt;div [ngSwitch]="viewMode$|async" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="filteredAppointments$|async"
            [date]="currentDate$|async"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="filteredAppointments$|async"
            [year]="currentYear$|async"
            [week]="currentWeek$|async"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="currentMonth$|async"
            [year]="currentYear$|async"
            [appointments]="filteredAppointments$|async"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>We have gathered the 6 following presentational streams:</p>

<ul>
  <li><strong>viewMode$ (string):</strong> needed to determine which view has to be shown</li>
  <li><strong>filteredAppointments$ (Array &lt; Appointment &gt;):</strong> needed by day view, week view, and month view to render the correct appointments</li>
  <li><strong>currentDate$ (date):</strong> the current date for the day view</li>
  <li><strong>currentWeek$ (number):</strong> the current week for the week view</li>
  <li><strong>currentYear$ (number):</strong> needed by week view and month view</li>
  <li><strong>currentMonth$ (number):</strong> needed by the month view</li>
</ul>

<p>Okay, great, we know the source streams, which are the sources of change in our application.
We know the presentational streams, which are simply the streams that our components need. Now it’s time for the cool part: <strong>We need to create those presentational streams based on the source streams</strong>.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar6.png" alt="sources to presentational streams" /></p>

<p>The first presentational stream we need is <code>viewMode$</code>. This is already an easy one, since <code>viewMode$</code> is also a source stream.</p>

<h4 id="currentdate">currentDate$</h4>
<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar7.png" alt="currentDate$" /></p>

<p><strong>Note:</strong> We use moment.js for date calculation. The suffix M after the currentDate property shows that the type is <code>Moment</code>. So in short, it’s not just a date, but a moment wrapper.</p>

<pre><code class="language-typescript">// we will need this stream a few times, so let's extract the stream 
// in a currentDateM first

// viewMode$:     M------------------W---------------D--------...
// navigation$:   0---(+1)-(-1)----------(+1)-(-1)------------...
// currentDateM$: d---d----d---------d---d----d------d--------...
private currentDateM = this.viewMode$.flatMap((viewMode: string) =&gt; {
    // every time the viewMode changes, the navigation should be reset as well
    // the dateM variable will contain the navigation and because of the 
    // flatMap it will reset every time the view mode changes
    // if the navigation$ changes afterwards it will manipulate the dateM object
    // by adding months, weeks, or days depending on the viewMode
    const dateM = moment();
    return this.navigation$
        .map((action: number) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return dateM.startOf('month').add(action, "months");
                case VIEW_MODE.WEEK:
                    return dateM.startOf('week').add(action, "weeks");
                case VIEW_MODE.DAY:
                    return dateM.startOf('day').add(action, "days");
            }
            return dateM;
        })
})
currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());

</code></pre>

<h4 id="currentweek">currentWeek$</h4>

<p>Based on the <code>currentDateM$</code> we can calculate the current week. The <code>currentDateM$</code> is just a moment object of the current date based on the navigation and viewMode.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar8.png" alt="currentWeek$" /></p>

<pre><code class="language-typescript">currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
</code></pre>

<h4 id="currentmonth">currentMonth$</h4>

<p>Just like we calculated the <code>currentWeek$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar9.png" alt="currentMonth$" /></p>

<pre><code class="language-typescript">currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
</code></pre>
<h4 id="currentyear">currentYear$</h4>

<p>Just like we calculated the <code>currentWeek$</code> and the <code>currentMonth$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar10.png" alt="currentYear$" /></p>

<pre><code class="language-typescript">currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
</code></pre>

<h4 id="filteredappointments">filteredAppointments$</h4>

<p>This is the most important stream. It is used to show the appointments in all the different views, and it is dependent on a bunch of streams:</p>

<ul>
  <li>viewMode$</li>
  <li>currentDateM$</li>
  <li>appointments$</li>
  <li>searchTerm$</li>
</ul>

<p>This looks a bit more complex, but let’s give it a go.</p>

<p><strong>Note:</strong> the <code>[]</code> in the image below stands for an empty array, the <code>[.]</code> for an array with one value, and so on.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar11.png" alt="filteredAppointment$" /></p>

<p>Let’s take the time to process this image. The operator we will use to combine all these streams is called <strong>combineLatest</strong>. It will create a stream that will wait until all streams have a value and will start emitting values for every change of every stream.</p>

<p>So basically, it gives us a function where we have all the information we need. The appointments in Firebase, the view mode, the search term, and the current date. Based on those values, we can calculate the appointments for every view:</p>

<pre><code class="language-typescript">filteredAppointments$ = Observable.combineLatest(
    [this.viewMode$, this.currentDateM$, 
    this.appointments$, this.searchTerm$],
    (viewMode: string, currentDateM: Moment, 
        appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
        switch (viewMode) {
            // calculate the appointments for the month-view based on
            // the current date, the appointments in firebase 
            // and the searchterm
            case VIEW_MODE.MONTH:
                return appointments
                    .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
             // calculate the appointments for the week-view based on
             // the current date, the appointments in firebase
             // and the searchterm
            case VIEW_MODE.WEEK:
                return appointments
                    .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
            // calculate the appointments for the day-view based on
            // the current date, the appointments in firebase
            // and the searchterm
            case VIEW_MODE.DAY:
                return appointments
                    .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));

        }
    });

private filterByTerm(appointment: Appointment, term: string): boolean {
    return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
}
</code></pre>

<p>This is all we have to do in order to create a kick-ass realtime reactive calendar application. We have created it in no time and with only a few lines of code. If we think about it, we will soon realize that all corner cases have been covered.</p>

<h2 id="performance-improvements">Performance Improvements</h2>

<p>The complete component looks like the code snippet below now. The calendar should be completely functional in your browser.</p>

<pre><code class="language-typescript">import { Component } from '@angular/core';
import { VIEW_MODE } from '../../constants';
import * as moment from 'moment';
import { Appointment } from '../../types/appointment.type';
import { AngularFireDatabase } from 'angularfire2/database';
import { Observable } from 'rxjs/Observable';
import Moment = moment.Moment;
import { BehaviorSubject } from 'rxjs/BehaviorSubject';


@Component({
    selector: 'app-root',
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        &lt;div [ngSwitch]="viewMode$|async"&gt;
            &lt;day-view
                    *ngSwitchCase="VIEW_MODE.DAY"
                    [appointments]="filteredAppointments$|async"
                    [date]="currentDate$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/day-view&gt;
            &lt;week-view
                    *ngSwitchCase="VIEW_MODE.WEEK"
                    [appointments]="filteredAppointments$|async"
                    [year]="currentYear$|async"
                    [week]="currentWeek$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/week-view&gt;
            &lt;month-view
                    *ngSwitchCase="VIEW_MODE.MONTH"
                    [month]="currentMonth$|async"
                    [year]="currentYear$|async"
                    [appointments]="filteredAppointments$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/month-view&gt;
        &lt;/div&gt;
    `,
    styleUrls: ['./app.component.less']
})
export class AppComponent {
    VIEW_MODE = VIEW_MODE;
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    // 0--------(+1)----(+1)----(-1)-------------...
    navigation$ = new BehaviorSubject&lt;number&gt;(0);
    searchTerm$ = new BehaviorSubject('');

    // -----MONTH---------------------YEAR------...
    // -----MONTH-------------------------------...
    // -----(d)---------------------------------...
    // --------(+1)----(+1)----(-1)-------------...
    // -----d---d-------d-------d-----d----------...

    private currentDateM$ = this.viewMode$.flatMap((viewMode: string) =&gt; {
        let dateM = moment();
        return this.navigation$
            .map((action: number) =&gt; {
                switch (viewMode) {
                    case VIEW_MODE.MONTH:
                        return dateM.startOf('month').add(action, 'months');
                    case VIEW_MODE.WEEK:
                        return dateM.startOf('week').add(action, 'weeks');
                    case VIEW_MODE.DAY:
                        return dateM.startOf('day').add(action, 'days');
                }
                return dateM;
            })
    });

    currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());
    currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
    currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
    currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
    appointments$ = this.db.list('/appointments');
    filteredAppointments$ = Observable.combineLatest([this.viewMode$, this.currentDateM$, this.appointments$, this.searchTerm$],
        (viewMode: string, currentDateM: Moment, appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.WEEK:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.DAY:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));

            }
        });

    constructor(private db: AngularFireDatabase) {
    }

    private filterByTerm(appointment: Appointment, term: string): boolean {
        return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
    }

    onSetViewMode(viewMode: string): void {
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        this.navigation$.next(-1);
    }

    onNext(): void {
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        this.searchTerm$.next(e);
    }

    onRemoveAppointment(id: string): void {
        this.appointments$.remove(id);
    }

    onAddAppointment(date: Date): void {
        this.appointments$.push(new Appointment(date.toDateString(), ''));
    }

    onUpdateAppointment(appointment: Appointment): void {
        this.db.object('appointments/' + appointment.$key).set({
            description: appointment.description,
            date: appointment.date
        });
    }
}

</code></pre>

<p>There is only one problem. We use the same observables multiple times in our template. Since observables are cold by default, they will get executed every time there is a subscription. In Angular, this means a subscription for every async pipe. For performance reasons, we only want to recalculate these streams when something actually changes. For that purpose, we can try to use the <code>share()</code> operator from RxJS. The <code>share()</code> operator is an alias for <code>publish().refCount()</code> and will share the subscription.</p>

<p>However, that creates some problems with Angular and its async pipe.
The situation of the problem goes like this:</p>

<ul>
  <li>Since we are using BehaviorSubjects, the streams will get an initial value (which is what we want, of course).</li>
  <li>The share() operator will emit that value on the first subscription</li>
  <li>When the app is initialized, the async pipes will start subscribing to the stream.</li>
  <li>Because the first async pipe triggered the first emit the rest of the async pipes will miss that value.</li>
</ul>

<p><strong>Solution: shareReplay() will emit those values but keep track of them. That way, the async pipes will never miss a value.</strong></p>

<h2 id="conclusion">Conclusion</h2>

<p>We have created a completely reactive calendar that is performant and fixes a bunch of corner cases in only a few lines of code. Just by thinking about source streams and presentational streams, it wasn’t even that hard. I hope that I can encourage more people to take on this reactive approach and start writing kick-ass applications.</p>

<h2 id="special-thanks">Special Thanks</h2>

<p>I would like to give special thanks to the awesome people that reviewed this post and gave me pointers:</p>

<ul>
  <li>Dominic Elm (<a href="https://twitter.com/elmd_">@elmd_</a>)</li>
  <li>Manfred Steyer (<a href="https://twitter.com/manfredsteyer">@manfredsteyer</a>)</li>
  <li>David Müllerchen (<a href="https://twitter.com/webdave_de">@webdave_de</a>)</li>
  <li>Maxim Robert (<a href="https://twitter.com/sizerone">@sizerOne</a>)</li>
</ul>

<p>Thanks, guys! It means a lot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>How to setup marble testing</title>
	  <link>//how-to-setup-marble-testing/</link>
	  <author></author>
	  <pubDate>2017-02-15T00:00:00+00:00</pubDate>
	  <guid>//how-to-setup-marble-testing/</guid>
	  <description><![CDATA[
	     <p>In an earlier blogpost, I showed you guys how to do client side filtering with streams (<a href="http://blog.kwintenp.com/client-side-filtering-with-streams/" target="_blank">here</a>). I tried to show you how you could use marble diagrams to draw out how the data will flow in your streams. Turns out that drawing your marble diagrams up front can help you a lot in testing your code as well. Using the marble diagram testing provided by RxJS, we can easily test the code we’ve written in the previous post. Let’s see how.</p>

<h3 id="setting-up-the-marble-diagram-testing">Setting up the marble diagram testing</h3>

<p>The steps to set this up are really easy. First we need to copy two files from the RxJS source code into our own codebase. This is the <code>marble-testing.ts</code> and <code>test-helper.ts</code> file which you can find <a href="https://github.com/ReactiveX/rxjs/tree/master/spec/helpers" target="_blank">here</a>.
The next thing you need to do is import these files in a test where you want to use the marble testing.</p>

<pre><code class="language-typescript">import "./helpers/test-helper.ts";
// I'll come back to these imports later
import { hot, cold, expectObservable } 
	from './helpers/marble-testing';
</code></pre>

<p>That’s it, you are ready to start testing!</p>

<h3 id="example">Example</h3>

<p>The marble diagram for the example looks like this:</p>

<p><img src="https://www.dropbox.com/s/zhj0xvz6d5e84m4/Screenshot%202017-03-04%2016.12.24.png?raw=1" alt="marble-diagram" /></p>

<p>We have a stream containing the characters (which will come from the backend) and one containing a value to filter the characters based on the gender. We use the <code>combineLatest</code> operator to create a new stream which hold the filtered characters. The code to create this stream based on the two input streams looks like this:</p>

<pre><code class="language-typescript">public createFilterCharacters(
        filter$: Observable&lt;string&gt;,
        characters$: Observable&lt;StarWarsCharacter[]&gt;) {
  return characters$.combineLatest(filter$,
     (characters: StarWarsCharacter[], filter: string) =&gt; {
      if (filter === 'All') {
        return characters;
      }
      return characters.filter(
            (character: StarWarsCharacter) =&gt;
              character.gender.toLowerCase() === filter.toLowerCase()
      );
  });
}
</code></pre>
<p>Every time the filter stream produces a new value, we loop over the array of characters and filter out the correct ones.</p>

<h4 id="testing-without-marble-diagrams">Testing without marble diagrams</h4>
<p>Trying to test this code without using marble diagram testing is quite verbose. First of all, we would need to create two streams ourselves to mock the character and gender filter streams. Then we would need to feed them to the method and take back the resulting stream. In our test, we would have to subscribe ourselves to this stream to check if the resulting next events are the ones we expect in the order we expect them. 
Let’s look at what that code would look like:</p>

<pre><code class="language-typescript"> it('on createFilterCharacters without marble testing', () =&gt; {
    // create a characters$ stream
    const characters$ = Observable.of([obiWan, c3po, leia]);
    // create a gender$ stream which is used to filter
    const gender$ = new BehaviorSubject&lt;string&gt;('All');


    let times = 0;
    // Feed the two streams to the method and subscribe to the result
    component.createFilterCharacters(gender$, characters$).subscribe(
      (val) =&gt; {
        // Based on the number of values that have passed here
        // check the value to see if it is what we expect
        if (times === 0) {
          expect(val).toEqual([obiWan, c3po, leia]);
          times++;
        } else if (times === 1) {
          expect(val).toEqual([obiWan]);
          times++;
        } else if (times === 2) {
          expect(val).toEqual([c3po]);
          times++;
        } else if (times === 3) {
          expect(val).toEqual([leia]);
          times++;
        }
      }
    );

    // pass new values to the gender subject to emulate the
    // gender filter change
    gender$.next("Male");
    gender$.next("N/A");
    gender$.next("Female");
  });
</code></pre>

<h4 id="testing-with-marble-testing">Testing with marble testing</h4>
<p>We can write this a lot easier using marble diagram testing. To do this, we need to define ASCII marble diagrams and create observables from them. We can define the character stream like this:</p>

<pre><code class="language-typescript">import { cold } from './helpers/marble-testing';

// Here we create an ASCII marble diagram that 
// represents our characters stream. Since this
// is a backend call in real life, this will 
// first take some time before a value is ready.
// We represent this by using the '-'. It will take
// 4 ticks or '-' before the result arrives. We
// define the result with a c here and close with a
// '|'. This denotes that the stream completes.
const charactersASCII = "----c|";
// We define an object that represents the values
// in the stream above. We used the 'c' to denote 
// a 'next' event and we use the same 'c' in the 
// object below to point to the actual value.
const charactersValues = {c: [obiWan, c3po, leia]};

// The ASCII and the values above aren't streams
// of course. And our method is expecting a stream.
// Using the 'cold' helper method from the 
// marble-testing, we can create a stream from
// the ASCII and the values.
const characters$ = cold(charactersASCII, charactersValues);
</code></pre>
<p>Now we created a stream that resembles our characters stream.</p>

<p><img src="https://www.dropbox.com/s/zyr7j5goywo3asy/Screenshot%202017-05-06%2018.14.21.png?raw=1" alt="marble-diagram" /></p>

<p>Let’s create the second stream. It looks the exact same way but we use the <code>hot</code> helper function instead since we are working with a subject here.</p>

<pre><code class="language-typescript">import { hot } from './helpers/marble-testing';

const gender = "a------b---c--d";
const genderValues = {a: "All", b: "Male", c: "N/A", d: "Female"};

const genderFilter$ = hot(gender, genderValues)
</code></pre>
<p>Now that we have created streams based on our ASCII marble diagrams, we can feed them to the function we are testing. But what do we do with the observable that is returned from this function? Luckily we can use another helper function provided by RxJS for that. 
Let’s take a look at the full example.</p>

<pre><code class="language-typescript"> it('on createFilterCharacters with marble testing', () =&gt; {
    const charactersAscii = "----c|";
    const charactersValues = {c: [obiWan, c3po, leia]};

    const gender = "a------b---c--d";
    const genderValues = 
    	{a: "All", b: "Male", c: "N/A", d: "Female"};

	 // Call the function we are testing with 
	 // the observables created. 
    const result$ = component.createFilterCharacters(
    	hot(gender, genderValues), 
    	cold(charactersAscii, charactersValues)
    );

    // Use the expectObservable helper function. This
    // takes an observable and compares it to a marble
    // diagram for correctness.
    expectObservable(result$)
    	.toBe(
    		"----a--b---c--d", 
    		{
    		    a: charactersValues.c,
    		    b: [obiWan],
    		    c: [c3po],
    		    d: [leia]}
    	);
  });
</code></pre>

<h3 id="conclusion">Conclusion</h3>
<p>Using marble diagram testing, we can write tests way faster and very easy. If we use marble diagrams up front to think about our streams, we can use this to test our code as well.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Using decorators and observables to implement retry</title>
	  <link>//decorators-and-observables-to-implement-retry-logic/</link>
	  <author></author>
	  <pubDate>2017-02-15T00:00:00+00:00</pubDate>
	  <guid>//decorators-and-observables-to-implement-retry-logic/</guid>
	  <description><![CDATA[
	     <p>Last week, I was at a meetup in Ghent where I was talking with <a href="https://twitter.com/stefanlapers" target="_blank">Stefan Lapers</a> about programming languages in general. We started talking about writing your backend using either Java or node.js. We agreed that node.js has massive potential but in a lot of situations companies choose Java because of it’s maturity. If you’re using a microservices based architecture for example, you can rely heavily on spring cloud which does a whole bunch of stuff for you so you can focus on functionality.
One element in spring cloud is hystrix. When you’re doing a network call which is protected by hystrix, you can, by just adding an annotation, tell how many times you want to retry this if it fails and even provide a fallback if it fails entirely.</p>

<p>When I was driving home later that night, I was thinking to myself that using observables and typescript decorators, it should be possible to implement something similar myself. The next morning I tried it out and about 30 minutes later I had a working version. Here it is.</p>

<h2 id="the-example">The example</h2>

<p>In the example below, we have a service which fetches a number of Star Wars characters from the backend, at least it tries. It seems I kind of screwed up the implementation a little :).</p>

<pre><code class="language-typescript">public getCharactersAndFail(): Observable&lt;StarWarsCharacter[]&gt; {
    return Observable.throw('Failing on purpose');
}
</code></pre>
<p>Instead of actually doing a backend call, I’m just returning an observable which will throw as soon as it’s subscribed to. This is of course not to handy but for demonstration purposes, it’s quite ideal.
Using the decorator I created myself, we can make this code a little more resillient (we’ll dive into how this decorator is constructed later on).</p>

<pre><code class="language-typescript">@retry(3, [{name: 'Obi Wan', birth_year: '1234', gender: 'Male'}])
public getCharactersAndFail(): Observable&lt;StarWarsCharacter[]&gt; {
    return Observable.throw('Failing on purpose');
}
</code></pre>

<p>I’ve added the <code>retry</code> decorator. The first argument it takes tells the decorator the times it should retry the backend call. The second parameter is the fallback that will be used if the backend keeps on failing.</p>

<p>The following is a gif of what happens when you try to run this code:</p>

<p><img src="https://www.dropbox.com/s/7natkxyj02o3xmd/Mar-08-2017%2019-32-51.gif?raw=1" alt="example-gif" /></p>

<p>You can see that there are 3 tries before the method returns the fallback we defined. Pretty cool right.</p>

<p>A second example is if you click the button below the first example. This will actually try to do the real request.
The code for this backend call looks like this:</p>

<pre><code class="language-typescript">@retry(3, [{name: 'Obi Wan', birth_year: '1234', gender: 'Male'}])
public getCharacters(): Observable&lt;StarWarsCharacter[]&gt; {
    return this.http.get('https://swapi.co/api/people/')
      .map((response: Response) =&gt; response.json().results);
}
</code></pre>

<p>For the retry example here to work, you have to go offline first, which will cause the request to fail. If you then try to run this code, you can see in the network tab it actually tries to do 3 requests, which fail because we are offline. After three attempts, the fallback is returned.</p>

<p><img src="https://www.dropbox.com/s/494jhrwvtdelo09/Mar-08-2017%2019-35-31.gif?raw=1" alt="example-gif" /></p>

<p>You can find the live working example <a href="http://blog-kwintenp-examples.surge.sh/home/retry" target="_blank">here</a>. Open up your console to see the number of tries and inspect the network tab with the second example.</p>

<h2 id="the-implementation">The implementation</h2>

<p>To implement this, there are two important things we need to do. First is implementing the logic to retry the call if it failed. We can levarage streams for this. Next we need to extract that logic into a typescript decorator.</p>

<h3 id="observable-composition">Observable composition</h3>

<p>Retrying a subscription after it has failed is fairly easy using RxJS. We can use the <code>retryWhen</code> operator for this. Let’s look at some code.</p>

<pre><code class="language-typescript">private starWarsService: StarWarsService;

characters$: Observable&lt;StarWarsCharacter&gt; = 
	// we call the starWarsService to get the characters
	this.starWarsService
		.getCharacters()
		// we use the retryWhen operator to retry a number of times
		.retryWhen((errors: Observable&lt;any&gt;) =&gt; {
		  // we use the scan operator to count the number of tries
          return errors.scan((errorCount, err) =&gt; {
            console.log('Try ' + (errorCount + 1));
            if (errorCount &gt;= 3) {
              throw err;
            }
            return errorCount + 1;
          }, 0).delay(1000);
        })
        // we catch the error if it keeps on failing and return
        // the fallback
        .catch(() =&gt; Observable.of(fallback));
</code></pre>
<p>I’m not going to go into the details of the RxJS implementation, that whould require a totally separate post.
What this code does however, is create an observable that, once subscribed to, will try to execute the backend call. If it fails, which it will in our case, it will re-execute it 2 more times with a single second delay in between. If it still fails, it will return the fallback we can define.</p>

<p>That’s the exact logic we want our decorator to do. So let’s see how we can extract this logic in the decorator.</p>

<h3 id="creating-a-decorator">Creating a decorator</h3>

<p>There are different types of decorators. We can put a decorator on a class, method, property or accessor method. In our case, we are going to use the method decorator. A method decorator is in fact nothing more than a function that gets called at runtime. You can find more information on what decorators are and how to use them <a href="https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators" target="_blank">here</a></p>

<p>Using a method decorator, you can replace, observe or modify the method definition. What we are going to do is really easy. Lets take a look at the image below.</p>

<p><img src="https://www.dropbox.com/s/o3xef1gl9f4jlmd/Screenshot%202017-03-05%2014.14.48.png?raw=1" alt="method decorator" /></p>

<p>At runtime, when the method we are decorating gets called, the decorator will be called first (1). We are going to call the actual function (2) which is going to return an observable in our case (3). Before returning the observable to the caller of our decorated function (5), we are going to augment the observable with our retry logic (4) and return this new observable.</p>

<p>Lets take a look at the code:</p>

<pre><code class="language-typescript">// defining the decorator is the same as the defining a
// function with the same name
export function retry(times = 3, fallback: any) {
  return (target, key, descriptor) =&gt; {
    // the descriptor holds a reference to the actual method
    // we are decorating
    const originalMethod = descriptor.value;
    // we replace the old function with a new function
    descriptor.value = function () {
      // call the original method and
      // augment the resulting observable
      // with the retry and fallback mechanism
      // we defined above
      return originalMethod.apply(this)
        .retryWhen((errors) =&gt; {
          return errors.scan((errorCount, err) =&gt; {
            console.log('Try ' + (errorCount + 1));
            if (errorCount &gt;= times - 1) {
              throw err;
            }
            return errorCount + 1;
          }, 0).delay(1000);
        })
        .catch(() =&gt; Observable.of(fallback));
    };
    // return edited descriptor as opposed to
    // overwriting the descriptor
    return descriptor;
  };
}
</code></pre>
<p>In the decorator we take the original function. We replace this function with a new one that executes the original one and augments the resulting observable with our retry logic.</p>

<p>Once you’ve understood the syntax of the method decorator, this implementation is pretty straight forward. It now allows us to add the decorator on top of every function that returns an observable like this:</p>

<pre><code class="language-typescript">@retry(3, [{name: 'Obi Wan', birth_year: '1234', gender: 'Male'}])
public getCharactersAndFail(): Observable&lt;StarWarsCharacter[]&gt; {
    return Observable.throw('Failing on purpose');
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Using the ease of composing of observables and decorators in typescript, we were able to create something really fast which can be reused throughout our entire application. It shouldn’t stop with a retry decorator. We could apply this principle to a whole bunch of RxJS related issues like catching errors for example.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Client side filtering using streams</title>
	  <link>//client-side-filtering-with-streams/</link>
	  <author></author>
	  <pubDate>2017-02-15T00:00:00+00:00</pubDate>
	  <guid>//client-side-filtering-with-streams/</guid>
	  <description><![CDATA[
	     <p>I have been coaching people in using RxJS for a while now. During this time, I’ve noticed that the hardest part for people to learn is not the API, concept or operators but the paradigm switch. Thinking reactively is not something that comes easily and you really have to get your hands dirty to get there.</p>

<p>Below I will show a piece of code that is used to do some basic client side filtering. It’s a snippet of code from somebody that I was coaching which perfecly shows how someone just starting with RxJS often handles this situation. Later on, we will update this to show how you would implement this with the reactive paradigm.</p>

<h3 id="example-case">Example case</h3>

<p>The example application we will be using is really easy. We have service which fetches a number of Star Wars characters from the swapi.com API. We will show these in a list and provide a select element to filter the fetched characters based on the gender.
The screen looks like this:</p>

<p><img src="https://www.dropbox.com/s/2s9e877rpdaa5w0/Screenshot%202017-02-25%2011.16.57.png?raw=1" alt="example-app" /></p>

<p>You can find the live example <a href="http://blog-kwintenp-examples.surge.sh/client-side-filter/withStream" target="_blank">here</a>.</p>

<h3 id="client-side-filtering-without-streams">Client side filtering without streams</h3>

<p>First we are going to look at an example where we implement the client side filtering without streams. Of course, we are going to use a stream to fetch the data from the backend, but afterwards, the implementation will be imperative.</p>

<pre><code class="language-typescript">// keep a local list of all the characters
characters: Array&lt;StarWarsCharacter&gt;;
// keep a list of all the filtered characters
filteredCharacters: Array&lt;StarWarsCharacter&gt;;

constructor(private starWarsService: StarWarsService) {}

// at startup time, we fetch the characters and save them
// to our local copy. We keep a local copy of the entire
// array since we will need it later on when the filter changes
ngOnInit() {
  this.starWarsService.getCharacters()
    .subscribe((fetchedCharacters) =&gt; {
        this.characters = fetchedCharacters;
        this.filteredCharacters = fetchedCharacters;
    })
}

// when the filter value changes, we filter the local list of
// characters and save the result to the
// filteredCharacters array. Here we reuse the entire array
// to create a new one.
filterChanged(value: string)
  if (value === "All") {
    this.filteredCharacters = this.characters;
  } else {
    this.filteredCharacters =
       this.characters.filter(
            (character: StarWarsCharacter) =&gt; {
               character.gender.toLowerCase() === value.toLowerCase()
            }
       );
  }
}
</code></pre>
<p>At startup time, we fetch the characters and save them in two local arrays, <code>characters</code> and <code>filteredCharacters</code>. When the filter actually changes, we use the local copy of the characters to filter out all the correct ones and create a new array. We then assign this new array to the <code>filteredCharacters</code> reference.
The component’s html looks like this:</p>

<pre><code class="language-html">&lt;h1&gt;Client side filtering without streams example&lt;/h1&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;
    &lt;!-- Component that holds the select and throws an event --&gt;
    &lt;!-- when it changes --&gt;
    &lt;app-gender-filter (filterChange)="filterChanged($event)"&gt;
    &lt;/app-gender-filter&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-9"&gt;&lt;/div&gt;
  &lt;div class="col-sm-6"&gt;
    &lt;!-- component that holds the list and displays the --&gt;
    &lt;!-- characters --&gt;
    &lt;app-character-list [characters]="filteredCharacters"&gt;
    &lt;/app-character-list&gt;
  &lt;/div&gt;
&lt;/div&gt;

</code></pre>

<p>While this all works perfectly, it’s not the best solution possible with the reactive paradigm in mind. We have to hold a local copy of the characters array, which kind of bugs me.
It’s also not really flexible. Here, we are fetching the characters via a backend call. This will thus only hold one result. But what if it’s an observable we get from Firebase? In that case the characters array can change as well. To be able to update the view properly when the characters change, we would also have to keep a local copy of the filter to update the <code>filteredCharacters</code> array reference accordingly.
And what if you would have a multitude of filters… This would result in a multitude of local variables to keep track of.</p>

<p>Using streams we can make this much more flexible!</p>

<h3 id="client-side-filtering-with-streams">Client side filtering with streams</h3>

<p>Let’s first of all try to think what should happen by thinking in streams of data. We will then try to reason about how we can use these streams, combine them and create a result.</p>

<p>If you think about it, we have two inputs that might change our view. On the one hand, we have our list of characters, which should be displayed. And on the other hand we have the dropdown which might filter this list.</p>

<p>Let’s look at the marble diagrams of what these streams might look like:</p>

<p><img src="https://www.dropbox.com/s/89blsfj9aoybdg0/Screenshot%202017-03-04%2016.10.54.png?raw=1" alt="marble-diagram" /></p>

<p>The resulting stream we want is one that holds an array with the filtered characters. If you think about the two input streams we just created, this resulting stream is actually a combination of both of the input streams.
If we have characters, we want to combine these with the filter and display them onto the screen. If the filter changes, we want to re-execute this logic. If we would have new characters (think about a stream from Firebase), we would also want to re-execute this logic.</p>

<p>It turns out that RxJS provides us with a perfect operator to do something like this: <code>combineLatest</code>. This operator merges streams by executing a projector function on the latest values of these streams.
The resulting stream looks like this:</p>

<p><img src="https://www.dropbox.com/s/zhj0xvz6d5e84m4/Screenshot%202017-03-04%2016.12.24.png?raw=1" alt="marble-diagram" /></p>

<p><strong>Note:</strong> You can notice here that the result stream only holds a value when both of the streams have emitted a single value. This is a precondition of the <code>combineLatest</code> operator. It will only emit an event onto the newly created stream if all source observables have emitted at least one element. If we think about our example, this means that the gender filter should already have a value to start with.</p>

<p>Let’s take a look at the code!</p>

<pre><code class="language-typescript">export class ClientSideFilterComponent implements OnInit {
  filter$: BehaviorSubject&lt;string&gt;;
  characters$: Observable&lt;StarWarsCharacter[]&gt;;
  filteredCharacters$: Observable&lt;StarWarsCharacter[]&gt;;

  constructor(private starWarsService: StarWarsService) {
  }

  ngOnInit() {
    // We create a stream ourselves to map an event form the child
    // component to a stream of 'filter values'.
    // We use a BehaviorSubject because this will have an initial 
    // value. This is important because the combineLatest operator
    // we will use below only works if every stream has emitted 
    // at least one value.
    this.filter$ = new BehaviorSubject("All");

    // we keep the stream containing our characters
    this.characters$  = this.starWarsService.getCharacters();

    // we create a new stream based on the two input
    // streams we defined
    this.filteredCharacters$ = this.createFilterCharacters(
            this.filter$,
            this.characters$
    );
  }

  public createFilterCharacters(
            filter$: Observable&lt;string&gt;,
            characters$: Observable&lt;StarWarsCharacter[]&gt;) {
    // We combine both of the input streams using the combineLatest
    // operator. Every time one of the two streams we are combining
    // here changes value, the project function is re-executed and
    // the result stream will get a new value. In our case this is
    // a new array with all the filtered characters.
    return characters$.combineLatest(
      filter$, (characters: StarWarsCharacter[], filter: string) =&gt; {
        // this is the project function where we imperatively
        // implement the filtering logic
        if (filter === "All") return characters;
        return characters.filter(
                (character: StarWarsCharacter) =&gt;
                    character.gender.toLowerCase()
                        === filter.toLowerCase()
        );
      });
  }

  filterChanged(value: string) {
    // Everytime we have new value, we pass it to the filter$
    this.filter$.next(value);
  })
}
</code></pre>
<p>We can use the new stream we created to bind in the view using the async pipe from Angular like this:</p>

<pre><code class="language-html">&lt;h1&gt;Client side filtering with streams example&lt;/h1&gt;
&lt;div class="row"&gt;
  &lt;div class="col-sm-3"&gt;
    &lt;app-gender-filter (filterChange)="filterChanged($event)"&gt;
    &lt;/app-gender-filter&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-9"&gt;&lt;/div&gt;
  &lt;div class="col-sm-6"&gt;
    &lt;!-- Using the async pipe we bind it in the app-character-list --&gt;
    &lt;!-- component --&gt;
    &lt;app-character-list [characters]="filteredCharacters$ | async"&gt;
    &lt;/app-character-list&gt;
  &lt;/div&gt;
&lt;/div&gt;

</code></pre>

<p>If we look at the code we have now, it’s much more flexible. We do not have to write any extra code if the <code>characters$</code>  would have any new values. We do not need to hold any local copies (this is done implicitely by the <code>combineLatest</code> operator). If we would want to add new filters, it’s just a matter of adding another stream to the <code>combineLatest$</code> operator.
We also don’t have to manually unsubscribe from the filteredCharacters$, the async pipe handles this for us.</p>

<h3 id="conclusion">Conclusion</h3>
<p>By thinking in input streams and output streams, we were able to map the inputs we had to a result. We bound the stream in the view layer. Using streams up until the html of our component, we eliminated the need for local copies of data and made our code more robust and open to changes. If we now want to add another filter on top of the list, it’s a piece of cake!</p>

<p>You can find the code on <a href="https://github.com/KwintenP/blog-examples/tree/master/src/app/home/client-side-filter" target="_blank"> Github </a>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>My favorite metaphor for hot vs cold observables</title>
	  <link>//my-favorite-metaphor-for-hot-vs-cold-observables/</link>
	  <author></author>
	  <pubDate>2017-01-10T00:00:00+00:00</pubDate>
	  <guid>//my-favorite-metaphor-for-hot-vs-cold-observables/</guid>
	  <description><![CDATA[
	     <p>A few weeks ago, I was at NG-BE (best conference of the year btw), where I was giving a workshop on RxJS and @ngrx/store in Angular 2 applications. In this course, we also explain hot vs cold observables.
When I try to explain new concepts to people, I either try to start from a known concept and build my way up to the new thing or use a metaphor. I’ve been looking for a similar approach to explain the hot vs cold observables concept but didn’t found one myself.
At the conference, I started talking with <a href="https://www.linkedin.com/in/lander-verhack-a404a04b" target="_blank">Lander Verhack</a>. Lander gives trainings at U2U and he told me a great metaphor for this concept. I’ll try to explain it below but all credits go to him for coming up with it.</p>

<h3 id="watching-a-movie">Watching a movie</h3>
<p>When you want to watch a movie nowadays, you have a lot of different options. You can either go to the movies, rent out a dvd (do people still do this?) or use some service like Netflix.
Lets first think about what happens when you watch a movie via Netflix.</p>

<h4 id="netflix">Netflix</h4>
<p>First step in watching a movie on Netflix is looking one up in the catalogue. As soon as you have found one, you can decide to start watching it. A Netflix movie will, unless you’ve already watched a part, start from the beginning. It doesn’t matter how many other people are watching the movie, you will always start at the beginning. If the movie doesn’t live up to your expactations, you can decide to stop watching it.</p>

<p>It turns out that watching a movie on netflix is the perfect metaphor for a cold observable. Lets take a look at the common properties between these two:</p>

<ul>
  <li>If no one is listening, the movie is not streamed. The movie stream is lazy, just like the cold observable.</li>
  <li>For every listener, a new stream is started. It’s not because 5 people are already watching the movie somewhere else in the world, that your movie will not start from the beginning. The movie stream is unicast, just like a cold observable.</li>
</ul>

<h4 id="going-to-the-movies">Going to the movies</h4>
<p>Another way of watching a movie is by going to the movies. In contrast with Netflix, it’s not you who decides when the movie will begin. It will begin at a predetermined time. When the movie starts, everyone who is present will see the same movie. If someone arrives too late, he will have missed the first part of the movie, but can follow everything afterwards the same way as the other people. If you decide to stop watching the movie because you don’t like it, the other people can keep on watching it. If everybody decides to walk out because it’s that bad, the movie will keep on playing.</p>

<p>Going to the movies is actually the perfect metaphor for a hot observable. Lets take a look at the common properties between the two:</p>

<ul>
  <li>As soon as the movie starts, everybody who is watching it, sees the same thing. If a person arrives 5 minutes late, the movie will not restart just for him. He will, from his moment of arrival, see the same things. So watching a movie at the movies is the same as a hot observable because it is multicast.</li>
  <li>If the movie has already started, and you arrive 5 minutes later, you will have missed the first part. So just like a hot observable, the movie is not lazy.</li>
</ul>

<h3 id="what-about-publishrefcount">What about <code>publish().refCount()</code></h3>

<p>Aside from hot and cold observables, you can also create an observable that starts emitting values as soon as there is one subscriber. You can accomplish this with the <code>publish().refCount()</code> operator or its alias <code>share()</code>. I’ve seen people calling this observable ‘warm’, ‘semi-hot’ or ‘semi-cold’.</p>

<h4 id="watching-a-movie-with-friends">Watching a movie with friends</h4>
<p>You could think of this ‘type’ of observable as watching a movie with some (douchy) friends. Let’s say you decide to watch a movie together at 6PM at your friends place. Due to car trouble, you’ll be runnning 15 minutes late so you text your friend and ask him to wait.
Because he is so excited about the movie, he decides to start anyway. As expected, you arrive 15 minutes late and you keep on watching the movie, having missed the first part.</p>

<p>Let’s see how this maps to the ‘warm’ observable we described above.</p>

<ul>
  <li>Since your (douchy) friend decides to start watching the movie, you missed the first part. So, as soon as he starts watching the movie, the movie stream starts and all your friends that were on time, see the same values. Since you arrive too late, you’ll miss the first part. This is exactly the same as our ‘warm’ observable.</li>
</ul>

<h3 id="conclusion">Conclusion</h3>
<p>So, if you ever have to explain the concept yourself, or just as a way to better remember it, think of observables like this:</p>

<ul>
  <li>Hot observable 		-&gt; 		Movie at the movies</li>
  <li>Cold observable 		-&gt; 		Movie with netflix</li>
  <li>‘Warm’ observable 	-&gt; 		Movie with friends</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Infinite scroll in Angular an RxJS</title>
	  <link>//infinite-scroll-with-rxjs-and-angular2/</link>
	  <author></author>
	  <pubDate>2016-12-21T00:00:00+00:00</pubDate>
	  <guid>//infinite-scroll-with-rxjs-and-angular2/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>This article explains how the “reactive-programming” approach helps us to create an awesome <strong>infinite-scroll-list</strong> in only a few lines of code. For this article, we are going to use <a href="http://reactivex.io/rxjs/">RxJS</a> and <a href="http://angular.io">Angular</a>. If <a href="http://reactivex.io/rxjs/">RxJS</a> is completely new, it might be a good idea to read the documentation first. Whether we use <a href="http://angular.io">Angular</a> or something else like <a href="https://facebook.github.io/react/">React</a>, it shouldn’t really interfere with the clarity of this article.</p>

<h2 id="reactive-programming">Reactive programming</h2>

<p>Reactive programming is a rather old but very powerful approach of solving problems. However, we can run into problems when trying to think in a completely reactive manner. Thinking reactively is a huge mind switch that we must make to completely accept this “new” way of coding things. The whole “Our application reacts to a state-management-layer like <a href="http://redux.js.org/">redux</a>” principle is grasped quite quickly (it’s reactive programming too), but when it comes to <a href="http://freecontent.manning.com/reactive-fundamentals-thinking-in-streams/">thinking in streams</a> it can become quite difficult in the beginning.</p>

<h3 id="why-reactive-programming">Why reactive programming?</h3>

<p>Reactive programming has some advantages over imperative programming.</p>

<ul>
  <li>No more “if this, then that” scenario’s</li>
  <li>We can forget about a ton of edge-cases&lt;</li>
  <li>It’s easy to separate presentation logic from other logic (The presentation layer will just react to streams)</li>
  <li>It’s a standard: widely supported by tons of languages</li>
  <li>When we grasp the concepts, we write complex logic in a few lines of code in a very simple manner</li>
</ul>

<p>A few days back a colleague of mine came to me with this problem: He wanted to create an <strong>infinite-scroll in Angular</strong> but he had bumped into the  boundaries of imperative programming. It turned out that an infinite-scroll-solution was actually a great use-case to explain how reactive programming can help you write better code.</p>

<h2 id="the-infinite-scroll">The infinite scroll</h2>

<h3 id="what-should-it-do">What should it do?</h3>

<p>An infinite-scroll-list, is a list where the data is being loaded asynchronosly when the user scrolls further down the application. It’s a great way to avoid a pager (where the user had to click on every time) and it can really keep the application performant. It’s an efficient way to keep bandwidth low and increase the user-experience.</p>

<p>For this scenario, let’s say that every page contains 10 results and that all the pages with results are being shown as one long scrollable list =&gt; the infinite-scroll-list.</p>

<p>Let’s list the features of what our infinite-scroll-list must do:</p>

<ul>
  <li>It should load the first page by default</li>
  <li>When the results of the first page don’t fill the page completely, it should fill page 2, and so on, until the page is full</li>
  <li>When the user scrolls down, it should load page 3, and so on…</li>
  <li>When the user resizes it’s window, and more space is being freed for results, it should load the next page</li>
  <li>It should make sure that it doesn’t load the same pages more than once (caching)</li>
</ul>

<h2 id="lets-draw-it-first">Let’s draw it first</h2>

<p>Like most coding decisions, drawing them on a whiteboard first might be a good idea. That might be a personal approach, but it helps us not to write code that will be removed/refactored later.</p>

<p>Based on the feature-list, there are three actions that will trigger the application to load data: Scrolling, resizing, and a manual action that will be triggered to manually fetch pages. When thinking reactively we can see 3 sources of events happening, let’s call them streams:</p>

<ul>
  <li>A stream of scroll events: <strong>scroll$</strong></li>
  <li>A stream of resize events: <strong>resize$</strong></li>
  <li>A manual stream where we can manually decide what page to load: <strong>pageByManual$</strong></li>
</ul>

<p><strong>Note: We will suffix the streams with $ to indicate that they are streams, this is a convention (personal preference)</strong></p>

<p>Let’s draw these streams on a whiteboard:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard1.png" alt="Whiteboard 1" /></p>

<p>These streams would contain certain values over time:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard2.png" alt="Whiteboard 2" /></p>

<p>The scroll$ stream has Y values, which we can use to calculate the page number.</p>

<p>The resize$ stream has event values. We don’t need the values but we do need to know when the user resizes its window.</p>

<p>The pageByManual$ will contain page numbers, which we can set directly since this is a subject (more on that later).</p>

<p>What if we could map all these streams, to streams that would contain page numbers? That would be awesome, because based on the page number, we could load a specific page. How we map the current streams to page number-streams is not something that we need to think about right now (we are just drawing remember?).
The next drawing might look something like this:</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard3.png" alt="Whiteboard 3" /></p>

<p>We can see that we have created the following streams based on our initial streams:</p>

<ul>
  <li><strong>pageByScroll$</strong>: which contains page numbers based on the scroll-events</li>
  <li><strong>pageByResize$</strong>: which contains page numbers based on the resize-events</li>
  <li><strong>pageByManual$</strong>: which contains page numbers based on manual events (for instance, if there is still whitespace on the screen, we have to load the next page)</li>
</ul>

<p>What if we could merge these 3 page-number streams in an efficient manner, than we would get a new stream called <strong>pageToLoad$</strong>, that would contain page numbers created by scrolling-events, resize-events, and manual events.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard4.png" alt="Whiteboard 4" /></p>

<p>If we subscribe to the pageToLoad$ stream and than fetch data from the service, part of our infinite scroll would work. However, we were thinking reactively right? That also means, avoid subscriptions as much as possible… 
We actually need a new stream based on the pageToLoad$ stream that contains the results of our infinite scroll list…</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard5.png" alt="Whiteboard 5" /></p>

<p>Now let’s throw this in one big schema.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard6.png" alt="Whiteboard 6" /></p>

<p>As we can see above we have 3 input streams: one for scrolling, one for resizing and a manual one.
Afterwards we have 3 page streams that are based on the input streams. When merging these streams we can create a pageToLoad$ stream. Based on that pageToLoad$ stream, we will fetch the data.</p>

<h2 id="lets-code">Let’s code</h2>

<p>We have drawn more than enough, we have a clear vision of what our inifinte-scroll-list should do, so let’s start shall we?</p>

<p>To calculate which page needs to be loaded we need 2 properties:</p>

<pre><code class="language-typescript">private itemHeight = 40;
private numberOfItems = 10;// number of items in a page
</code></pre>

<h3 id="pagebyscroll">pageByScroll$</h3>

<p>The pageByScroll$ stream might look something like this:</p>

<pre><code class="language-typescript"> private pageByScroll$ = 
 	// first of all, we want to create a stream that contains 
 	// all the scroll events that are happening in the window object
	Observable.fromEvent(window, "scroll") 
	// we are only interested in the scrollY value of these events
	// let's create a stream with only these values
	.map(() =&gt; window.scrollY)
	// create a stream with the filtered values
	// we only need the values from when we are scrolling outside
	// our viewport
	.filter(current =&gt; current &gt;=  document.body.clientHeight - window.innerHeight)
	// Only when the user stops scrolling for 200 ms, we can continue
	// so let's debounce this stream for 200 ms
	.debounceTime(200) 
	// filter out double values
	.distinct() 
	// calculate the page number
	.map(y =&gt; Math.ceil((y + window.innerHeight)/ (this.itemHeight * this.numberOfItems)));
	
	// --------1---2----3------2...
</code></pre>

<p><strong>note: In real applications you might want to use injected services for window and document</strong></p>

<h3 id="pagebyresize">pageByResize$</h3>

<p>The pageByResize$ looks like this:</p>

<pre><code class="language-typescript">  private pageByResize$ = 
  	// Now, we want to create a new stream that contains 
 	// all the resize events that are happening in the window object
	Observable.fromEvent(window, "resize")
	// when the user stops resizing for 200 ms, then we can continue
	.debounceTime(200) 
	// calculate the page number based on the window
   .map(_ =&gt; Math.ceil(
	   	(window.innerHeight + document.body.scrollTop) / 
	   	(this.itemHeight * this.numberOfItems)
   	));
   
	// --------1---2----3------2...
</code></pre>

<h3 id="pagebymanual">pageByManual$</h3>

<p>The pageByManual$ is the stream we use to have an initial value (initial page to load), but it’s also something that we need to control manually. A <a href="http://reactivex.io/documentation/subject.html">Behavior subject</a> looks perfect for the job, because we need a stream that has an initial value where we can also manually add values. A behavior subject is just a stream that has an initial value and can be manipulated over time.</p>

<pre><code class="language-typescript">private pageByManual$ = new BehaviorSubject(1);

// 1---2----3------...
</code></pre>

<h3 id="pagetoload">pageToLoad$</h3>

<p>Awesome, we have the 3 streams with page inputs, now let’s create a pageToLoad$ stream.</p>

<pre><code class="language-typescript">private pageToLoad$ = 
	// merge all the page streams and create a new stream of those
	Observable.merge(this.pageByManual$, this.pageByScroll$, this.pageByResize$)
	// create a new stream where the double values are filtered out
	.distinct() 
	// check if the page is already in the cache (just an array property in our component)
	.filter(page =&gt; this.cache[page-1] === undefined); 
</code></pre>

<h3 id="itemresults">itemResults$</h3>

<p>The hard part is over. We now have a stream with the page we have to load in there, which is super useful. We don’t need to care anymore about corner cases or other complex logic. Every time a new value in that stream is added, we just need to load the data. <strong>That’s it!!</strong></p>

<p>We will use <a href="http://reactivex.io/documentation/operators/flatmap.html">flatmap</a> for this because the fetch-data-call will return a stream as well. FlatMap (or MergeMap) will merge these 2 streams as one.</p>

<pre><code class="language-typescript">itemResults$ = this.pageToLoad$ 
	// based on that stream, load our asynchronosly data
	// flatmap is an alias for mergemap
	.flatMap((page: number) =&gt; {
		// load me some starwars characters
		return this.http.get(`https://swapi.co/api/people?page=${page}`)
			// create a stream that contains the results
			.map(resp =&gt; resp.json().results)
			.do(resp =&gt; {
				// add the page to the cache
				this.cache[page -1] = resp;
				// if the page contains enough white space, load some more data :)
				if((this.itemHeight * this.numberOfItems * page) &lt; window.innerHeight){
					this.pageByManual$.next(page + 1);
				}
			})
		})
	// eventually, just return a stream that contains the cache
	.map(_ =&gt; flatMap(this.cache)); 
</code></pre>

<h3 id="the-result">The result</h3>

<p>the complete result might look like this:  <strong>Note the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#!#async-pipe">async pipe</a> that puts the whole subscription process into play</strong></p>

<pre><code class="language-typescript">@Component({
  selector: 'infinite-scroll-list',
  template: `
  &lt;table&gt;
   &lt;tbody&gt;
    &lt;tr *ngFor="let item of itemResults$|async" [style.height]="itemHeight + 'px'"&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
   &lt;/tbody&gt;
   &lt;/table&gt;
  `
})
export class InfiniteScrollListComponent {
  private cache = []; 
  private pageByManual$ = new BehaviorSubject(1);
  private itemHeight = 40;
  private numberOfItems = 10; 
  private pageByScroll$ = Observable.fromEvent(window, "scroll")
      .map(() =&gt; window.scrollY)
      .filter(current =&gt; current &gt;=  document.body.clientHeight - window.innerHeight)
      .debounceTime(200) 
      .distinct() 
      .map(y =&gt; Math.ceil((y + window.innerHeight)/ (this.itemHeight * this.numberOfItems)));
       
  private pageByResize$ = 
	Observable.fromEvent(window, "resize")
	.debounceTime(200) 
	.map(_ =&gt; Math.ceil(
	   	(window.innerHeight + document.body.scrollTop) / 
	   	(this.itemHeight * this.numberOfItems)
   	));

    
  private pageToLoad$ = Observable
    .merge(this.pageByManual$, this.pageByScroll$, this.pageByResize$)
    .distinct() 
    .filter(page =&gt; this.cache[page-1] === undefined); 
    
  itemResults$ = this.pageToLoad$ 
    .do(_ =&gt; this.loading = true)
    .flatMap((page: number) =&gt; {
      return this.http.get(`https://swapi.co/api/people?page=${page}`)
          .map(resp =&gt; resp.json().results)
      		.do(resp =&gt; {
				this.cache[page -1] = resp;
				if((this.itemHeight * this.numberOfItems * page) &lt; window.innerHeight){
					this.pageByManual$.next(page + 1);
				}
          })
    })
    .map(_ =&gt; flatMap(this.cache)); 
  
  constructor(private http: Http){ 
  } 
}
</code></pre>

<p>Here is a <a href="http://plnkr.co/edit/WewXnQRj9xBA7yPveWLQ?p=preview">working plunk</a></p>

<iframe src="https://embed.plnkr.co/plunk/WewXnQRj9xBA7yPveWLQ?show=app,preview&amp;deferRun" frameborder="0" width="100%" height="480px">
</iframe>

<p>Again, (like I try to prove in previous articles) We don’t need to use third party solutions for everything. The infinite-scroll-list doesn’t contain that much code, and it’s very flexible.
Let’s say that we would like to free up DOM-elements and use only 100 items at a time, we could just create a new stream for that :)</p>

<p>Thanks for reading, I hope you enjoyed it.</p>

	  ]]></description>
	</item>


</channel>
</rss>
